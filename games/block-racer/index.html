<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Block Racer - Free HTML5 Game</title>
<meta name="description" content="Play Block Racer - Swipe to switch lanes and dodge multiplying pixel obstacles on a retro highway.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0a1a">
<meta property="og:title" content="Block Racer - Free HTML5 Game">
<meta property="og:description" content="Play Block Racer - Swipe to switch lanes and dodge multiplying pixel obstacles on a retro neon highway. Trigger Perfect Cuts for combo multipliers!">
<meta property="og:type" content="website">
<meta property="og:url" content="https://balinti.github.io/block-racer/">
<meta property="og:image" content="https://balinti.github.io/block-racer/preview.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Block Racer - Free HTML5 Game">
<meta name="twitter:description" content="Dodge multiplying glitch blocks and trigger Perfect Cuts on a neon highway!">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
  *{margin:0;padding:0;box-sizing:border-box;}
  html,body{
    width:100%;height:100%;
    background:#0a0a1a;
    display:flex;flex-direction:column;
    align-items:center;justify-content:flex-start;
    font-family:'Segoe UI',system-ui,sans-serif;
    overflow-x:hidden;
    color:#e0e0ff;
  }
  #game-wrap{
    position:relative;
    width:100%;max-width:420px;
    flex:1;display:flex;flex-direction:column;
    align-items:center;
  }
  canvas{
    display:block;
    width:100%;
    max-width:420px;
    max-height:750px;
    touch-action:none;
    cursor:pointer;
    background:#0a0a1a;
  }
  #info{
    width:100%;max-width:420px;
    padding:14px 18px 24px;
    font-size:13px;line-height:1.6;
    color:#8080aa;
    text-align:center;
  }
  #info h2{font-size:15px;color:#a0a0cc;margin-bottom:6px;}
  #info strong{color:#c0c0ee;}
</style>
</head>
<body>
<div id="game-wrap">
<canvas id="c"></canvas>
</div>
<div id="info">
  <h2>How to Play Block Racer</h2>
  <p>Tap <strong>left half</strong> to move left, <strong>right half</strong> to move right. Use <strong>arrow keys</strong> or <strong>A/D</strong> on keyboard. Time your lane switch at the last moment for a <strong>Perfect Cut</strong> — triggers slow-mo, a score burst, and builds your combo multiplier up to x4! Watch out for <strong>Glitch Blocks</strong> that split into two Echo Blocks after passing you.</p>
</div>
<script>
(()=>{
"use strict";

// ── Canvas setup ──────────────────────────────────────────────────────────────
const canvas = document.getElementById('c');
const ctx    = canvas.getContext('2d');

const MAX_W = 420, MAX_H = 750;
const DPR    = Math.min(window.devicePixelRatio||1, 2);

function resize(){
  const wrap = document.getElementById('game-wrap');
  const cw = Math.min(wrap.clientWidth, MAX_W);
  const ch = Math.min(Math.round(cw * (MAX_H/MAX_W)), window.innerHeight - 100, MAX_H);
  canvas.style.width  = cw+'px';
  canvas.style.height = ch+'px';
  canvas.width  = Math.round(cw*DPR);
  canvas.height = Math.round(ch*DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  GAME.logicW = cw;
  GAME.logicH = ch;
  computeLanes();
}

// ── Game state singleton ──────────────────────────────────────────────────────
const GAME = {
  state:'start',     // 'start'|'playing'|'gameover'
  logicW:MAX_W, logicH:MAX_H,
  score:0, best:0, combo:1, comboPerfects:0,
  t:0,               // seconds since game start
  worldSpeed:260,
  spawnTimer:0,
  spawnIdx:0,
  dashOffset:0,
  roadHue:200,
  shakeMag:0, shakeX:0, shakeY:0,
  timeScale:1,
  timeScaleTimer:0,
  slowmoDur:0,
  scoreTimer:0,      // accumulated time for +1 scoring
};

// ── Best score ────────────────────────────────────────────────────────────────
const LS_KEY = 'br_glitchsplit_best';
function loadBest(){ GAME.best = parseInt(localStorage.getItem(LS_KEY)||'0',10)||0; }
function saveBest(){ if(GAME.score>GAME.best){GAME.best=GAME.score;localStorage.setItem(LS_KEY,GAME.best);} }
loadBest();

// ── Lanes ─────────────────────────────────────────────────────────────────────
const NUM_LANES = 4;
let ROAD_L=0, ROAD_R=0, LANE_W=0;
let LANE_CENTERS=[];

function computeLanes(){
  const margin = Math.round(GAME.logicW*0.10);
  ROAD_L = margin;
  ROAD_R = GAME.logicW - margin;
  LANE_W = (ROAD_R - ROAD_L) / NUM_LANES;
  LANE_CENTERS = Array.from({length:NUM_LANES},(_,i)=> ROAD_L + LANE_W*i + LANE_W/2);
}
computeLanes();

// ── Player ────────────────────────────────────────────────────────────────────
const player = {
  lane:1,            // 0-3
  x:0,               // current x (interpolated)
  y:0,               // set on resize
  w:28, h:36,
  speed:0,
  trail:[],
  alive:true,
};
function resetPlayer(){
  player.lane = 1;
  player.x    = LANE_CENTERS[player.lane];
  player.y    = Math.round(GAME.logicH * 0.80);
  player.trail= [];
  player.alive= true;
}

// ── Obstacles ─────────────────────────────────────────────────────────────────
// type: 'glitch'|'echo'|'shield'
let obstacles = [];

const OBS_W = 30, OBS_H = 30;
const ECHO_W = 22, ECHO_H = 22;
const SHIELD_W = 30, SHIELD_H = 30;

// ── Particles ─────────────────────────────────────────────────────────────────
let particles = [];
const MAX_PARTICLES = 420;

function spawnParticles(recipe, x, y, extra){
  if(particles.length >= MAX_PARTICLES) return;
  const slots = MAX_PARTICLES - particles.length;
  let ps = [];
  switch(recipe){
    case 'near-miss':
      for(let i=0;i<8&&i<slots;i++){
        const a=Math.random()*Math.PI*2, s=60+Math.random()*80;
        ps.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:1,maxLife:0.5+Math.random()*0.3,
                 r:2+Math.random()*2,hue:extra?.hue||60,bright:90});
      }
      break;
    case 'echo-spawn':
      for(let i=0;i<6&&i<slots;i++){
        const a=Math.random()*Math.PI*2, s=40+Math.random()*60;
        ps.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:1,maxLife:0.3+Math.random()*0.2,
                 r:2,hue:extra?.hue||280,bright:80});
      }
      break;
    case 'perfect-cut':
      for(let i=0;i<24&&i<slots;i++){
        const a=-Math.PI/2 + (Math.random()-0.5)*Math.PI*1.2, s=80+Math.random()*200;
        ps.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:1,maxLife:0.4+Math.random()*0.4,
                 r:2+Math.random()*4,hue:extra?.hue||180,bright:95});
      }
      break;
    case 'crash':
      for(let i=0;i<40&&i<slots;i++){
        const a=Math.random()*Math.PI*2, s=50+Math.random()*200;
        ps.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:1,maxLife:0.6+Math.random()*0.6,
                 r:3+Math.random()*5,hue:extra?.hue||0,bright:80+Math.random()*20});
      }
      break;
  }
  particles.push(...ps);
}

// ── Slash effect ──────────────────────────────────────────────────────────────
let slashes = [];
function spawnSlash(x,y,hue){
  slashes.push({x,y,life:1,hue});
}

// ── Input ─────────────────────────────────────────────────────────────────────
let pendingDir = 0; // -1 left, +1 right

canvas.addEventListener('pointerdown', e=>{
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const lx = (e.clientX - rect.left) / rect.width;
  if(GAME.state==='start'||GAME.state==='gameover'){
    startGame(); return;
  }
  pendingDir = lx < 0.5 ? -1 : 1;
});

window.addEventListener('keydown', e=>{
  if(e.key===' '||e.key==='Enter'){
    if(GAME.state!=='playing'){ startGame(); return; }
  }
  if(GAME.state!=='playing') return;
  if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') pendingDir=-1;
  if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') pendingDir=1;
});

// ── Game control ──────────────────────────────────────────────────────────────
function startGame(){
  GAME.state='playing';
  GAME.score=0; GAME.combo=1; GAME.comboPerfects=0;
  GAME.t=0; GAME.worldSpeed=260;
  GAME.spawnTimer=0; GAME.spawnIdx=0;
  GAME.dashOffset=0; GAME.roadHue=200;
  GAME.shakeMag=0; GAME.timeScale=1;
  GAME.timeScaleTimer=0; GAME.slowmoDur=0;
  GAME.scoreTimer=0;
  obstacles=[];
  particles=[];
  slashes=[];
  pendingDir=0;
  resetPlayer();
}

function triggerGameOver(){
  GAME.state='gameover';
  player.alive=false;
  GAME.shakeMag=14;
  saveBest();
  spawnParticles('crash', player.x, player.y, {hue:0});
}

// ── Lane-switch + Perfect Cut ─────────────────────────────────────────────────
function doLaneSwitch(dir){
  const newLane = player.lane + dir;
  if(newLane<0||newLane>=NUM_LANES) return;

  // Check perfect cut
  let perfectCut = false;
  let clearedEchoes = 0;

  // Find closest obstacle in target lane ahead (above player)
  let closest = null, closestGap = Infinity;
  for(const o of obstacles){
    if(o.lane!==newLane) continue;
    const obsBottom = o.y + o.h/2;
    const playerTop = player.y - player.h/2;
    const gap = playerTop - obsBottom;
    if(gap>0 && gap < closestGap){ closestGap=gap; closest=o; }
  }

  if(closest && closestGap>=8 && closestGap<=34){
    perfectCut=true;
    GAME.comboPerfects++;
    GAME.combo = Math.min(4, 1+Math.floor(GAME.comboPerfects/2));

    // Slow-mo
    GAME.timeScale = 0.35;
    GAME.slowmoDur = 0.18;
    GAME.timeScaleTimer = GAME.slowmoDur;

    // Score burst
    const bonus = 5 * GAME.combo;
    GAME.score += bonus;

    // Clear echo blocks in entered lane within forward band
    const bandTop  = player.y - 320;
    const bandBot  = player.y;
    obstacles = obstacles.filter(o=>{
      if(o.type==='echo'&&o.lane===newLane&&o.y>=bandTop&&o.y<=bandBot){
        clearedEchoes++;
        spawnParticles('echo-spawn',LANE_CENTERS[newLane],o.y,{hue:GAME.roadHue});
        return false;
      }
      return true;
    });
    GAME.score += clearedEchoes;

    // Slash + particles
    spawnSlash(LANE_CENTERS[newLane], player.y-player.h/2, GAME.roadHue);
    spawnParticles('perfect-cut', LANE_CENTERS[newLane], player.y, {hue:(GAME.roadHue+60)%360});

    // Screen shake
    GAME.shakeMag = 4;
  } else {
    // Not a perfect cut: decay combo
    GAME.comboPerfects = Math.max(0, GAME.comboPerfects-1);
    if(GAME.comboPerfects===0) GAME.combo=1;
    else GAME.combo = Math.min(4, 1+Math.floor(GAME.comboPerfects/2));
  }

  player.lane = newLane;
}

// ── Spawn logic ───────────────────────────────────────────────────────────────
function getSpawnInterval(){ return Math.max(0.42, Math.min(0.95, 0.95 - 0.010*GAME.t)); }

function spawnObstacles(){
  GAME.spawnIdx++;
  const t = GAME.t;

  // Double glitch every 9th spawn
  if(GAME.spawnIdx % 9 === 0){
    // Pick two lanes that avoid player lane if possible
    const lanes = [0,1,2,3].filter(l=>l!==player.lane);
    shuffle(lanes);
    const l1=lanes[0], l2=lanes[1];
    spawnOne('glitch',l1);
    spawnOne('glitch',l2);
    return;
  }

  // Normal spawn
  const roll = Math.random();
  let type;
  if(t<25){
    type = roll<0.85 ? 'glitch' : 'shield';
  } else {
    type = roll<0.70 ? 'glitch' : 'shield';
  }
  const lane = Math.floor(Math.random()*NUM_LANES);
  spawnOne(type,lane);
}

function spawnOne(type,lane){
  const w = type==='echo'?ECHO_W:type==='glitch'?OBS_W:SHIELD_W;
  const h = type==='echo'?ECHO_H:OBS_H;
  obstacles.push({
    type, lane,
    x: LANE_CENTERS[lane],
    y: -(h/2+5),
    w, h,
    hue: type==='glitch' ? 300 : type==='shield' ? 60 : 200,
    passed: false,
    echoSpawned: false,
    speed: GAME.worldSpeed*(type==='echo'?1.08:1),
  });
}

function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.random()*(i+1)|0; [arr[i],arr[j]]=[arr[j],arr[i]]; } }

// ── Glitch split ──────────────────────────────────────────────────────────────
function processGlitchSplit(){
  const pBottom = player.y + player.h/2;
  for(const o of obstacles){
    if(o.type!=='glitch'||o.echoSpawned) continue;
    const oTop = o.y - o.h/2;
    if(oTop > pBottom){
      // Passed the player
      o.echoSpawned = true;
      if(obstacles.length>18) continue;
      const t = GAME.t;
      const echoLead = Math.max(150, Math.min(260, 260-2.2*t));
      const echoY = player.y - echoLead;
      const adjLanes=[];
      if(o.lane>0) adjLanes.push(o.lane-1);
      if(o.lane<NUM_LANES-1) adjLanes.push(o.lane+1);
      for(const al of adjLanes){
        if(obstacles.length>18) break;
        const echo = {
          type:'echo', lane:al,
          x:LANE_CENTERS[al],
          y:echoY,
          w:ECHO_W, h:ECHO_H,
          hue:280,
          passed:false, echoSpawned:true,
          speed: GAME.worldSpeed*1.08,
        };
        obstacles.push(echo);
        spawnParticles('echo-spawn',LANE_CENTERS[al],echoY,{hue:280});
      }
    }
  }
}

// ── Collision ─────────────────────────────────────────────────────────────────
function checkCollision(){
  const px=player.x, py=player.y;
  const ph=player.h/2-3, pw=player.w/2-3;
  for(const o of obstacles){
    const dx=Math.abs(px-o.x), dy=Math.abs(py-o.y);
    if(dx<pw+o.w/2-2 && dy<ph+o.h/2-2){
      triggerGameOver(); return;
    }
  }
}

// ── Near-miss ─────────────────────────────────────────────────────────────────
let nearMissSet = new WeakSet();
function checkNearMiss(){
  const py=player.y, px=player.x;
  for(const o of obstacles){
    if(nearMissSet.has(o)) continue;
    const dy=Math.abs(py-o.y);
    const dx=Math.abs(px-o.x);
    if(dy<55 && dx>player.w/2+o.w/2 && dx < player.w/2+o.w/2+30){
      nearMissSet.add(o);
      GAME.score+=2;
      spawnParticles('near-miss',px,py,{hue:60});
    }
  }
}

// ── Update ────────────────────────────────────────────────────────────────────
let lastTime=0;
function update(ts){
  const raw = lastTime===0 ? 0.016 : (ts-lastTime)/1000;
  lastTime = ts;
  const dt  = Math.min(raw,0.05) * GAME.timeScale;

  if(GAME.state!=='playing'){ return; }

  // Time scale ease-back
  if(GAME.timeScaleTimer>0){
    GAME.timeScaleTimer -= raw;
    if(GAME.timeScaleTimer<=0){ GAME.timeScale=1; GAME.timeScaleTimer=0; }
    else {
      const prog = 1-(GAME.timeScaleTimer/GAME.slowmoDur);
      GAME.timeScale = 0.35 + (1-0.35)*easeOut(prog);
    }
  }

  GAME.t += dt;

  // Process pending input
  if(pendingDir!==0){
    doLaneSwitch(pendingDir);
    pendingDir=0;
  }

  // World speed ramp
  GAME.worldSpeed = Math.min(520, 260 + 6*GAME.t);

  // Road hue
  GAME.roadHue = (200 + GAME.t*12) % 360;

  // Dash offset
  GAME.dashOffset = (GAME.dashOffset + GAME.worldSpeed*dt*0.5) % 40;

  // Score by distance
  GAME.scoreTimer += dt;
  if(GAME.scoreTimer>=0.3){ GAME.scoreTimer=0; GAME.score+=1; }

  // Spawn
  GAME.spawnTimer -= dt;
  if(GAME.spawnTimer<=0){
    spawnObstacles();
    GAME.spawnTimer = getSpawnInterval();
  }

  // Player x interpolation
  const targetX = LANE_CENTERS[player.lane];
  player.x += (targetX - player.x) * Math.min(1, 12*dt);

  // Player trail
  player.trail.unshift({x:player.x, y:player.y});
  if(player.trail.length>8) player.trail.pop();

  // Move obstacles
  for(const o of obstacles){
    o.y += o.speed * dt;
    o.x += (LANE_CENTERS[o.lane]-o.x)*Math.min(1,10*dt);
  }

  // Glitch split
  processGlitchSplit();

  // Remove off-screen obstacles
  obstacles = obstacles.filter(o=>o.y < GAME.logicH + 60);

  // Collision
  if(player.alive) checkCollision();

  // Near miss
  if(player.alive) checkNearMiss();

  // Particles
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx*dt; p.y+=p.vy*dt;
    p.vy+=120*dt; // gravity
    p.life-=dt/p.maxLife;
    if(p.life<=0) particles.splice(i,1);
  }

  // Slashes
  for(let i=slashes.length-1;i>=0;i--){
    slashes[i].life-=dt/0.3;
    if(slashes[i].life<=0) slashes.splice(i,1);
  }

  // Screen shake decay
  if(GAME.shakeMag>0){
    GAME.shakeMag = Math.max(0, GAME.shakeMag - 20*dt);
    GAME.shakeX = (Math.random()-0.5)*GAME.shakeMag*2;
    GAME.shakeY = (Math.random()-0.5)*GAME.shakeMag*2;
  } else { GAME.shakeX=0; GAME.shakeY=0; }
}

function easeOut(t){ return 1-(1-t)*(1-t); }

// ── Draw ──────────────────────────────────────────────────────────────────────
function draw(){
  const W=GAME.logicW, H=GAME.logicH;
  ctx.clearRect(0,0,W,H);

  // Background gradient
  const bg=ctx.createLinearGradient(0,0,0,H);
  bg.addColorStop(0,`hsl(${GAME.roadHue},60%,5%)`);
  bg.addColorStop(1,`hsl(${(GAME.roadHue+40)%360},50%,8%)`);
  ctx.fillStyle=bg;
  ctx.fillRect(0,0,W,H);

  // World shake
  ctx.save();
  ctx.translate(GAME.shakeX, GAME.shakeY);

  // Road
  ctx.fillStyle=`hsl(${GAME.roadHue},30%,10%)`;
  ctx.fillRect(ROAD_L,0,ROAD_R-ROAD_L,H);

  // Road edge glow
  const gL=ctx.createLinearGradient(ROAD_L-12,0,ROAD_L+8,0);
  gL.addColorStop(0,'transparent');
  gL.addColorStop(1,`hsla(${GAME.roadHue},80%,55%,0.5)`);
  ctx.fillStyle=gL; ctx.fillRect(ROAD_L-12,0,20,H);
  const gR=ctx.createLinearGradient(ROAD_R-8,0,ROAD_R+12,0);
  gR.addColorStop(0,`hsla(${GAME.roadHue},80%,55%,0.5)`);
  gR.addColorStop(1,'transparent');
  ctx.fillStyle=gR; ctx.fillRect(ROAD_R-8,0,20,H);

  // Lane separators (dashed)
  ctx.strokeStyle=`hsla(${GAME.roadHue},60%,55%,0.3)`;
  ctx.lineWidth=1.5;
  ctx.setLineDash([18,22]);
  for(let i=1;i<NUM_LANES;i++){
    const lx=ROAD_L+LANE_W*i;
    ctx.lineDashOffset=-GAME.dashOffset;
    ctx.beginPath(); ctx.moveTo(lx,0); ctx.lineTo(lx,H); ctx.stroke();
  }
  ctx.setLineDash([]);

  // Combo overlay tint
  if(GAME.combo>=2&&GAME.state==='playing'){
    const alpha=0.04*(GAME.combo-1);
    ctx.fillStyle=`hsla(${(GAME.roadHue+180)%360},80%,60%,${alpha})`;
    ctx.fillRect(ROAD_L,0,ROAD_R-ROAD_L,H);
  }

  // Player trail
  for(let i=1;i<player.trail.length;i++){
    const t=player.trail[i];
    const a=(1-i/player.trail.length)*0.35;
    const scale=1-i/player.trail.length*0.5;
    ctx.fillStyle=`hsla(${GAME.roadHue},80%,60%,${a})`;
    const tw=player.w*scale, th=player.h*scale;
    ctx.fillRect(t.x-tw/2, t.y-th/2, tw, th);
  }

  // Obstacles
  for(const o of obstacles){
    const cx=o.x, cy=o.y;
    const hw=o.w/2, hh=o.h/2;
    let hue=o.hue;
    if(o.type==='glitch') hue=(hue+GAME.t*60)%360;
    if(o.type==='echo')   hue=(hue+GAME.t*90)%360;

    // Glow
    const glow=ctx.createRadialGradient(cx,cy,0,cx,cy,o.w*0.8);
    glow.addColorStop(0,`hsla(${hue},90%,65%,0.4)`);
    glow.addColorStop(1,`hsla(${hue},90%,65%,0)`);
    ctx.fillStyle=glow;
    ctx.fillRect(cx-o.w,cy-o.h,o.w*2,o.h*2);

    // Body
    ctx.fillStyle=`hsl(${hue},80%,58%)`;
    ctx.fillRect(cx-hw,cy-hh,o.w,o.h);

    // Inner highlight
    ctx.fillStyle=`hsla(${hue},80%,85%,0.5)`;
    ctx.fillRect(cx-hw+3,cy-hh+3,o.w-6,o.h/3);

    // Echo marker
    if(o.type==='echo'){
      ctx.strokeStyle=`hsla(${hue},90%,80%,0.9)`;
      ctx.lineWidth=2;
      ctx.strokeRect(cx-hw+2,cy-hh+2,o.w-4,o.h-4);
    }

    // Glitch noise lines
    if(o.type==='glitch'){
      ctx.strokeStyle=`hsla(${(hue+180)%360},90%,70%,0.6)`;
      ctx.lineWidth=1.5;
      for(let g=0;g<2;g++){
        const gy=cy-hh+4+(g*(o.h-8)/2);
        const gOff=(Math.sin(GAME.t*8+g)*4);
        ctx.beginPath();
        ctx.moveTo(cx-hw+2+gOff,gy);
        ctx.lineTo(cx+hw-2+gOff,gy);
        ctx.stroke();
      }
    }

    // Shield badge
    if(o.type==='shield'){
      ctx.fillStyle=`hsla(${hue},80%,85%,0.9)`;
      ctx.font=`bold ${o.w*0.55}px monospace`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText('▣',cx,cy);
    }
  }

  // Player
  if(player.alive||GAME.state==='gameover'){
    const px=player.x, py=player.y;
    const hw=player.w/2, hh=player.h/2;
    const ph=GAME.roadHue;

    // Player glow
    const pg=ctx.createRadialGradient(px,py,0,px,py,player.w);
    pg.addColorStop(0,`hsla(${ph},90%,70%,0.5)`);
    pg.addColorStop(1,`hsla(${ph},90%,70%,0)`);
    ctx.fillStyle=pg;
    ctx.fillRect(px-player.w,py-player.h,player.w*2,player.h*2);

    // Car body
    ctx.fillStyle=`hsl(${ph},85%,62%)`;
    ctx.fillRect(px-hw,py-hh,player.w,player.h);

    // Windshield
    ctx.fillStyle=`hsla(${ph},60%,85%,0.7)`;
    ctx.fillRect(px-hw+4,py-hh+4,player.w-8,player.h*0.4);

    // Wheels
    ctx.fillStyle='#111';
    ctx.fillRect(px-hw-2,py-hh+4,5,8);
    ctx.fillRect(px+hw-3,py-hh+4,5,8);
    ctx.fillRect(px-hw-2,py+hh-12,5,8);
    ctx.fillRect(px+hw-3,py+hh-12,5,8);
  }

  // Particles
  for(const p of particles){
    const a=Math.max(0,p.life);
    ctx.fillStyle=`hsla(${p.hue},85%,${p.bright}%,${a})`;
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.r*p.life,0,Math.PI*2);
    ctx.fill();
  }

  // Slashes
  for(const s of slashes){
    const a=s.life;
    ctx.save();
    ctx.translate(s.x,s.y);
    ctx.strokeStyle=`hsla(${s.hue},90%,85%,${a})`;
    ctx.lineWidth=3*a;
    ctx.lineCap='round';
    const len=60*a;
    ctx.beginPath();
    ctx.moveTo(-len*0.3,-len);
    ctx.lineTo(len*0.3,0);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-len*0.2,-len*0.5);
    ctx.lineTo(len*0.2,len*0.5);
    ctx.stroke();
    ctx.restore();
  }

  ctx.restore(); // end shake

  // ── UI (no shake) ────────────────────────────────────────────────────────
  if(GAME.state==='playing'){
    // Score
    ctx.font='bold 22px monospace';
    ctx.fillStyle='#fff';
    ctx.textAlign='right';
    ctx.textBaseline='top';
    ctx.fillText(GAME.score, W-12, 10);

    // Best
    ctx.font='13px monospace';
    ctx.fillStyle='#8080aa';
    ctx.fillText('BEST '+GAME.best, W-12, 36);

    // Combo
    if(GAME.combo>=2){
      ctx.font=`bold ${14+GAME.combo*3}px monospace`;
      const cHue=(GAME.roadHue+180)%360;
      ctx.fillStyle=`hsl(${cHue},90%,65%)`;
      ctx.textAlign='left';
      ctx.fillText(`×${GAME.combo}`, 12, 10);
    }

    // Speed indicator
    ctx.font='11px monospace';
    ctx.fillStyle='rgba(255,255,255,0.3)';
    ctx.textAlign='center';
    ctx.fillText(`${Math.round(GAME.worldSpeed)} km/h`, W/2, 8);
  }

  // ── Start screen ─────────────────────────────────────────────────────────
  if(GAME.state==='start'){
    ctx.fillStyle='rgba(0,0,20,0.72)';
    ctx.fillRect(0,0,W,H);

    // Animated road preview
    drawStartRoadPreview(W,H);

    ctx.textAlign='center';

    // Title
    const titleY=H*0.28;
    ctx.font=`bold 42px monospace`;
    ctx.fillStyle='transparent';
    const tg=ctx.createLinearGradient(W/2-90,titleY,W/2+90,titleY);
    tg.addColorStop(0,`hsl(${GAME.roadHue},90%,65%)`);
    tg.addColorStop(1,`hsl(${(GAME.roadHue+80)%360},90%,65%)`);
    ctx.fillStyle=tg;
    ctx.fillText('BLOCK',W/2,titleY);
    ctx.fillText('RACER',W/2,titleY+48);

    ctx.font='14px monospace';
    ctx.fillStyle='rgba(200,200,255,0.55)';
    ctx.fillText('GLITCH SPLIT EDITION',W/2,titleY+80);

    // Subtitle
    ctx.font='bold 16px monospace';
    ctx.fillStyle='rgba(255,255,255,0.85)';
    const pulse=0.7+0.3*Math.sin(Date.now()/300);
    ctx.globalAlpha=pulse;
    ctx.fillText('TAP TO START',W/2,H*0.60);
    ctx.globalAlpha=1;

    // Tips
    ctx.font='12px monospace';
    ctx.fillStyle='rgba(160,160,220,0.7)';
    ctx.fillText('Tap left / right to change lanes',W/2,H*0.68);
    ctx.fillText('Perfect Cut = last-moment switch',W/2,H*0.74);
    ctx.fillText('Glitch blocks split into Echoes!',W/2,H*0.80);

    if(GAME.best>0){
      ctx.font='bold 14px monospace';
      ctx.fillStyle=`hsl(${GAME.roadHue},80%,65%)`;
      ctx.fillText('BEST: '+GAME.best, W/2, H*0.87);
    }
  }

  // ── Gameover screen ───────────────────────────────────────────────────────
  if(GAME.state==='gameover'){
    ctx.fillStyle='rgba(0,0,10,0.78)';
    ctx.fillRect(0,0,W,H);

    ctx.textAlign='center';

    ctx.font='bold 36px monospace';
    ctx.fillStyle='#ff4466';
    ctx.fillText('GAME OVER',W/2,H*0.28);

    ctx.font='bold 26px monospace';
    ctx.fillStyle='#ffffff';
    ctx.fillText('SCORE: '+GAME.score,W/2,H*0.40);

    ctx.font='16px monospace';
    ctx.fillStyle=`hsl(${GAME.roadHue},80%,65%)`;
    ctx.fillText('BEST: '+GAME.best,W/2,H*0.49);

    ctx.font='bold 15px monospace';
    ctx.fillStyle='rgba(255,255,255,0.85)';
    const pulse=0.7+0.3*Math.sin(Date.now()/300);
    ctx.globalAlpha=pulse;
    ctx.fillText('TAP TO RETRY',W/2,H*0.61);
    ctx.globalAlpha=1;

    if(GAME.comboPerfects>0||GAME.combo>1){
      ctx.font='13px monospace';
      ctx.fillStyle='rgba(180,180,255,0.7)';
      ctx.fillText(`Max Combo ×${GAME.combo}`,W/2,H*0.69);
    }
  }
}

function drawStartRoadPreview(W,H){
  // Simple moving road lines for start screen
  ctx.save();
  ctx.globalAlpha=0.25;
  const rl=ROAD_L, rw=ROAD_R-ROAD_L;
  ctx.fillStyle=`hsl(${GAME.roadHue},25%,15%)`;
  ctx.fillRect(rl,0,rw,H);
  ctx.strokeStyle=`hsla(${GAME.roadHue},60%,55%,0.5)`;
  ctx.lineWidth=1.5;
  ctx.setLineDash([18,22]);
  const off=(Date.now()*0.1)%40;
  for(let i=1;i<NUM_LANES;i++){
    const lx=ROAD_L+LANE_W*i;
    ctx.lineDashOffset=-off;
    ctx.beginPath(); ctx.moveTo(lx,0); ctx.lineTo(lx,H); ctx.stroke();
  }
  ctx.setLineDash([]);
  ctx.restore();
}

// ── Game loop ─────────────────────────────────────────────────────────────────
function loop(ts){
  update(ts);
  draw();
  requestAnimationFrame(loop);
}

// ── Init ──────────────────────────────────────────────────────────────────────
window.addEventListener('resize', resize);
resize();
resetPlayer();
requestAnimationFrame(loop);

})();
</script>
<noscript>Enable JavaScript to play Block Racer.</noscript>
</body>
</html>
