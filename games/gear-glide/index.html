<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Gear Glide - Free HTML5 Game</title>
<meta name="description" content="Play Gear Glide - Tap to glide your clockwork drone through multiplying rotating gears in a vintage industrial setting.">
<meta name="theme-color" content="#1a1a2e">
<meta property="og:type" content="website">
<meta property="og:title" content="Gear Glide - Free HTML5 Game">
<meta property="og:description" content="Tap to phase-lock rotating gears and glide your clockwork drone through an industrial gauntlet. How far can you go?">
<meta property="og:url" content="https://balinti.github.io/gear-glide/">
<meta property="og:image" content="https://balinti.github.io/gear-glide/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Gear Glide - Free HTML5 Game">
<meta name="twitter:description" content="Tap to phase-lock rotating gears and glide your clockwork drone through an industrial gauntlet.">
<meta name="twitter:image" content="https://balinti.github.io/gear-glide/og-image.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#e0e0e0}
#app{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;min-height:100dvh;padding:4px}
header{text-align:center;padding:4px 0;width:100%;max-width:420px}
header h1{font-size:14px;font-weight:600;color:#8888aa;letter-spacing:2px;text-transform:uppercase}
main{width:100%;max-width:420px;display:flex;flex-direction:column;align-items:center}
#gameCanvas{width:100%;max-width:420px;max-height:750px;border-radius:12px;touch-action:none;cursor:pointer;display:block}
footer{text-align:center;padding:6px 0;width:100%;max-width:420px}
footer p{font-size:10px;color:#555}
details{max-width:420px;width:100%;margin:6px auto 0;font-size:11px;color:#666;text-align:center}
details summary{cursor:pointer;color:#777;font-size:11px;padding:4px}
details p{padding:4px 10px;line-height:1.5;text-align:left}
</style>
</head>
<body>
<div id="app">
<header><h1>Gear Glide</h1></header>
<main><canvas id="gameCanvas"></canvas></main>
<footer><p>Tap to phase-lock gears &bull; A hyper-casual timing game</p></footer>
<details>
<summary>About Gear Glide</summary>
<p>Gear Glide is a free hyper-casual HTML5 timing game. Your clockwork drone auto-glides through an industrial world of rotating gears. Tap at the right moment to phase-lock each gear's safe window into alignment. Score points for each gear cleared, earn Perfect Lock bonuses for precise timing, and build streaks. Difficulty ramps as you progress &mdash; gears spin faster, windows shrink, and lock durations tighten. Challenge your friends with daily seeds and compete for the highest score!</p>
</details>
</div>
<script>
'use strict';
(() => {
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const dpr = Math.min(window.devicePixelRatio || 1, 3);
let W, H;

function resize() {
  const maxW = 420, maxH = 750;
  const vw = Math.min(window.innerWidth, maxW);
  const vh = Math.min(window.innerHeight - 60, maxH);
  const aspect = maxW / maxH;
  let w = vw, h = vh;
  if (w / h > aspect) w = h * aspect;
  else h = w / aspect;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.round(w * dpr);
  canvas.height = Math.round(h * dpr);
  W = w; H = h;
}
resize();
window.addEventListener('resize', resize);

// Daily seed
function getDailySeed() {
  const d = new Date();
  return d.getFullYear() * 10000 + (d.getMonth() + 1) * 100 + d.getDate();
}
function seededRandom(seed) {
  let s = seed;
  return () => { s = (s * 16807 + 0) % 2147483647; return (s - 1) / 2147483646; };
}

const DAILY_SEED = getDailySeed();
const LS_BEST = 'gearglide_best';
const LS_TODAY = 'gearglide_today_' + DAILY_SEED;

function getBest() { return parseInt(localStorage.getItem(LS_BEST)) || 0; }
function setBest(s) { localStorage.setItem(LS_BEST, s); }
function getTodayBest() { return parseInt(localStorage.getItem(LS_TODAY)) || 0; }
function setTodayBest(s) { localStorage.setItem(LS_TODAY, s); }

// Game state
let state = 'start';
let score = 0;
let bestScore = getBest();
let todayBest = getTodayBest();
let perfects = 0;
let streak = 0;
let maxStreak = 0;
let gameTime = 0;
let shakeAmount = 0;
let shakeDuration = 0;
let flashAlpha = 0;
let deathHint = '';
let particles = [];
let gears = [];
let scrollSpeed = 0;
let baseScrollSpeed = 0;
let laneY = 0;
let playerX = 0;
let dronePhase = 0;

// Difficulty
function getDifficulty() {
  const t = Math.min(score, 80);
  return {
    scrollSpeed: 100 + t * 2.5,
    rotSpeed: 0.6 + t * 0.02,
    windowArc: Math.max(0.7, 1.4 - t * 0.009),
    lockDuration: Math.max(0.18, 0.38 - t * 0.0025),
    perfectBand: Math.max(0.08, 0.18 - t * 0.0012),
    gearSpacing: Math.max(160, 240 - t * 1.0),
    doubleGateChance: Math.min(0.18, t * 0.003),
  };
}

// Gear class
class Gear {
  constructor(x, radius, rng) {
    this.x = x;
    this.radius = radius || 50 + rng() * 20;
    this.ringWidth = 10 + rng() * 4;
    this.teeth = 12 + Math.floor(rng() * 8);
    this.toothLen = 8 + rng() * 5;
    this.angle = rng() * Math.PI * 2;
    this.rotDir = rng() > 0.5 ? 1 : -1;
    this.windowArc = getDifficulty().windowArc;
    this.windowOffset = rng() * Math.PI * 2;
    this.locked = false;
    this.lockTimer = 0;
    this.lockTargetAngle = 0;
    this.cleared = false;
    this.perfectLocked = false;
    this.wasLockAttempted = false;
    this.hue = 0;
  }
}

function spawnGear(x, rng) {
  const diff = getDifficulty();
  const g = new Gear(x, 45 + rng() * 25, rng);
  g.windowArc = diff.windowArc;
  return g;
}

function initGame() {
  score = 0;
  perfects = 0;
  streak = 0;
  maxStreak = 0;
  gameTime = 0;
  shakeAmount = 0;
  shakeDuration = 0;
  flashAlpha = 0;
  deathHint = '';
  particles = [];
  gears = [];
  laneY = H * 0.58;
  playerX = W * 0.28;

  const diff = getDifficulty();
  baseScrollSpeed = diff.scrollSpeed;
  scrollSpeed = baseScrollSpeed;

  const rng = seededRandom(DAILY_SEED + 42);
  let gx = W * 0.8;
  for (let i = 0; i < 8; i++) {
    const g = spawnGear(gx, rng);
    gears.push(g);
    const nextDiff = getDifficulty();
    gx += nextDiff.gearSpacing + g.radius * 1.2;
    if (rng() < nextDiff.doubleGateChance && i > 2) {
      const g2 = spawnGear(gx - 30, rng);
      g2.radius = g.radius * 0.8;
      gears.push(g2);
    }
  }
}

// Particles
function spawnParticles(x, y, count, hue, speed) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const v = (speed || 80) * (0.3 + Math.random() * 0.7);
    particles.push({
      x, y,
      vx: Math.cos(a) * v,
      vy: Math.sin(a) * v,
      life: 0.5 + Math.random() * 0.7,
      maxLife: 0.5 + Math.random() * 0.7,
      size: 2 + Math.random() * 3,
      hue: hue + Math.random() * 30 - 15,
    });
  }
}

function triggerShake(amount, duration) {
  shakeAmount = amount;
  shakeDuration = duration;
}

// Input
let tapQueued = false;
function handleTap() {
  if (state === 'start') {
    state = 'playing';
    initGame();
    return;
  }
  if (state === 'gameover') {
    state = 'playing';
    initGame();
    return;
  }
  if (state === 'playing') {
    tapQueued = true;
  }
}

canvas.addEventListener('pointerdown', (e) => { e.preventDefault(); handleTap(); });
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); handleTap(); }
});

// Lane angle for a gear
function getLaneAngle(gear) {
  return Math.atan2(laneY - H * 0.5, gear.x - gear.x);
}

// Check if drone hits gear
function checkCollision(gear) {
  const dx = playerX - gear.x;
  const dy = laneY - (H * 0.5);
  const dist = Math.sqrt(dx * dx + dy * dy);
  const innerR = gear.radius - gear.ringWidth * 0.5;
  const outerR = gear.radius + gear.ringWidth * 0.5;

  if (dist < innerR || dist > outerR) return false;

  // In the ring - check window
  let angle = Math.atan2(dy, dx);
  let windowCenter;
  if (gear.locked) {
    windowCenter = gear.lockTargetAngle;
  } else {
    windowCenter = gear.angle + gear.windowOffset;
  }
  let diff = angle - windowCenter;
  while (diff > Math.PI) diff -= Math.PI * 2;
  while (diff < -Math.PI) diff += Math.PI * 2;

  if (Math.abs(diff) < gear.windowArc * 0.5) return false;
  return true;
}

// Is drone inside gear ring zone (for clearing)
function isInGearZone(gear) {
  const dx = playerX - gear.x;
  const dy = laneY - (H * 0.5);
  const dist = Math.sqrt(dx * dx + dy * dy);
  const outerR = gear.radius + gear.ringWidth * 0.5 + 5;
  return dist < outerR;
}

// Detect early/late
function getTimingHint(gear) {
  const windowCenter = gear.locked ? gear.lockTargetAngle : (gear.angle + gear.windowOffset);
  const droneAngle = Math.atan2(laneY - H * 0.5, playerX - gear.x);
  let diff = droneAngle - windowCenter;
  while (diff > Math.PI) diff -= Math.PI * 2;
  while (diff < -Math.PI) diff += Math.PI * 2;
  if (gear.wasLockAttempted) {
    return diff * gear.rotDir > 0 ? 'Too Late!' : 'Too Early!';
  }
  return 'Missed Lock!';
}

function gameOver(gear) {
  state = 'gameover';
  deathHint = gear ? getTimingHint(gear) : 'Crashed!';
  bestScore = getBest();
  if (score > bestScore) { bestScore = score; setBest(score); }
  todayBest = getTodayBest();
  if (score > todayBest) { todayBest = score; setTodayBest(score); }
  triggerShake(12, 0.4);
  flashAlpha = 0.6;
  spawnParticles(playerX, laneY, 40, 0, 150);
}

// Tier for share
function getTier(s) {
  if (s >= 50) return 'Clockwork Legend';
  if (s >= 30) return 'Gear Master';
  if (s >= 20) return 'Phase Pro';
  if (s >= 10) return 'Gear Runner';
  if (s >= 5) return 'Apprentice';
  return 'Newbie';
}

function shareScore() {
  const tier = getTier(score);
  const text = `I scored ${score} in Gear Glide! (${tier}) ${perfects} perfects, ${maxStreak} max streak. Can you beat me?\nhttps://balinti.github.io/gear-glide/?challenge=1&score=${score}&seed=${DAILY_SEED}`;
  if (navigator.share) {
    navigator.share({ title: 'Gear Glide Challenge', text }).catch(() => {});
  } else {
    navigator.clipboard.writeText(text).then(() => {
      shareMsg = 'Copied!';
      shareMsgTimer = 1.5;
    }).catch(() => {});
  }
}
let shareMsg = '';
let shareMsgTimer = 0;
let shareBtn = { x: 0, y: 0, w: 0, h: 0 };

canvas.addEventListener('pointerdown', (e) => {
  if (state === 'gameover') {
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) / rect.width * W;
    const sy = (e.clientY - rect.top) / rect.height * H;
    if (sx >= shareBtn.x && sx <= shareBtn.x + shareBtn.w &&
        sy >= shareBtn.y && sy <= shareBtn.y + shareBtn.h) {
      e.stopPropagation();
      shareScore();
      return;
    }
  }
}, true);

// Update
let lastTime = 0;
function update(ts) {
  requestAnimationFrame(update);
  const now = ts / 1000;
  let dt = now - lastTime;
  lastTime = now;
  if (dt > 0.1) dt = 0.016;
  if (dt <= 0) dt = 0.016;

  const baseHue = (now * 12 + score * 7) % 360;

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= 0.97;
    p.vy *= 0.97;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Shake
  if (shakeDuration > 0) {
    shakeDuration -= dt;
    if (shakeDuration < 0) shakeDuration = 0;
  }

  // Flash
  if (flashAlpha > 0) flashAlpha -= dt * 2;

  // Share msg
  if (shareMsgTimer > 0) shareMsgTimer -= dt;

  if (state === 'playing') {
    gameTime += dt;
    dronePhase += dt * 8;

    const diff = getDifficulty();
    scrollSpeed = diff.scrollSpeed;

    // Process tap
    if (tapQueued) {
      tapQueued = false;
      let nearest = null;
      let nearestDist = Infinity;
      for (const g of gears) {
        if (g.cleared || g.locked) continue;
        const d = g.x - playerX;
        if (d > -g.radius * 0.5 && d < nearestDist) {
          nearestDist = d;
          nearest = g;
        }
      }
      if (nearest) {
        nearest.locked = true;
        nearest.wasLockAttempted = true;
        nearest.lockTimer = diff.lockDuration;
        // Target angle: align window center with drone angle
        const droneAngle = Math.atan2(laneY - H * 0.5, playerX - nearest.x);
        nearest.lockTargetAngle = droneAngle - nearest.windowOffset + nearest.angle + nearest.windowOffset;
        // Simplify: lock so window center = drone approach angle
        nearest.lockTargetAngle = droneAngle;
        // Store original angle to detect snap
        nearest.lockedFromAngle = nearest.angle + nearest.windowOffset;
        // Calculate perfect
        const currentWindowCenter = nearest.angle + nearest.windowOffset;
        let angleDiff = droneAngle - currentWindowCenter;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        if (Math.abs(angleDiff) < diff.perfectBand) {
          nearest.perfectLocked = true;
          perfects++;
          streak++;
          if (streak > maxStreak) maxStreak = streak;
          spawnParticles(nearest.x, laneY, 12, 50, 60);
          triggerShake(3, 0.1);
        } else {
          // Non-perfect: cool down streak by 1 instead of reset
          if (streak > 0) streak = Math.max(0, streak - 1);
        }
        spawnParticles(nearest.x, laneY, 6, baseHue, 40);
        triggerShake(2, 0.08);
      }
    }

    // Move gears
    for (const g of gears) {
      g.x -= scrollSpeed * dt;
      g.hue = baseHue;

      if (!g.locked) {
        g.angle += diff.rotSpeed * g.rotDir * dt;
      } else {
        g.lockTimer -= dt;
        if (g.lockTimer <= 0) {
          g.locked = false;
        }
      }

      // Check if passed
      if (!g.cleared && g.x < playerX - g.radius - 10) {
        g.cleared = true;
        score++;
        spawnParticles(playerX, laneY, 4, baseHue + 120, 30);
      }
    }

    // Collision
    for (const g of gears) {
      if (g.cleared) continue;
      if (isInGearZone(g) && checkCollision(g)) {
        gameOver(g);
        return;
      }
    }

    // Remove old gears and spawn new
    while (gears.length > 0 && gears[0].x < -100) {
      gears.shift();
    }
    const lastGear = gears[gears.length - 1];
    if (lastGear && lastGear.x < W + 200) {
      const rng = seededRandom(DAILY_SEED + score * 137 + gears.length * 31);
      const newDiff = getDifficulty();
      const newX = lastGear.x + newDiff.gearSpacing + lastGear.radius * 1.2;
      gears.push(spawnGear(newX, rng));
      if (rng() < newDiff.doubleGateChance) {
        const g2 = spawnGear(newX + 25, rng);
        g2.radius *= 0.78;
        gears.push(g2);
      }
    }
  }

  // Draw
  draw(now, baseHue, dt);
}

function draw(now, baseHue, dt) {
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // Shake offset
  let sx = 0, sy = 0;
  if (shakeDuration > 0) {
    const intensity = shakeAmount * (shakeDuration / 0.4);
    sx = (Math.random() - 0.5) * intensity * 2;
    sy = (Math.random() - 0.5) * intensity * 2;
  }
  ctx.save();
  ctx.translate(sx, sy);

  // Background gradient
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, `hsl(${(baseHue + 200) % 360}, 15%, 8%)`);
  bg.addColorStop(1, `hsl(${(baseHue + 220) % 360}, 20%, 4%)`);
  ctx.fillStyle = bg;
  ctx.fillRect(-20, -20, W + 40, H + 40);

  // Background dots (industrial vibe)
  ctx.globalAlpha = 0.08;
  for (let i = 0; i < 30; i++) {
    const bx = ((i * 73.7 + now * 8) % (W + 40)) - 20;
    const by = ((i * 137.3 + i * i * 7) % H);
    ctx.fillStyle = `hsl(${baseHue}, 30%, 50%)`;
    ctx.fillRect(bx, by, 1.5, 1.5);
  }
  ctx.globalAlpha = 1;

  // Lane line
  ctx.save();
  ctx.strokeStyle = `hsla(${baseHue}, 40%, 40%, 0.15)`;
  ctx.lineWidth = 1;
  ctx.setLineDash([8, 12]);
  ctx.beginPath();
  ctx.moveTo(0, laneY);
  ctx.lineTo(W, laneY);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();

  if (state === 'start') {
    drawStartScreen(now, baseHue);
  } else if (state === 'playing' || state === 'gameover') {
    drawGame(now, baseHue);
  }

  // Particles
  for (const p of particles) {
    const alpha = Math.max(0, p.life / p.maxLife);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = `hsl(${p.hue}, 80%, 60%)`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Flash
  if (flashAlpha > 0) {
    ctx.globalAlpha = Math.max(0, flashAlpha);
    ctx.fillStyle = '#ff2222';
    ctx.fillRect(-20, -20, W + 40, H + 40);
    ctx.globalAlpha = 1;
  }

  // Vignette
  const vg = ctx.createRadialGradient(W * 0.5, H * 0.5, W * 0.2, W * 0.5, H * 0.5, W * 0.8);
  vg.addColorStop(0, 'rgba(0,0,0,0)');
  vg.addColorStop(1, 'rgba(0,0,0,0.4)');
  ctx.fillStyle = vg;
  ctx.fillRect(0, 0, W, H);

  ctx.restore();
}

function drawGear(g, baseHue) {
  const cx = g.x;
  const cy = H * 0.5;

  // Gear teeth (visual only)
  ctx.save();
  ctx.translate(cx, cy);
  const toothAngle = (Math.PI * 2) / g.teeth;
  const actualAngle = g.locked ? (g.angle) : g.angle;
  ctx.rotate(actualAngle);
  ctx.strokeStyle = `hsla(${g.hue + 30}, 30%, 35%, 0.4)`;
  ctx.lineWidth = 2;
  for (let i = 0; i < g.teeth; i++) {
    const a = i * toothAngle;
    const r1 = g.radius + g.ringWidth * 0.5;
    const r2 = r1 + g.toothLen;
    const hw = toothAngle * 0.2;
    ctx.beginPath();
    ctx.moveTo(Math.cos(a - hw) * r1, Math.sin(a - hw) * r1);
    ctx.lineTo(Math.cos(a - hw * 0.6) * r2, Math.sin(a - hw * 0.6) * r2);
    ctx.lineTo(Math.cos(a + hw * 0.6) * r2, Math.sin(a + hw * 0.6) * r2);
    ctx.lineTo(Math.cos(a + hw) * r1, Math.sin(a + hw) * r1);
    ctx.stroke();
  }
  ctx.restore();

  // Ring
  ctx.save();
  ctx.translate(cx, cy);

  // Solid ring
  ctx.strokeStyle = `hsla(${g.hue + 180}, 40%, 25%, 0.8)`;
  ctx.lineWidth = g.ringWidth;
  ctx.beginPath();
  ctx.arc(0, 0, g.radius, 0, Math.PI * 2);
  ctx.stroke();

  // Window arc (safe zone)
  const windowCenter = g.locked ? g.lockTargetAngle : (g.angle + g.windowOffset);
  const windowStart = windowCenter - g.windowArc * 0.5;
  const windowEnd = windowCenter + g.windowArc * 0.5;

  // Glow behind window
  ctx.shadowColor = g.perfectLocked ? `hsl(50, 100%, 60%)` : `hsl(${g.hue + 120}, 80%, 50%)`;
  ctx.shadowBlur = g.locked ? 15 : 8;
  ctx.strokeStyle = g.perfectLocked
    ? `hsla(50, 100%, 70%, 0.9)`
    : g.locked
      ? `hsla(${g.hue + 120}, 90%, 55%, 0.9)`
      : `hsla(${g.hue + 120}, 70%, 45%, 0.7)`;
  ctx.lineWidth = g.ringWidth + 2;
  ctx.beginPath();
  ctx.arc(0, 0, g.radius, windowStart, windowEnd);
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Target marker at lane intersection
  const droneAngle = Math.atan2(laneY - cy, playerX - cx);
  ctx.strokeStyle = `hsla(${g.hue}, 60%, 70%, 0.4)`;
  ctx.lineWidth = 1.5;
  const mr = g.radius + g.ringWidth * 0.5 + 3;
  ctx.beginPath();
  ctx.moveTo(Math.cos(droneAngle) * (mr - 8), Math.sin(droneAngle) * (mr - 8));
  ctx.lineTo(Math.cos(droneAngle) * (mr + 5), Math.sin(droneAngle) * (mr + 5));
  ctx.stroke();

  // Lock indicator
  if (g.locked) {
    ctx.strokeStyle = `hsla(50, 100%, 70%, ${0.3 + Math.sin(Date.now() * 0.01) * 0.2})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, g.radius + g.ringWidth, 0, Math.PI * 2);
    ctx.stroke();
  }

  // Center dot
  ctx.fillStyle = `hsla(${g.hue}, 30%, 30%, 0.5)`;
  ctx.beginPath();
  ctx.arc(0, 0, 4, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawDrone(now, baseHue) {
  const x = playerX;
  const y = laneY;
  const bob = Math.sin(dronePhase) * 2;

  ctx.save();
  ctx.translate(x, y + bob);

  // Glow
  ctx.shadowColor = `hsl(${baseHue + 60}, 80%, 60%)`;
  ctx.shadowBlur = 12;

  // Body
  ctx.fillStyle = `hsl(${baseHue + 60}, 50%, 55%)`;
  ctx.beginPath();
  ctx.moveTo(12, 0);
  ctx.lineTo(-6, -7);
  ctx.lineTo(-4, 0);
  ctx.lineTo(-6, 7);
  ctx.closePath();
  ctx.fill();

  // Core
  ctx.fillStyle = `hsl(${baseHue + 60}, 90%, 80%)`;
  ctx.beginPath();
  ctx.arc(2, 0, 3, 0, Math.PI * 2);
  ctx.fill();

  // Propeller lines
  ctx.strokeStyle = `hsla(${baseHue + 60}, 60%, 70%, 0.6)`;
  ctx.lineWidth = 1;
  const pa = now * 25;
  for (let i = 0; i < 3; i++) {
    const a = pa + i * (Math.PI * 2 / 3);
    ctx.beginPath();
    ctx.moveTo(-3, -8);
    ctx.lineTo(-3 + Math.cos(a) * 7, -8 + Math.sin(a) * 3);
    ctx.stroke();
  }

  ctx.shadowBlur = 0;

  // Trail particles
  if (state === 'playing') {
    spawnParticles(x - 8, y + bob, 1, baseHue + 60, 15);
  }

  ctx.restore();
}

function drawGame(now, baseHue) {
  // Draw gears
  for (const g of gears) {
    if (g.x > -100 && g.x < W + 100) {
      drawGear(g, baseHue);
    }
  }

  // Draw drone
  drawDrone(now, baseHue);

  // HUD
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${20}px 'Segoe UI', system-ui, sans-serif`;
  ctx.textAlign = 'left';
  ctx.fillText(score, 16, 32);

  // Streak
  if (streak > 1) {
    ctx.font = `bold 14px 'Segoe UI', system-ui, sans-serif`;
    ctx.fillStyle = `hsl(50, 100%, 70%)`;
    ctx.fillText(`${streak}x streak`, 16, 52);
  }

  // Perfect flash
  if (state === 'playing') {
    for (const g of gears) {
      if (g.perfectLocked && g.lockTimer > 0) {
        ctx.save();
        ctx.font = `bold 13px 'Segoe UI', system-ui, sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillStyle = `hsla(50, 100%, 70%, ${Math.min(1, g.lockTimer * 4)})`;
        ctx.fillText('PERFECT', g.x, H * 0.5 - g.radius - g.ringWidth - 12);
        ctx.restore();
      }
    }
  }

  // Game over overlay
  if (state === 'gameover') {
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillRect(0, 0, W, H);

    ctx.textAlign = 'center';

    // Death hint
    ctx.font = `bold 16px 'Segoe UI', system-ui, sans-serif`;
    ctx.fillStyle = `hsl(0, 80%, 65%)`;
    ctx.fillText(deathHint, W * 0.5, H * 0.32);

    // Score
    ctx.font = `bold 42px 'Segoe UI', system-ui, sans-serif`;
    ctx.fillStyle = '#fff';
    ctx.fillText(score, W * 0.5, H * 0.44);

    ctx.font = `14px 'Segoe UI', system-ui, sans-serif`;
    ctx.fillStyle = '#aaa';
    ctx.fillText(`Best: ${bestScore}  |  Today: ${todayBest}`, W * 0.5, H * 0.50);

    // Stats
    ctx.font = `12px 'Segoe UI', system-ui, sans-serif`;
    ctx.fillStyle = '#888';
    ctx.fillText(`${perfects} perfects  ·  ${maxStreak} max streak  ·  ${getTier(score)}`, W * 0.5, H * 0.55);

    // Retry
    ctx.font = `16px 'Segoe UI', system-ui, sans-serif`;
    ctx.fillStyle = `hsl(${baseHue + 120}, 60%, 70%)`;
    ctx.fillText('Tap to Retry', W * 0.5, H * 0.64);

    // Share button
    const btnW = 160, btnH = 34;
    const btnX = W * 0.5 - btnW * 0.5;
    const btnY = H * 0.68;
    shareBtn = { x: btnX, y: btnY, w: btnW, h: btnH };

    ctx.fillStyle = `hsla(${baseHue + 200}, 50%, 35%, 0.8)`;
    ctx.beginPath();
    ctx.roundRect(btnX, btnY, btnW, btnH, 8);
    ctx.fill();
    ctx.strokeStyle = `hsla(${baseHue + 200}, 60%, 55%, 0.6)`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(btnX, btnY, btnW, btnH, 8);
    ctx.stroke();

    ctx.font = `bold 13px 'Segoe UI', system-ui, sans-serif`;
    ctx.fillStyle = '#ddd';
    ctx.textAlign = 'center';
    ctx.fillText(shareMsgTimer > 0 ? shareMsg : 'Challenge a Friend', W * 0.5, btnY + btnH * 0.65);
  }
}

function drawStartScreen(now, baseHue) {
  // Animated background gears
  for (let i = 0; i < 5; i++) {
    ctx.save();
    const gx = W * (0.15 + i * 0.18);
    const gy = H * 0.5 + Math.sin(now * 0.5 + i) * 30;
    ctx.translate(gx, gy);
    ctx.rotate(now * 0.3 * (i % 2 ? 1 : -1));
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = `hsl(${baseHue + i * 40}, 40%, 50%)`;
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.arc(0, 0, 30 + i * 12, 0, Math.PI * 2);
    ctx.stroke();
    // Teeth
    const teeth = 8 + i * 2;
    for (let t = 0; t < teeth; t++) {
      const ta = (t / teeth) * Math.PI * 2;
      const r1 = 30 + i * 12 + 3;
      const r2 = r1 + 8;
      ctx.beginPath();
      ctx.moveTo(Math.cos(ta) * r1, Math.sin(ta) * r1);
      ctx.lineTo(Math.cos(ta) * r2, Math.sin(ta) * r2);
      ctx.stroke();
    }
    ctx.restore();
  }
  ctx.globalAlpha = 1;

  ctx.textAlign = 'center';

  // Title
  ctx.font = `bold 36px 'Segoe UI', system-ui, sans-serif`;
  ctx.fillStyle = `hsl(${baseHue + 60}, 60%, 75%)`;
  ctx.shadowColor = `hsl(${baseHue + 60}, 80%, 50%)`;
  ctx.shadowBlur = 20;
  ctx.fillText('GEAR GLIDE', W * 0.5, H * 0.32);
  ctx.shadowBlur = 0;

  // Subtitle
  ctx.font = `14px 'Segoe UI', system-ui, sans-serif`;
  ctx.fillStyle = `hsl(${baseHue + 180}, 40%, 60%)`;
  ctx.fillText('Phase Lock Runner', W * 0.5, H * 0.38);

  // Instruction
  const pulse = 0.6 + Math.sin(now * 3) * 0.4;
  ctx.font = `16px 'Segoe UI', system-ui, sans-serif`;
  ctx.fillStyle = `hsla(0, 0%, 100%, ${pulse})`;
  ctx.fillText('Tap to Start', W * 0.5, H * 0.52);

  // Instructions
  ctx.font = `12px 'Segoe UI', system-ui, sans-serif`;
  ctx.fillStyle = '#777';
  ctx.fillText('Tap to lock gears into safe alignment', W * 0.5, H * 0.60);
  ctx.fillText('Time it perfectly for bonus streaks', W * 0.5, H * 0.64);

  // Best / Today
  ctx.font = `13px 'Segoe UI', system-ui, sans-serif`;
  ctx.fillStyle = '#999';
  if (bestScore > 0) {
    ctx.fillText(`Best: ${bestScore}`, W * 0.5, H * 0.74);
  }
  if (todayBest > 0) {
    ctx.fillStyle = `hsl(${baseHue + 120}, 50%, 60%)`;
    ctx.fillText(`Today's Best: ${todayBest}`, W * 0.5, H * 0.78);
  }

  // Challenge params
  const params = new URLSearchParams(window.location.search);
  if (params.get('challenge') === '1') {
    const cs = params.get('score') || '?';
    ctx.fillStyle = `hsl(${baseHue + 40}, 70%, 65%)`;
    ctx.font = `bold 14px 'Segoe UI', system-ui, sans-serif`;
    ctx.fillText(`Friend scored ${cs} — beat them!`, W * 0.5, H * 0.86);
  }
}

// Polyfill roundRect if needed
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    if (typeof r === 'number') r = [r, r, r, r];
    const [tl, tr, br, bl] = r;
    this.moveTo(x + tl, y);
    this.lineTo(x + w - tr, y);
    this.quadraticCurveTo(x + w, y, x + w, y + tr);
    this.lineTo(x + w, y + h - br);
    this.quadraticCurveTo(x + w, y + h, x + w - br, y + h);
    this.lineTo(x + bl, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - bl);
    this.lineTo(x, y + tl);
    this.quadraticCurveTo(x, y, x + tl, y);
    this.closePath();
  };
}

requestAnimationFrame(update);
})();
</script>
</body>
</html>
