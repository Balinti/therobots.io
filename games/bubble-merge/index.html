<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Bubble Merge - Free HTML5 Game</title>
<meta name="description" content="Play Bubble Merge - Tap to merge ascending number bubbles before the color palette shifts underwater.">
<meta name="theme-color" content="#05070c">
<link rel="canonical" href="https://balinti.github.io/bubble-merge/">

<!-- Open Graph -->
<meta property="og:type" content="website">
<meta property="og:title" content="Bubble Merge - Free HTML5 Game">
<meta property="og:description" content="Play Bubble Merge - Tap to merge ascending number bubbles before the color palette shifts underwater.">
<meta property="og:url" content="https://balinti.github.io/bubble-merge/">
<meta property="og:image" content="https://balinti.github.io/bubble-merge/og-image.png">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Bubble Merge - Free HTML5 Game">
<meta name="twitter:description" content="Play Bubble Merge - Tap to merge ascending number bubbles before the color palette shifts underwater.">
<meta name="twitter:image" content="https://balinti.github.io/bubble-merge/og-image.png">

<!-- AdSense preconnects -->
<link rel="preconnect" href="https://pagead2.googlesyndication.com">
<link rel="preconnect" href="https://googleads.g.doubleclick.net">

<!-- AdSense -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>

<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  html, body {
    width: 100%; height: 100%;
    background: #05070c;
    display: flex; align-items: center; justify-content: center;
    overflow: hidden;
    font-family: system-ui, -apple-system, sans-serif;
    touch-action: manipulation;
  }
  #container {
    position: relative;
    width: 420px; height: 750px;
    max-width: 100vw; max-height: 100vh;
  }
  canvas {
    display: block;
    width: 100%; height: 100%;
    cursor: pointer;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }
</style>
</head>
<body>
<div id="container">
  <canvas id="c"></canvas>
</div>

<script>
(function(){
'use strict';

// ─── Constants ────────────────────────────────────────────────────────────────
const DESIGN_W = 420, DESIGN_H = 750;
const COLS = 5;
const BUBBLE_R = 28;
const STEP_Y = 58;
const TANK_X = 30;
const TANK_W = DESIGN_W - 60;
const COL_W = TANK_W / COLS;
const SURFACE_Y = 80;
const FLOOR_Y = DESIGN_H - 60;
const MAX_ROWS = Math.floor((FLOOR_Y - SURFACE_Y) / STEP_Y);
const LS_KEY = 'bubbleMergeBest';

// ─── Canvas Setup ─────────────────────────────────────────────────────────────
const container = document.getElementById('container');
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let dpr = 1;
function resizeCanvas() {
  const rect = container.getBoundingClientRect();
  dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(dpr * (rect.width / DESIGN_W), dpr * (rect.height / DESIGN_H));
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ─── State ────────────────────────────────────────────────────────────────────
let state = 'start'; // 'start' | 'playing' | 'gameover'
let score = 0, bestScore = parseInt(localStorage.getItem(LS_KEY)||'0');
let elapsed = 0; // seconds since game start
let shakeTimer = 0, shakeMag = 0;
let panicTimer = 0; // if column reaches surface

// Columns: array of 5 arrays, each holding bubble objects {value, y, targetY, hue, foam}
let columns;
// Highlight sweep
let hlCol = 0, hlDir = 1, hlT = 0;
// Falling bubble
let falling = null; // {value, col, x, y, targetY, hue, foam}
let fallSpeed = 0;
// Current phase
let currentPhase = false, currentDir = 0, currentTimer = 0, currentDuration = 0;
let currentStreak = []; // streak particles
let nextCurrentIn = 0;
let driftStrength = 0;
// Micro-bubbles background
let microBubbles = [];
// Particles
let particles = [];
// Combo state
let comboCount = 0, comboTimer = 0;
// Light bands
let lightBands = [];
// HSL hue cycle
let globalHue = 200;
// Overlay flash for current shift
let flashAlpha = 0, flashHue = 0;

// ─── Helpers ──────────────────────────────────────────────────────────────────
function colX(c) { return TANK_X + c * COL_W + COL_W * 0.5; }
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function lerp(a,b,t){ return a+(b-a)*t; }
function easeOut(t){ return 1-(1-t)*(1-t); }

function getBubbleHue(value) {
  const vals = [2,4,8,16,32,64,128,256,512,1024,2048,4096];
  const idx = vals.indexOf(value);
  return (idx >= 0 ? idx * 30 : 0) + globalHue * 0.3;
}

function getStartValue() {
  // weighted: more low values
  const w = elapsed < 30 ? [70,20,10] : elapsed < 90 ? [50,30,20] : [40,30,30];
  const r = Math.random() * 100;
  if (r < w[0]) return 2;
  if (r < w[0]+w[1]) return 4;
  return 8;
}

function stackTop(col) {
  // returns y of top of stack (lowest y = highest on screen)
  const arr = columns[col];
  if (!arr.length) return FLOOR_Y;
  return arr[arr.length-1].y - STEP_Y;
}

function landingY(col) {
  const arr = columns[col];
  if (!arr.length) return FLOOR_Y - BUBBLE_R;
  const top = arr[arr.length-1];
  return top.y - STEP_Y;
}

function columnHeight(col) {
  return columns[col].length;
}

function isColumnFull(col) {
  return columnHeight(col) >= MAX_ROWS;
}

function anySurface() {
  for (let c=0;c<COLS;c++) {
    if (columns[c].length > 0 && columns[c][columns[c].length-1].y <= SURFACE_Y + STEP_Y * 1.5) return true;
  }
  return false;
}

// ─── Init ─────────────────────────────────────────────────────────────────────
function initGame() {
  score = 0;
  elapsed = 0;
  shakeTimer = 0; shakeMag = 0;
  panicTimer = 0;
  columns = [[],[],[],[],[]];
  hlCol = 2; hlDir = 1; hlT = 0;
  falling = null;
  currentPhase = false; currentDir = 1; currentTimer = 0;
  currentStreak = [];
  nextCurrentIn = 8;
  driftStrength = 0;
  particles = [];
  comboCount = 0; comboTimer = 0;
  globalHue = 200;
  flashAlpha = 0;
  microBubbles = Array.from({length:30}, () => ({
    x: randInt(TANK_X+5, TANK_X+TANK_W-5),
    y: randInt(SURFACE_Y, FLOOR_Y),
    r: Math.random()*2+0.5,
    speed: Math.random()*15+8,
    alpha: Math.random()*0.3+0.1
  }));
  lightBands = Array.from({length:3}, () => ({
    y: randInt(SURFACE_Y+50, FLOOR_Y-50),
    w: randInt(30,80),
    x: randInt(TANK_X, TANK_X+TANK_W-80),
    alpha: Math.random()*0.04+0.01,
    speed: Math.random()*5+2,
    dir: Math.random()<0.5?1:-1
  }));
  spawnFalling();
}

function spawnFalling() {
  const col = hlCol;
  const val = getStartValue();
  const isFoam = elapsed > 60 && Math.random() < 0.08 && columnHeight(col) > 0;
  const hue = getBubbleHue(val);
  falling = {
    value: val,
    col: col,
    x: colX(col),
    y: SURFACE_Y - BUBBLE_R * 2,
    targetY: landingY(col),
    hue: hue,
    foam: isFoam,
    vel: 0
  };
  fallSpeed = 350 + elapsed * 2;
}

// ─── Merge Logic ──────────────────────────────────────────────────────────────
function tryMerge(col, startIdx, comboDepth) {
  const arr = columns[col];
  let merged = false;
  let mergeIdx = startIdx;

  if (mergeIdx < 0 || mergeIdx >= arr.length) return false;
  const bubble = arr[mergeIdx];
  if (bubble.foam) return false;

  // check same column: bubble below or above
  // look for adjacent same value in this column
  let partnerIdx = -1;
  if (mergeIdx > 0 && !arr[mergeIdx-1].foam && arr[mergeIdx-1].value === bubble.value) {
    partnerIdx = mergeIdx - 1;
  } else if (mergeIdx < arr.length-1 && !arr[mergeIdx+1].foam && arr[mergeIdx+1].value === bubble.value) {
    partnerIdx = mergeIdx + 1;
  }

  if (partnerIdx < 0) return false;

  // Merge!
  const newVal = bubble.value * 2;
  const mx = colX(col);
  const my = arr[Math.min(mergeIdx, partnerIdx)].y;

  // Remove both, insert merged at lower index
  const lowerIdx = Math.min(mergeIdx, partnerIdx);
  arr.splice(lowerIdx, 2);

  const newHue = getBubbleHue(newVal);
  const newBubble = { value: newVal, y: my, hue: newHue, foam: false, driftOffset: 0 };
  arr.splice(lowerIdx, 0, newBubble);

  // Restack positions
  restackColumn(col);

  // Scoring
  comboCount++;
  comboTimer = 1.5;
  const pts = newVal * comboCount;
  score += pts;

  // Particles
  spawnMergeBurst(mx, my, newHue, newVal);

  // Shake on big merge
  if (newVal >= 128) { shakeTimer = 0.18; shakeMag = newVal >= 512 ? 5 : 3; }

  // Check foam adjacent pop
  popAdjacentFoam(col, lowerIdx);

  // Chain merge
  tryMerge(col, lowerIdx, comboDepth+1);

  // Cross-column adjacency merge (drift makes bubbles touch)
  if (comboDepth === 0) {
    tryAdjacentColMerge(col);
  }

  return true;
}

function tryAdjacentColMerge(col) {
  // Check if top bubble of this col matches top bubble of adjacent col
  for (let dc of [-1, 1]) {
    const nc = col + dc;
    if (nc < 0 || nc >= COLS) continue;
    const a = columns[col];
    const b = columns[nc];
    if (!a.length || !b.length) continue;
    const ta = a[a.length-1];
    const tb = b[b.length-1];
    if (ta.foam || tb.foam) continue;
    if (ta.value !== tb.value) continue;
    // Check proximity via driftOffset
    const ax = colX(col) + (ta.driftOffset||0);
    const bx = colX(nc) + (tb.driftOffset||0);
    if (Math.abs(ax - bx) < BUBBLE_R * 2.2) {
      // Merge into col (left col wins)
      const winCol = col < nc ? col : nc;
      const loseCol = col < nc ? nc : col;
      const winArr = columns[winCol];
      const newVal = ta.value * 2;
      const newHue = getBubbleHue(newVal);
      const my = winArr[winArr.length-1].y;
      winArr[winArr.length-1] = { value: newVal, y: my, hue: newHue, foam: false, driftOffset: 0 };
      columns[loseCol].pop();
      comboCount++;
      comboTimer = 1.5;
      score += newVal * comboCount;
      spawnMergeBurst(colX(winCol), my, newHue, newVal);
      tryMerge(winCol, winArr.length-1, 1);
    }
  }
}

function popAdjacentFoam(col, idx) {
  const arr = columns[col];
  for (let di of [-1,1]) {
    const fi = idx + di;
    if (fi>=0 && fi<arr.length && arr[fi].foam) {
      spawnMergeBurst(colX(col), arr[fi].y, 30, 0);
      arr.splice(fi,1);
      restackColumn(col);
      score += 50;
    }
  }
}

function restackColumn(col) {
  const arr = columns[col];
  for (let i=0; i<arr.length; i++) {
    arr[i].y = FLOOR_Y - BUBBLE_R - i * STEP_Y;
    arr[i].targetY = arr[i].y;
  }
}

// ─── Particles ────────────────────────────────────────────────────────────────
function spawnMergeBurst(x, y, hue, value) {
  const count = Math.min(5 + Math.log2(value||2) * 2, 16);
  for (let i=0;i<count;i++) {
    const angle = (Math.PI*2/count)*i + Math.random()*0.5;
    const speed = 60 + Math.random()*100;
    particles.push({
      x, y,
      vx: Math.cos(angle)*speed,
      vy: Math.sin(angle)*speed - 30,
      r: 3+Math.random()*4,
      hue: hue + randInt(-20,20),
      alpha: 1,
      life: 0.5+Math.random()*0.4,
      t: 0,
      type: 'dot'
    });
  }
  // Ring
  particles.push({ x, y, r: 0, maxR: BUBBLE_R*2.5, hue, alpha: 0.8, life:0.35, t:0, type:'ring' });
}

function spawnCurrentStreaks(dir) {
  for (let i=0;i<12;i++) {
    const sx = dir > 0 ? TANK_X + randInt(0,80) : TANK_X+TANK_W - randInt(0,80);
    currentStreak.push({
      x: sx, y: randInt(SURFACE_Y+20, FLOOR_Y-20),
      vx: dir * (80+Math.random()*80),
      len: 20+Math.random()*40,
      alpha: 0.6+Math.random()*0.3,
      life: 0.5+Math.random()*0.4,
      t:0, hue: flashHue
    });
  }
}

// ─── Update ───────────────────────────────────────────────────────────────────
let lastTime = 0;
function update(ts) {
  const rawDt = lastTime ? (ts - lastTime)/1000 : 0.016;
  lastTime = ts;
  const dt = clamp(rawDt, 0, 0.05);

  if (state !== 'playing') { render(dt); requestAnimationFrame(update); return; }

  elapsed += dt;
  globalHue = (globalHue + dt * 8) % 360;

  // Highlight sweep
  const sweepSpeed = clamp(1.5 + elapsed * 0.02, 1.5, 4.5);
  hlT += dt * sweepSpeed;
  if (hlT >= 1) {
    hlT -= 1;
    hlCol += hlDir;
    if (hlCol >= COLS-1) { hlCol = COLS-1; hlDir = -1; }
    if (hlCol <= 0)      { hlCol = 0;      hlDir =  1; }
  }

  // Combo decay
  if (comboTimer > 0) { comboTimer -= dt; if (comboTimer <= 0) comboCount = 0; }

  // Current phase management
  nextCurrentIn -= dt;
  if (!currentPhase && nextCurrentIn <= 0) {
    currentPhase = true;
    currentDir = Math.random() < 0.5 ? 1 : -1;
    currentDuration = clamp(6 - elapsed * 0.03, 2.5, 6);
    currentTimer = currentDuration;
    driftStrength = clamp(0.3 + elapsed * 0.005, 0.3, 1.2);
    flashAlpha = 0.25;
    flashHue = currentDir > 0 ? 40 : 200;
    spawnCurrentStreaks(currentDir);
    nextCurrentIn = clamp(10 - elapsed * 0.02, 5, 10) + Math.random()*3;
  }
  if (currentPhase) {
    currentTimer -= dt;
    flashAlpha = Math.max(0, flashAlpha - dt * 0.8);
    if (currentTimer <= 0) {
      currentPhase = false;
      driftStrength = 0;
      // Snap drift back
      for (let c=0;c<COLS;c++) for (let b of columns[c]) b.driftOffset = 0;
    }
    // Update drift on stacked bubbles
    if (currentPhase) {
      for (let c=0;c<COLS;c++) {
        for (let b of columns[c]) {
          const targetDrift = currentDir * driftStrength * COL_W * 0.35;
          b.driftOffset = lerp(b.driftOffset||0, targetDrift, dt*2);
        }
      }
    }
  } else {
    // Ease drift back to 0
    for (let c=0;c<COLS;c++) {
      for (let b of columns[c]) {
        if (b.driftOffset) b.driftOffset = lerp(b.driftOffset, 0, dt*3);
      }
    }
  }

  // Update current streaks
  for (let i=currentStreak.length-1;i>=0;i--) {
    const s = currentStreak[i];
    s.t += dt;
    s.x += s.vx * dt;
    s.alpha = Math.max(0, 0.8 * (1 - s.t/s.life));
    if (s.t >= s.life || s.x < TANK_X-50 || s.x > TANK_X+TANK_W+50) currentStreak.splice(i,1);
  }

  // Falling bubble
  if (falling) {
    const spd = clamp(350 + elapsed*3, 350, 700);
    falling.vel += spd * dt;
    falling.y += falling.vel * dt;
    if (falling.y >= falling.targetY) {
      falling.y = falling.targetY;
      landBubble();
    }
  }

  // Update particles
  for (let i=particles.length-1;i>=0;i--) {
    const p = particles[i];
    p.t += dt;
    if (p.type === 'dot') {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 120 * dt; // gravity
      p.alpha = Math.max(0, 1 - p.t/p.life);
    } else if (p.type === 'ring') {
      p.r = (p.t/p.life) * p.maxR;
      p.alpha = Math.max(0, 0.8*(1-p.t/p.life));
    }
    if (p.t >= p.life) particles.splice(i,1);
  }

  // Micro-bubbles
  for (let m of microBubbles) {
    m.y -= m.speed * dt;
    if (m.y < SURFACE_Y - 10) {
      m.y = FLOOR_Y + randInt(0,30);
      m.x = randInt(TANK_X+5, TANK_X+TANK_W-5);
    }
  }

  // Light bands
  for (let lb of lightBands) {
    lb.x += lb.dir * lb.speed * dt;
    if (lb.x > TANK_X+TANK_W || lb.x < TANK_X-lb.w) lb.dir *= -1;
  }

  // Screen shake decay
  if (shakeTimer > 0) shakeTimer -= dt;

  // Check game over: if any column is over-full (reaches surface)
  let danger = false;
  for (let c=0;c<COLS;c++) {
    if (columns[c].length >= MAX_ROWS) {
      danger = true;
      break;
    }
  }
  if (danger) {
    panicTimer += dt;
    if (panicTimer >= 1.0) {
      triggerGameOver();
      return;
    }
  } else {
    panicTimer = 0;
  }

  render(dt);
  requestAnimationFrame(update);
}

function landBubble() {
  if (!falling) return;
  const col = falling.col;

  if (isColumnFull(col)) {
    // Force game over
    triggerGameOver();
    return;
  }

  const bubble = {
    value: falling.value,
    y: falling.targetY,
    hue: falling.hue,
    foam: falling.foam,
    driftOffset: 0
  };
  columns[col].push(bubble);
  restackColumn(col);

  // Perfect drop bonus: if immediate merge
  const beforeScore = score;
  const merged = tryMerge(col, columns[col].length-1, 0);
  if (merged && score > beforeScore) {
    score += 10; // perfect drop bonus
  }

  falling = null;
  setTimeout(() => { if (state==='playing') spawnFalling(); }, 80);
}

function triggerGameOver() {
  state = 'gameover';
  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem(LS_KEY, bestScore);
  }
  shakeTimer = 0.6; shakeMag = 8;
  falling = null;
}

// ─── Input ────────────────────────────────────────────────────────────────────
function handleTap() {
  if (state === 'start') { state = 'playing'; initGame(); return; }
  if (state === 'gameover') { state = 'playing'; initGame(); return; }
  // playing: drop into highlighted column
  if (falling && !isColumnFull(hlCol)) {
    falling.col = hlCol;
    falling.x = colX(hlCol);
    const ty = landingY(hlCol);
    falling.targetY = ty;
    if (falling.y > falling.targetY) {
      landBubble();
    }
  }
}

canvas.addEventListener('pointerdown', (e) => { e.preventDefault(); handleTap(); });
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); handleTap(); }
});

// ─── Render ───────────────────────────────────────────────────────────────────
function render(dt) {
  ctx.save();
  // Screen shake
  if (shakeTimer > 0) {
    const mag = shakeMag * (shakeTimer / 0.6);
    ctx.translate(randInt(-mag,mag), randInt(-mag,mag));
  }

  // Background gradient
  const bg = ctx.createLinearGradient(0,0,0,DESIGN_H);
  bg.addColorStop(0, '#05070c');
  bg.addColorStop(1, `hsl(${(globalHue+180)%360},30%,8%)`);
  ctx.fillStyle = bg;
  ctx.fillRect(0,0,DESIGN_W,DESIGN_H);

  // Tank background
  ctx.save();
  ctx.beginPath();
  ctx.rect(TANK_X, SURFACE_Y, TANK_W, FLOOR_Y-SURFACE_Y);
  ctx.clip();

  // Tank fill
  const tankGrad = ctx.createLinearGradient(0,SURFACE_Y,0,FLOOR_Y);
  tankGrad.addColorStop(0, `hsla(${globalHue},60%,15%,0.9)`);
  tankGrad.addColorStop(1, `hsla(${(globalHue+30)%360},40%,8%,0.95)`);
  ctx.fillStyle = tankGrad;
  ctx.fillRect(TANK_X,SURFACE_Y,TANK_W,FLOOR_Y-SURFACE_Y);

  // Current flash overlay
  if (flashAlpha > 0) {
    ctx.fillStyle = `hsla(${flashHue},80%,60%,${flashAlpha.toFixed(3)})`;
    ctx.fillRect(TANK_X,SURFACE_Y,TANK_W,FLOOR_Y-SURFACE_Y);
  }

  // Light bands
  for (const lb of lightBands) {
    ctx.save();
    ctx.globalAlpha = lb.alpha;
    ctx.fillStyle = `hsl(${globalHue},80%,90%)`;
    ctx.beginPath();
    ctx.ellipse(lb.x+lb.w/2, lb.y, lb.w, 4, -0.2, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // Micro-bubbles
  for (const m of microBubbles) {
    ctx.save();
    ctx.globalAlpha = m.alpha;
    ctx.beginPath();
    ctx.arc(m.x, m.y, m.r, 0, Math.PI*2);
    ctx.strokeStyle = `hsl(${globalHue},80%,80%)`;
    ctx.lineWidth = 0.8;
    ctx.stroke();
    ctx.restore();
  }

  // Current streaks
  for (const s of currentStreak) {
    ctx.save();
    ctx.globalAlpha = s.alpha;
    ctx.strokeStyle = `hsl(${s.hue},90%,70%)`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(s.x - s.vx*0.08, s.y);
    ctx.stroke();
    ctx.restore();
  }

  // Column separators
  for (let c=1;c<COLS;c++) {
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = `hsl(${globalHue},60%,70%)`;
    ctx.lineWidth = 1;
    ctx.setLineDash([4,6]);
    ctx.beginPath();
    ctx.moveTo(TANK_X + c*COL_W, SURFACE_Y);
    ctx.lineTo(TANK_X + c*COL_W, FLOOR_Y);
    ctx.stroke();
    ctx.restore();
  }

  // Highlighted column sweep glow
  if (state === 'playing') {
    const hx = TANK_X + hlCol * COL_W;
    const hlGrad = ctx.createLinearGradient(hx,0,hx+COL_W,0);
    hlGrad.addColorStop(0, `hsla(${globalHue},100%,70%,0)`);
    hlGrad.addColorStop(0.5, `hsla(${globalHue},100%,70%,0.18)`);
    hlGrad.addColorStop(1, `hsla(${globalHue},100%,70%,0)`);
    ctx.fillStyle = hlGrad;
    ctx.fillRect(hx, SURFACE_Y, COL_W, FLOOR_Y-SURFACE_Y);
  }

  // Stacked bubbles
  for (let c=0;c<COLS;c++) {
    for (const b of columns[c]) {
      const bx = colX(c) + (b.driftOffset||0);
      drawBubble(bx, b.y, BUBBLE_R, b.value, b.hue, b.foam, 1);
    }
  }

  ctx.restore(); // unclip tank

  // Tank border
  ctx.save();
  ctx.strokeStyle = `hsl(${globalHue},60%,50%)`;
  ctx.lineWidth = 2;
  ctx.shadowColor = `hsl(${globalHue},80%,60%)`;
  ctx.shadowBlur = 8;
  ctx.strokeRect(TANK_X, SURFACE_Y, TANK_W, FLOOR_Y-SURFACE_Y);
  ctx.restore();

  // Surface danger line
  const dangerProgress = getDangerProgress();
  if (dangerProgress > 0) {
    ctx.save();
    const pulse = 0.5 + 0.5*Math.sin(Date.now()*0.008);
    ctx.globalAlpha = dangerProgress * (0.5 + 0.5*pulse);
    ctx.strokeStyle = `hsl(0,100%,60%)`;
    ctx.lineWidth = 2+pulse*2;
    ctx.shadowColor = 'red';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.moveTo(TANK_X, SURFACE_Y + STEP_Y * 1.5);
    ctx.lineTo(TANK_X+TANK_W, SURFACE_Y + STEP_Y * 1.5);
    ctx.stroke();
    ctx.restore();
  }

  // Particles
  for (const p of particles) {
    ctx.save();
    ctx.globalAlpha = p.alpha;
    if (p.type === 'dot') {
      ctx.fillStyle = `hsl(${p.hue},90%,65%)`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    } else if (p.type === 'ring') {
      ctx.strokeStyle = `hsl(${p.hue},90%,65%)`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Falling bubble
  if (falling && state === 'playing') {
    drawBubble(falling.x, falling.y, BUBBLE_R, falling.value, falling.hue, falling.foam, 1);
    // Drop guide dotted line
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = `hsl(${globalHue},80%,70%)`;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([4,6]);
    ctx.beginPath();
    ctx.moveTo(falling.x, falling.y + BUBBLE_R);
    ctx.lineTo(falling.x, falling.targetY - BUBBLE_R);
    ctx.stroke();
    ctx.restore();
  }

  // HUD
  drawHUD();

  // Current phase indicator
  if (currentPhase) {
    drawCurrentIndicator();
  }

  // State overlays
  if (state === 'start') drawStartOverlay();
  if (state === 'gameover') drawGameOverOverlay();

  ctx.restore(); // shake restore
}

function getDangerProgress() {
  let maxH = 0;
  for (let c=0;c<COLS;c++) maxH = Math.max(maxH, columns[c].length);
  const threshold = MAX_ROWS * 0.7;
  if (maxH < threshold) return 0;
  return clamp((maxH - threshold) / (MAX_ROWS - threshold), 0, 1);
}

function drawBubble(x, y, r, value, hue, foam, alpha) {
  ctx.save();
  ctx.globalAlpha = alpha;

  if (foam) {
    // Foam blocker: white/grey with X
    const g = ctx.createRadialGradient(x-r*0.3, y-r*0.3, 1, x, y, r);
    g.addColorStop(0, 'rgba(240,240,255,0.95)');
    g.addColorStop(1, 'rgba(150,160,180,0.9)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(100,110,140,0.6)';
    ctx.lineWidth = 2;
    ctx.stroke();
    // X mark
    ctx.strokeStyle = 'rgba(80,80,100,0.8)';
    ctx.lineWidth = 2.5;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(x-r*0.4, y-r*0.4); ctx.lineTo(x+r*0.4, y+r*0.4);
    ctx.moveTo(x+r*0.4, y-r*0.4); ctx.lineTo(x-r*0.4, y+r*0.4);
    ctx.stroke();
  } else {
    // Normal bubble
    const g = ctx.createRadialGradient(x-r*0.3, y-r*0.35, r*0.05, x, y, r);
    g.addColorStop(0, `hsla(${hue},80%,80%,0.95)`);
    g.addColorStop(0.6, `hsla(${hue},70%,50%,0.9)`);
    g.addColorStop(1, `hsla(${(hue+20)%360},60%,30%,0.95)`);
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fill();

    // Shine
    ctx.save();
    ctx.globalAlpha *= 0.6;
    const shine = ctx.createRadialGradient(x-r*0.35, y-r*0.4, 0, x-r*0.35, y-r*0.4, r*0.6);
    shine.addColorStop(0, 'rgba(255,255,255,0.7)');
    shine.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = shine;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Border
    ctx.strokeStyle = `hsla(${hue},90%,80%,0.6)`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.stroke();

    // Text
    const label = value >= 1000 ? (value >= 4096 ? '4K+' : value >= 2048 ? '2K' : '1K') : String(value);
    const fontSize = value >= 1000 ? 14 : value >= 100 ? 16 : 18;
    ctx.font = `bold ${fontSize}px system-ui,sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.strokeStyle = 'rgba(0,0,0,0.7)';
    ctx.lineWidth = 3;
    ctx.strokeText(label, x, y);
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.fillText(label, x, y);
  }

  ctx.restore();
}

function drawHUD() {
  // Score
  ctx.save();
  ctx.font = 'bold 28px system-ui,sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#fff';
  ctx.shadowColor = `hsl(${globalHue},80%,60%)`;
  ctx.shadowBlur = 12;
  ctx.fillText(score, DESIGN_W/2, 38);
  ctx.restore();

  // Best
  ctx.save();
  ctx.font = '13px system-ui,sans-serif';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('BEST ' + bestScore, DESIGN_W - 18, 22);
  ctx.restore();

  // Combo
  if (comboCount >= 2 && comboTimer > 0) {
    ctx.save();
    ctx.font = `bold ${18 + comboCount}px system-ui,sans-serif`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    const cc = comboTimer / 1.5;
    ctx.globalAlpha = Math.min(1, cc * 2);
    ctx.fillStyle = `hsl(${(globalHue+120)%360},100%,70%)`;
    ctx.shadowColor = `hsl(${(globalHue+120)%360},100%,60%)`;
    ctx.shadowBlur = 10;
    ctx.fillText(`x${comboCount} COMBO!`, TANK_X + 8, 55);
    ctx.restore();
  }

  // Current direction hint
  if (currentPhase) {
    ctx.save();
    ctx.font = '12px system-ui,sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = `hsla(${flashHue},90%,70%,0.8)`;
    ctx.fillText(`CURRENT ${currentDir>0?'►':'◄'}`, TANK_X, SURFACE_Y - 18);
    ctx.restore();
  }
}

function drawCurrentIndicator() {
  // Animated arrow strip at top of tank
  const progress = 1 - currentTimer/currentDuration;
  const arrowY = SURFACE_Y - 10;
  ctx.save();
  ctx.globalAlpha = 0.7;
  for (let i=0;i<5;i++) {
    const phase = (progress + i/5) % 1;
    const ax = currentDir > 0 ?
      TANK_X + phase * TANK_W :
      TANK_X + TANK_W - phase * TANK_W;
    const a = 0.2 + (1-Math.abs(phase-0.5)*2)*0.8;
    ctx.fillStyle = `hsla(${flashHue},90%,70%,${a.toFixed(2)})`;
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(currentDir > 0 ? '▶' : '◀', ax, arrowY);
  }
  ctx.restore();
}

function drawStartOverlay() {
  // Dimmed bg
  ctx.save();
  ctx.fillStyle = 'rgba(5,7,12,0.85)';
  ctx.fillRect(0,0,DESIGN_W,DESIGN_H);

  // Title
  ctx.font = 'bold 48px system-ui,sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = `hsl(${globalHue},80%,70%)`;
  ctx.shadowColor = `hsl(${globalHue},100%,60%)`;
  ctx.shadowBlur = 20;
  ctx.fillText('BUBBLE', DESIGN_W/2, DESIGN_H*0.35);
  ctx.fillText('MERGE', DESIGN_W/2, DESIGN_H*0.35+54);

  ctx.shadowBlur = 0;
  ctx.font = '18px system-ui,sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.fillText('Tap matching bubbles to merge', DESIGN_W/2, DESIGN_H*0.55);
  ctx.fillText('Chain combos for bigger scores!', DESIGN_W/2, DESIGN_H*0.55+28);

  // Tap to start
  const pulse = 0.6 + 0.4*Math.sin(Date.now()*0.003);
  ctx.font = 'bold 22px system-ui,sans-serif';
  ctx.fillStyle = `rgba(255,255,255,${(0.6+0.4*pulse).toFixed(2)})`;
  ctx.fillText('TAP TO START', DESIGN_W/2, DESIGN_H*0.75);

  ctx.restore();
}

function drawGameOverOverlay() {
  ctx.save();
  ctx.fillStyle = 'rgba(5,7,12,0.88)';
  ctx.fillRect(0,0,DESIGN_W,DESIGN_H);

  ctx.font = 'bold 42px system-ui,sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = 'hsl(0,80%,65%)';
  ctx.shadowColor = 'hsl(0,100%,50%)';
  ctx.shadowBlur = 18;
  ctx.fillText('GAME OVER', DESIGN_W/2, DESIGN_H*0.3);

  ctx.shadowBlur = 0;
  ctx.font = 'bold 32px system-ui,sans-serif';
  ctx.fillStyle = `hsl(${globalHue},80%,70%)`;
  ctx.fillText('Score: ' + score, DESIGN_W/2, DESIGN_H*0.44);

  ctx.font = '20px system-ui,sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fillText('Best: ' + bestScore, DESIGN_W/2, DESIGN_H*0.53);

  const pulse = 0.6 + 0.4*Math.sin(Date.now()*0.003);
  ctx.font = 'bold 22px system-ui,sans-serif';
  ctx.fillStyle = `rgba(255,255,255,${(0.6+0.4*pulse).toFixed(2)})`;
  ctx.fillText('TAP TO RETRY', DESIGN_W/2, DESIGN_H*0.7);

  ctx.restore();
}

// ─── Boot ─────────────────────────────────────────────────────────────────────
requestAnimationFrame(update);

})();
</script>
</body>
</html>
