<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Glacier Escape - Free HTML5 Game</title>
  <meta name="description" content="Play Glacier Escape - Swipe to avoid falling snow chunks as the view zooms closer and farther.">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#0a1628">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Glacier Escape - Free HTML5 Game">
  <meta property="og:description" content="Play Glacier Escape - Swipe to avoid falling snow chunks as the view zooms closer and farther.">
  <meta property="og:url" content="https://balinti.github.io/glacier-escape/">
  <meta property="og:image" content="https://balinti.github.io/glacier-escape/og-preview.png">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Glacier Escape - Free HTML5 Game">
  <meta name="twitter:description" content="Play Glacier Escape - Swipe to avoid falling snow chunks as the view zooms closer and farther.">
  <meta name="twitter:image" content="https://balinti.github.io/glacier-escape/og-preview.png">

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%;
      background: #05101f;
      font-family: 'Segoe UI', system-ui, sans-serif;
      color: #c8e8ff;
      overflow-x: hidden;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      background: radial-gradient(ellipse at top, #0d2040 0%, #05101f 60%);
    }
    #game-wrap {
      position: relative;
      width: 100%;
      max-width: 420px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    canvas {
      display: block;
      width: 100%;
      max-width: 420px;
      height: auto;
      max-height: 750px;
      cursor: pointer;
      touch-action: none;
    }
    #info {
      width: 100%;
      max-width: 420px;
      padding: 18px 20px 32px;
      color: #7ab4d8;
      font-size: 13px;
      line-height: 1.7;
    }
    #info h2 { color: #a8d8f0; font-size: 15px; margin-bottom: 6px; }
    #info p { margin-bottom: 8px; }
    #info ul { padding-left: 18px; }
    #info ul li { margin-bottom: 4px; }
    #share-link {
      display: none;
      margin-top: 6px;
      color: #5bc8f5;
      font-size: 12px;
      word-break: break-all;
    }
  </style>
</head>
<body>
<div id="game-wrap">
  <canvas id="c"></canvas>
  <p id="share-link"></p>
  <div id="info">
    <h2>How to Play Glacier Escape</h2>
    <p>You are a sled racing through a crumbling glacier. Hazards are telegraphed before they strike — use the warning phase to plan, then dodge during impact!</p>
    <ul>
      <li><strong>Tap / Hold</strong> — steer RIGHT</li>
      <li><strong>Release</strong> — drift LEFT</li>
      <li><strong>Near-miss</strong> — graze past impact zones for bonus points</li>
      <li><strong>Risk line</strong> — ride close to the glacier walls for a multiplier</li>
      <li><strong>Combo</strong> — chain near-misses for massive score boosts</li>
    </ul>
    <p>Survive as long as possible. The glacier narrows and hazards multiply as your score climbs. Share your challenge seed with friends to race the same pattern!</p>
    <p style="margin-top:10px;color:#4a8cb0;font-size:11px;">Glacier Escape is a free browser game. No download required. Works on mobile and desktop.</p>
  </div>
</div>

<script>
(function(){
'use strict';

// ── RNG ──────────────────────────────────────────────────────────────────────
function mulberry32(seed){
  return function(){
    seed |= 0; seed = seed + 0x6D2B79F5 | 0;
    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
const urlParams = new URLSearchParams(location.search);
const SEED_PARAM = urlParams.get('challenge');
let gameSeed = SEED_PARAM ? parseInt(SEED_PARAM, 36) : (Math.random() * 0xFFFFFF | 0);
let rng = mulberry32(gameSeed);

// ── Canvas setup ─────────────────────────────────────────────────────────────
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const DPR = window.devicePixelRatio || 1;

const BASE_W = 420, BASE_H = 750;
let CW, CH;

function resizeCanvas(){
  const wrapW = Math.min(window.innerWidth, BASE_W);
  const wrapH = Math.min(window.innerHeight, BASE_H);
  canvas.width  = wrapW * DPR;
  canvas.height = wrapH * DPR;
  canvas.style.width  = wrapW + 'px';
  canvas.style.height = wrapH + 'px';
  CW = canvas.width;
  CH = canvas.height;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// ── State ─────────────────────────────────────────────────────────────────────
const STATE = { START: 0, PLAYING: 1, GAMEOVER: 2 };
let state = STATE.START;
let score = 0, bestScore = +localStorage.getItem('ge_best') || 0;
let combo = 0, comboTimer = 0;
let riskMultiplier = 1;
let shakeAmt = 0, shakeDecay = 0.85;
let colorHue = 200;
let dt = 0, last = 0;
let frameCount = 0;

// ── Player ───────────────────────────────────────────────────────────────────
const LANE_MARGIN = 0.12; // fraction of CW
let player = { x: 0.5, vx: 0, y: 0.75, r: 10*DPR };
let pressing = false;

// ── Pulse system ─────────────────────────────────────────────────────────────
const PHASE = { WARN: 'warn', IMPACT: 'impact' };
let phase = PHASE.WARN;
let phaseTimer = 0;
let warnDur  = 1.0; // seconds
let impactDur = 0.5;
let phaseCycle = 0; // count

// ── Hazards ──────────────────────────────────────────────────────────────────
let hazards = []; // { x, r, type, warned, active, hit, impactAnim, particles[] }
// types: 'rock' (circle), 'splitter' (double), 'slab' (bar)

// ── Particles ────────────────────────────────────────────────────────────────
let particles = [];

function spawnParticles(x, y, n, col, speed, life){
  for(let i=0;i<n;i++){
    const a = rng()*Math.PI*2;
    const s = speed*(0.5+rng()*0.8);
    particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, life, maxLife: life, col });
  }
}

// ── Near-miss sparks ──────────────────────────────────────────────────────────
let sparks = [];
function spawnSparks(x, y){
  for(let i=0;i<12;i++){
    const a = rng()*Math.PI*2;
    sparks.push({ x, y, vx: Math.cos(a)*4*DPR, vy: Math.sin(a)*4*DPR-2*DPR, life: 0.4 });
  }
}

// ── Vignette pulse ────────────────────────────────────────────────────────────
let vignettePulse = 0; // 0..1

// ── Difficulty ────────────────────────────────────────────────────────────────
function getDifficulty(){
  const t = Math.min(score / 600, 1); // 0..1 over 10 min
  return {
    warnDur:   1.0 - t * 0.35,
    impactDur: 0.55 - t * 0.15,
    hazardCount: 1 + Math.floor(t * 3.5),
    useSplitter: t > 0.3,
    useSlab:     t > 0.55,
    sledSpeed:   0.22 + t * 0.18,
    rngWeight:   t,
  };
}

// ── Spawn hazards ─────────────────────────────────────────────────────────────
function spawnHazards(){
  hazards = hazards.filter(h => h.active && !h.hit);
  const diff = getDifficulty();
  const count = diff.hazardCount;
  const laneLeft  = LANE_MARGIN * CW;
  const laneRight = (1 - LANE_MARGIN) * CW;
  const laneW = laneRight - laneLeft;

  for(let i=0;i<count;i++){
    const types = ['rock'];
    if(diff.useSplitter && rng() < 0.3) types.push('splitter');
    if(diff.useSlab && rng() < 0.25) types.push('slab');
    const type = types[Math.floor(rng()*types.length)];

    // Avoid spawning directly on player
    let px = player.x * CW;
    let attempts = 0;
    let x, r;
    do {
      if(type === 'slab'){
        r = laneW * (0.18 + rng()*0.18);
        x = laneLeft + r + rng() * (laneW - 2*r);
      } else {
        r = (16 + rng()*14) * DPR;
        x = laneLeft + r + rng() * (laneW - 2*r);
      }
      attempts++;
    } while(Math.abs(x - px) < (r + player.r + 30*DPR) && attempts < 10);

    hazards.push({ x, r, type, warned: false, active: true, hit: false,
                   impactAnim: 0, y: 0.55 * CH });
  }
}

// ── Reset game ────────────────────────────────────────────────────────────────
function resetGame(){
  gameSeed = SEED_PARAM ? parseInt(SEED_PARAM, 36) : (Math.random() * 0xFFFFFF | 0);
  rng = mulberry32(gameSeed);
  score = 0; combo = 0; comboTimer = 0; riskMultiplier = 1;
  shakeAmt = 0; colorHue = 200; frameCount = 0;
  player = { x: 0.5, vx: 0, y: 0.75, r: 10*DPR };
  pressing = false;
  phase = PHASE.WARN; phaseTimer = 0; phaseCycle = 0;
  warnDur = 1.0; impactDur = 0.5;
  hazards = []; particles = []; sparks = [];
  vignettePulse = 0;
  spawnHazards();
}

// ── Input ─────────────────────────────────────────────────────────────────────
function onDown(e){
  e.preventDefault();
  if(state === STATE.START)    { state = STATE.PLAYING; resetGame(); return; }
  if(state === STATE.GAMEOVER) { state = STATE.PLAYING; resetGame(); return; }
  pressing = true;
}
function onUp(e){
  e.preventDefault();
  pressing = false;
}
canvas.addEventListener('pointerdown', onDown, { passive: false });
canvas.addEventListener('pointerup',   onUp,   { passive: false });
canvas.addEventListener('pointercancel', onUp, { passive: false });
window.addEventListener('keydown', e => {
  if(e.code === 'Space' || e.code === 'Enter'){ e.preventDefault(); onDown(e); }
});
window.addEventListener('keyup', e => {
  if(e.code === 'Space' || e.code === 'Enter'){ e.preventDefault(); onUp(e); }
});

// ── Main update ───────────────────────────────────────────────────────────────
function update(ts){
  dt = Math.min((ts - last) / 1000, 0.05);
  last = ts;
  if(state !== STATE.PLAYING){ requestAnimationFrame(update); draw(); return; }

  frameCount++;
  const diff = getDifficulty();
  colorHue = (colorHue + dt * 12) % 360;
  shakeAmt *= shakeDecay;

  // Score
  score += dt * 10 * riskMultiplier * (1 + combo * 0.1);

  // Combo decay
  comboTimer -= dt;
  if(comboTimer < 0){ combo = 0; comboTimer = 0; }

  // Player steering
  const laneLeft  = LANE_MARGIN * CW;
  const laneRight = (1 - LANE_MARGIN) * CW;
  if(pressing){ player.vx += diff.sledSpeed * CW * dt; }
  else        { player.vx -= diff.sledSpeed * CW * dt * 0.7; }
  player.vx = Math.max(-CW*0.45, Math.min(CW*0.45, player.vx));
  player.x = (player.x * CW + player.vx * dt) / CW;

  // Wall bounce
  const pr = player.r / CW;
  if(player.x < LANE_MARGIN + pr){ player.x = LANE_MARGIN + pr; player.vx *= -0.3; }
  if(player.x > 1-LANE_MARGIN-pr){ player.x = 1-LANE_MARGIN-pr; player.vx *= -0.3; }

  // Risk multiplier (close to walls)
  const distToWall = Math.min(
    (player.x - LANE_MARGIN) * CW,
    ((1 - LANE_MARGIN) - player.x) * CW
  );
  const wallZone = 0.08 * CW;
  riskMultiplier = distToWall < wallZone ? 1 + (1 - distToWall/wallZone) * 2 : 1;

  // Phase logic
  phaseTimer += dt;
  warnDur   = diff.warnDur;
  impactDur = diff.impactDur;

  if(phase === PHASE.WARN && phaseTimer >= warnDur){
    phase = PHASE.IMPACT; phaseTimer = 0;
    vignettePulse = 1.0;
    // Activate all warned hazards
    hazards.forEach(h => { if(!h.hit) h.warned = true; });
  } else if(phase === PHASE.IMPACT && phaseTimer >= impactDur){
    phase = PHASE.WARN; phaseTimer = 0; phaseCycle++;
    // Clear spent hazards and spawn new ones
    hazards = hazards.filter(h => !h.hit);
    spawnHazards();
  }

  vignettePulse = Math.max(0, vignettePulse - dt * 2.5);

  // Impact phase: check collisions & near-misses
  if(phase === PHASE.IMPACT){
    const px = player.x * CW;
    const py = player.y * CH;
    hazards.forEach(h => {
      if(h.hit) return;
      h.impactAnim = Math.min(1, phaseTimer / (impactDur * 0.4));

      if(h.type === 'slab'){
        // bar: rect collision
        const barH = 18*DPR;
        const left = h.x - h.r, right = h.x + h.r;
        const top  = h.y - barH/2, bot = h.y + barH/2;
        if(px > left && px < right && py > top-player.r && py < bot+player.r){
          killPlayer(); return;
        }
        // near-miss for slab
        const nearX = px > left-30*DPR && px < right+30*DPR;
        const nearY = Math.abs(py - h.y) < 40*DPR;
        if(nearX && nearY && !h.nearMissed){ nearMiss(px, py); h.nearMissed = true; }
      } else {
        const dist = Math.hypot(px - h.x, py - h.y);
        if(dist < h.r + player.r - 4*DPR){ killPlayer(); return; }
        // near-miss
        if(dist < h.r + player.r + 28*DPR && !h.nearMissed){ nearMiss(px, py); h.nearMissed = true; }
      }
    });
  }

  // Particles
  particles.forEach(p => {
    p.x += p.vx; p.y += p.vy; p.vy += 0.12*DPR;
    p.life -= dt;
  });
  particles = particles.filter(p => p.life > 0);

  sparks.forEach(s => {
    s.x += s.vx; s.y += s.vy; s.vy += 0.08*DPR;
    s.life -= dt;
  });
  sparks = sparks.filter(s => s.life > 0);

  draw();
  requestAnimationFrame(update);
}

function nearMiss(x, y){
  combo++;
  comboTimer = 1.8;
  score += 50 * combo;
  spawnSparks(x, y);
}

function killPlayer(){
  if(state !== STATE.PLAYING) return;
  const px = player.x * CW, py = player.y * CH;
  spawnParticles(px, py, 30, `hsl(${colorHue},80%,70%)`, 5*DPR, 1.0);
  shakeAmt = 22*DPR;
  state = STATE.GAMEOVER;
  if(score > bestScore){ bestScore = score; localStorage.setItem('ge_best', bestScore|0); }
  // Share link
  const sl = document.getElementById('share-link');
  sl.style.display = 'block';
  sl.textContent = 'Challenge link: ' + location.origin + location.pathname + '?challenge=' + gameSeed.toString(36);
}

// ── Draw ──────────────────────────────────────────────────────────────────────
function draw(){
  ctx.save();

  // Screen shake
  const sx = shakeAmt > 0.5 ? (rng()-0.5)*shakeAmt*2 : 0;
  const sy = shakeAmt > 0.5 ? (rng()-0.5)*shakeAmt*2 : 0;
  ctx.translate(sx, sy);

  // Background
  const grad = ctx.createLinearGradient(0, 0, 0, CH);
  grad.addColorStop(0, '#071628');
  grad.addColorStop(1, '#0d2a18');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, CW, CH);

  // Glacier walls
  const laneLeft  = LANE_MARGIN * CW;
  const laneRight = (1 - LANE_MARGIN) * CW;
  drawWalls(laneLeft, laneRight);

  // Ice lane texture
  drawLane(laneLeft, laneRight);

  if(state === STATE.START){
    drawStartScreen();
    ctx.restore();
    return;
  }

  // Phase indicator strip
  drawPhaseStrip();

  // Hazards
  hazards.forEach(h => drawHazard(h));

  // Player
  drawPlayer();

  // Particles
  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.col;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3*DPR, 0, Math.PI*2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  // Sparks
  sparks.forEach(s => {
    const alpha = s.life / 0.4;
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = '#fff8a0';
    ctx.lineWidth = 1.5*DPR;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(s.x + s.vx*3, s.y + s.vy*3);
    ctx.stroke();
  });
  ctx.globalAlpha = 1;

  // Vignette
  if(vignettePulse > 0){
    const vg = ctx.createRadialGradient(CW/2,CH/2,CH*0.2, CW/2,CH/2,CH*0.85);
    vg.addColorStop(0, 'rgba(0,80,180,0)');
    vg.addColorStop(1, `rgba(0,40,140,${vignettePulse*0.55})`);
    ctx.fillStyle = vg;
    ctx.fillRect(0, 0, CW, CH);
  }

  // HUD
  drawHUD();

  if(state === STATE.GAMEOVER) drawGameOver();

  ctx.restore();
}

function drawWalls(ll, lr){
  // Left wall
  const wg1 = ctx.createLinearGradient(0, 0, ll+10*DPR, 0);
  wg1.addColorStop(0, 'rgba(140,210,255,0.55)');
  wg1.addColorStop(1, 'rgba(80,160,220,0.15)');
  ctx.fillStyle = wg1;
  ctx.fillRect(0, 0, ll, CH);

  // Wall edge glow
  const eg1 = ctx.createLinearGradient(ll, 0, ll+8*DPR, 0);
  eg1.addColorStop(0, 'rgba(180,230,255,0.7)');
  eg1.addColorStop(1, 'rgba(180,230,255,0)');
  ctx.fillStyle = eg1;
  ctx.fillRect(ll, 0, 8*DPR, CH);

  // Right wall
  const wg2 = ctx.createLinearGradient(CW, 0, lr-10*DPR, 0);
  wg2.addColorStop(0, 'rgba(140,210,255,0.55)');
  wg2.addColorStop(1, 'rgba(80,160,220,0.15)');
  ctx.fillStyle = wg2;
  ctx.fillRect(lr, 0, CW-lr, CH);

  const eg2 = ctx.createLinearGradient(lr, 0, lr-8*DPR, 0);
  eg2.addColorStop(0, 'rgba(180,230,255,0.7)');
  eg2.addColorStop(1, 'rgba(180,230,255,0)');
  ctx.fillStyle = eg2;
  ctx.fillRect(lr-8*DPR, 0, 8*DPR, CH);

  // Risk zone glow when close to wall
  if(state === STATE.PLAYING && riskMultiplier > 1){
    const intensity = (riskMultiplier - 1) / 2;
    ctx.strokeStyle = `rgba(255,160,60,${intensity*0.8})`;
    ctx.lineWidth = 3*DPR;
    ctx.setLineDash([14*DPR, 8*DPR]);
    ctx.beginPath(); ctx.moveTo(ll+4*DPR, 0); ctx.lineTo(ll+4*DPR, CH); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(lr-4*DPR, 0); ctx.lineTo(lr-4*DPR, CH); ctx.stroke();
    ctx.setLineDash([]);
  }
}

function drawLane(ll, lr){
  // Subtle ice lines
  ctx.strokeStyle = 'rgba(180,230,255,0.07)';
  ctx.lineWidth = 1*DPR;
  const lw = lr - ll;
  for(let i=1;i<5;i++){
    const x = ll + lw * (i/5);
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, CH); ctx.stroke();
  }
  // Scrolling crack lines
  const scrollY = (frameCount * 2.5 * DPR) % (CH);
  ctx.strokeStyle = 'rgba(180,230,255,0.05)';
  for(let i=0;i<6;i++){
    const y = (scrollY + i * CH/6) % CH;
    ctx.beginPath(); ctx.moveTo(ll, y); ctx.lineTo(lr, y); ctx.stroke();
  }
}

function drawPhaseStrip(){
  const prog = phaseTimer / (phase === PHASE.WARN ? warnDur : impactDur);
  const barH = 5*DPR;
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.fillRect(0, 0, CW, barH);
  if(phase === PHASE.WARN){
    ctx.fillStyle = `hsl(200,80%,65%)`;
  } else {
    ctx.fillStyle = `hsl(15,90%,65%)`;
  }
  ctx.fillRect(0, 0, CW * prog, barH);
}

function drawHazard(h){
  const alpha = phase === PHASE.WARN ? 0.55 : Math.min(1, 0.3 + h.impactAnim * 0.7);

  if(h.type === 'slab'){
    const barH = 18*DPR;
    const left = h.x - h.r, right = h.x + h.r;
    const iy = h.y;

    if(phase === PHASE.WARN){
      // Shadow bar warning
      ctx.strokeStyle = `rgba(255,140,30,${alpha})`;
      ctx.lineWidth = 3*DPR;
      ctx.setLineDash([10*DPR, 6*DPR]);
      ctx.strokeRect(left, iy - barH/2, h.r*2, barH);
      ctx.setLineDash([]);
      // Arrow indicators
      ctx.fillStyle = `rgba(255,180,50,${alpha*0.7})`;
      ctx.font = `bold ${14*DPR}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText('▼', h.x, iy - barH);
    } else {
      // Impact slab
      ctx.save();
      const scaleT = h.impactAnim;
      ctx.globalAlpha = alpha;
      const gg = ctx.createLinearGradient(left, iy-barH, right, iy+barH);
      gg.addColorStop(0, `hsl(${colorHue+40},70%,75%)`);
      gg.addColorStop(1, `hsl(${colorHue+60},80%,55%)`);
      ctx.fillStyle = gg;
      ctx.shadowColor = `hsl(${colorHue+50},90%,70%)`;
      ctx.shadowBlur = 18*DPR;
      ctx.fillRect(left, iy - barH/2, h.r*2, barH);
      ctx.restore();
      // Crack effect
      if(scaleT > 0.7){
        spawnParticles(h.x + (rng()-0.5)*h.r, iy, 1, '#cceeff', 3*DPR, 0.3);
      }
    }
  } else if(h.type === 'splitter'){
    // Double ring
    const offsets = [-h.r*0.65, h.r*0.65];
    offsets.forEach(off => {
      const cx2 = h.x + off, cy2 = h.y;
      const r2 = h.r * 0.55;
      drawSingleHazard(cx2, cy2, r2, alpha, h.impactAnim);
      if(phase === PHASE.WARN){
        ctx.strokeStyle = `rgba(255,100,60,${alpha*0.5})`;
        ctx.lineWidth = 2*DPR;
        ctx.beginPath(); ctx.arc(cx2, cy2, r2+10*DPR, 0, Math.PI*2); ctx.stroke();
      }
    });
  } else {
    drawSingleHazard(h.x, h.y, h.r, alpha, h.impactAnim);
    if(phase === PHASE.WARN){
      // Outer warning ring
      ctx.strokeStyle = `rgba(255,180,40,${alpha*0.5})`;
      ctx.lineWidth = 2*DPR;
      ctx.setLineDash([6*DPR, 4*DPR]);
      ctx.beginPath(); ctx.arc(h.x, h.y, h.r+12*DPR, 0, Math.PI*2); ctx.stroke();
      ctx.setLineDash([]);
    }
  }
}

function drawSingleHazard(x, y, r, alpha, impactAnim){
  ctx.save();
  ctx.globalAlpha = alpha;
  if(phase === PHASE.WARN){
    // Shadow/ghost
    ctx.fillStyle = `rgba(80,150,220,0.3)`;
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = `rgba(150,200,255,0.7)`;
    ctx.lineWidth = 2.5*DPR;
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.stroke();
  } else {
    const g = ctx.createRadialGradient(x-r*0.3, y-r*0.3, r*0.1, x, y, r);
    g.addColorStop(0, `hsl(${colorHue+20},60%,88%)`);
    g.addColorStop(0.6, `hsl(${colorHue},50%,60%)`);
    g.addColorStop(1, `hsl(${colorHue-20},70%,35%)`);
    ctx.fillStyle = g;
    ctx.shadowColor = `hsl(${colorHue},90%,80%)`;
    ctx.shadowBlur = 16*DPR;
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();
}

function drawPlayer(){
  const px = player.x * CW;
  const py = player.y * CH;
  // Sled glow
  ctx.save();
  ctx.shadowColor = `hsl(${colorHue},100%,70%)`;
  ctx.shadowBlur = 20*DPR;

  // Sled body
  const sg = ctx.createRadialGradient(px, py-3*DPR, 1*DPR, px, py, player.r);
  sg.addColorStop(0, '#ffffff');
  sg.addColorStop(0.5, `hsl(${colorHue+30},90%,75%)`);
  sg.addColorStop(1, `hsl(${colorHue},80%,55%)`);
  ctx.fillStyle = sg;
  ctx.beginPath();
  ctx.ellipse(px, py, player.r, player.r*0.65, 0, 0, Math.PI*2);
  ctx.fill();

  // Speed lines behind sled
  ctx.strokeStyle = `rgba(180,230,255,0.35)`;
  ctx.lineWidth = 1.5*DPR;
  for(let i=0;i<3;i++){
    const off = (i-1)*4*DPR;
    const len = (18 + i*6) * DPR;
    ctx.beginPath();
    ctx.moveTo(px + off, py + player.r*0.5);
    ctx.lineTo(px + off, py + player.r*0.5 + len);
    ctx.stroke();
  }
  ctx.restore();

  // Risk multiplier halo
  if(riskMultiplier > 1){
    const ri = (riskMultiplier - 1) / 2;
    ctx.save();
    ctx.globalAlpha = ri * 0.6;
    ctx.strokeStyle = `rgba(255,160,30,0.9)`;
    ctx.lineWidth = 2.5*DPR;
    ctx.beginPath(); ctx.arc(px, py, player.r+8*DPR, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }
}

function drawHUD(){
  const fontSize = Math.round(15*DPR);
  ctx.font = `bold ${fontSize}px 'Segoe UI', sans-serif`;
  ctx.textBaseline = 'top';

  // Score
  ctx.fillStyle = '#e0f4ff';
  ctx.textAlign = 'left';
  ctx.fillText(`${score|0}`, 14*DPR, 14*DPR);

  // Best
  ctx.fillStyle = 'rgba(180,220,255,0.6)';
  ctx.font = `${Math.round(11*DPR)}px 'Segoe UI', sans-serif`;
  ctx.fillText(`BEST ${bestScore|0}`, 14*DPR, 34*DPR);

  // Phase label
  ctx.textAlign = 'center';
  ctx.font = `bold ${Math.round(11*DPR)}px 'Segoe UI', sans-serif`;
  if(phase === PHASE.WARN){
    ctx.fillStyle = 'rgba(120,190,255,0.85)';
    ctx.fillText('PLAN', CW/2, 10*DPR);
  } else {
    ctx.fillStyle = 'rgba(255,140,60,0.9)';
    ctx.fillText('DODGE!', CW/2, 10*DPR);
  }

  // Combo
  if(combo > 1){
    ctx.textAlign = 'center';
    ctx.font = `bold ${Math.round(18*DPR)}px 'Segoe UI', sans-serif`;
    ctx.fillStyle = `hsl(${colorHue},90%,75%)`;
    ctx.globalAlpha = Math.min(1, comboTimer);
    ctx.fillText(`x${combo} COMBO!`, CW/2, CH*0.18);
    ctx.globalAlpha = 1;
  }

  // Risk multiplier
  if(riskMultiplier > 1.05){
    ctx.textAlign = 'right';
    ctx.font = `bold ${Math.round(12*DPR)}px 'Segoe UI', sans-serif`;
    ctx.fillStyle = `rgba(255,180,60,${Math.min(1, (riskMultiplier-1)/1.5)})`;
    ctx.fillText(`RISK x${riskMultiplier.toFixed(1)}`, CW - 14*DPR, 14*DPR);
  }
}

function drawStartScreen(){
  // Title
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Title glow
  ctx.shadowColor = 'rgba(100,200,255,0.9)';
  ctx.shadowBlur = 30*DPR;
  ctx.font = `bold ${Math.round(38*DPR)}px 'Segoe UI', sans-serif`;
  ctx.fillStyle = '#d0f0ff';
  ctx.fillText('GLACIER', CW/2, CH*0.32);
  ctx.fillText('ESCAPE', CW/2, CH*0.32 + 44*DPR);

  ctx.shadowBlur = 0;
  ctx.font = `${Math.round(14*DPR)}px 'Segoe UI', sans-serif`;
  ctx.fillStyle = 'rgba(180,230,255,0.75)';
  ctx.fillText('Zoom Pulse Edition', CW/2, CH*0.32 + 82*DPR);

  // Tap to start (pulsing)
  const pulse = 0.7 + 0.3 * Math.sin(frameCount * 0.08);
  ctx.globalAlpha = pulse;
  ctx.font = `bold ${Math.round(17*DPR)}px 'Segoe UI', sans-serif`;
  ctx.fillStyle = '#80d0ff';
  ctx.fillText('TAP TO START', CW/2, CH*0.58);
  ctx.globalAlpha = 1;

  // Controls hint
  ctx.font = `${Math.round(12*DPR)}px 'Segoe UI', sans-serif`;
  ctx.fillStyle = 'rgba(140,200,240,0.6)';
  ctx.fillText('Hold → steer right  |  Release → drift left', CW/2, CH*0.65);
  ctx.fillText('Near-miss ice chunks for bonus points!', CW/2, CH*0.68);

  ctx.restore();
  frameCount++;
}

function drawGameOver(){
  ctx.save();
  // Overlay
  ctx.fillStyle = 'rgba(2,10,25,0.75)';
  ctx.fillRect(0, 0, CW, CH);

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  ctx.shadowColor = 'rgba(255,80,80,0.8)';
  ctx.shadowBlur = 25*DPR;
  ctx.font = `bold ${Math.round(32*DPR)}px 'Segoe UI', sans-serif`;
  ctx.fillStyle = '#ff9090';
  ctx.fillText('CRUSHED', CW/2, CH*0.30);
  ctx.shadowBlur = 0;

  ctx.font = `${Math.round(22*DPR)}px 'Segoe UI', sans-serif`;
  ctx.fillStyle = '#e0f4ff';
  ctx.fillText(`${score|0}`, CW/2, CH*0.40);

  ctx.font = `${Math.round(13*DPR)}px 'Segoe UI', sans-serif`;
  ctx.fillStyle = 'rgba(180,220,255,0.7)';
  ctx.fillText(`BEST  ${bestScore|0}`, CW/2, CH*0.47);

  // Tap to retry (pulse)
  const pulse = 0.7 + 0.3 * Math.sin(frameCount * 0.08);
  ctx.globalAlpha = pulse;
  ctx.font = `bold ${Math.round(17*DPR)}px 'Segoe UI', sans-serif`;
  ctx.fillStyle = '#80d0ff';
  ctx.fillText('TAP TO RETRY', CW/2, CH*0.57);
  ctx.globalAlpha = 1;

  ctx.restore();
  frameCount++;
}

// ── Start ─────────────────────────────────────────────────────────────────────
requestAnimationFrame(function boot(ts){
  last = ts;
  requestAnimationFrame(update);
});

draw();
})();
</script>
</body>
</html>
