<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Dusk Drift - Free HTML5 Game</title>
<meta name="description" content="Play Dusk Drift - Tap to merge drifting numbers that leave sparkling trails in a twilight sky.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta property="og:type" content="website">
<meta property="og:title" content="Dusk Drift - Free HTML5 Game">
<meta property="og:description" content="Play Dusk Drift - Tap to merge drifting numbers that leave sparkling trails in a twilight sky.">
<meta property="og:url" content="https://balinti.github.io/dusk-drift/">
<meta property="og:image" content="https://balinti.github.io/dusk-drift/og.png">
<meta name="theme-color" content="#1a0a2e">
<link rel="canonical" href="https://balinti.github.io/dusk-drift/">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;height:100svh;background:#0d0618;display:flex;align-items:center;justify-content:center;overflow:hidden;font-family:'Segoe UI',sans-serif}
#game-container{position:relative;width:420px;height:750px;max-width:100vw;max-height:100svh;background:linear-gradient(180deg,#0d0618 0%,#1a0a2e 40%,#2d1044 70%,#3d1a22 100%)}
canvas{display:block;width:100%;height:100%}
#score-ui{position:absolute;top:0;left:0;right:0;padding:12px 16px;display:flex;justify-content:space-between;align-items:flex-start;pointer-events:none;z-index:10}
.score-box{text-align:center}
.score-label{font-size:11px;color:rgba(255,200,255,0.6);text-transform:uppercase;letter-spacing:1px}
.score-val{font-size:22px;font-weight:700;color:#fff;text-shadow:0 0 10px rgba(200,100,255,0.8)}
</style>
</head>
<body>
<div id="game-container">
  <canvas id="c"></canvas>
  <div id="score-ui">
    <div class="score-box"><div class="score-label">Score</div><div class="score-val" id="ui-score">0</div></div>
    <div class="score-box"><div class="score-label">Best</div><div class="score-val" id="ui-best">0</div></div>
  </div>
</div>
<script>
(function(){
'use strict';

const container = document.getElementById('game-container');
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const dpr = window.devicePixelRatio || 1;
let CW = 420, CH = 750;

function resizeCanvas() {
  const rect = container.getBoundingClientRect();
  CW = rect.width; CH = rect.height;
  canvas.width = Math.round(CW * dpr);
  canvas.height = Math.round(CH * dpr);
  canvas.style.width = CW + 'px';
  canvas.style.height = CH + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const LS_KEY = 'duskdrift_best';
const HORIZON_FRAC = 0.82;
const ORB_R = 22;
const PULSE_DUR = 0.35;
const SHAKE_DUR = 0.4;

const DIFF = [
  {t:0,  lanes:3, speed:55,  spawnInt:2.2, maxVal:4},
  {t:10, lanes:3, speed:70,  spawnInt:1.8, maxVal:8},
  {t:25, lanes:4, speed:90,  spawnInt:1.4, maxVal:8},
  {t:45, lanes:4, speed:108, spawnInt:1.1, maxVal:16},
  {t:70, lanes:5, speed:130, spawnInt:0.85,maxVal:32},
];

let state = 'start';
let score = 0;
let best = parseInt(localStorage.getItem(LS_KEY)) || 0;
let gameTime = 0;
let lastTime = null;
let orbs = [];
let nextId = 0;
let pulseActive = false, pulseT = 0, pulseX = 0, pulseY = 0;
let particles = [];
let floatTexts = [];
let shakeT = 0, shakeAmt = 0;
let windTimer = 0, windActive = false, windT = 0, windDir = 0;
let numLanes = 3;
let laneXs = [];
let spawnTimer = 0;
let hueShift = 0;
let starsArr = null;

function getDiff() {
  let d = DIFF[0];
  for (let i = DIFF.length - 1; i >= 0; i--) {
    if (gameTime >= DIFF[i].t) { d = DIFF[i]; break; }
  }
  return d;
}

function getLaneXs(n, wo) {
  const margin = CW * 0.12;
  const usable = CW - margin * 2;
  const xs = [];
  for (let i = 0; i < n; i++) xs.push(margin + (usable / (n - 1)) * i + (wo || 0));
  return xs;
}

function laneX(li, y) {
  const base = laneXs[li] || CW / 2;
  return base + Math.sin(y * 0.004 + li * 1.1) * 6;
}

function hy() { return CH * HORIZON_FRAC; }

function spawnOrb() {
  const d = getDiff();
  const lane = Math.floor(Math.random() * numLanes);
  const vals = [2,2,2,4,4];
  if (d.maxVal >= 8)  vals.push(4,8);
  if (d.maxVal >= 16) vals.push(8,16);
  if (d.maxVal >= 32) vals.push(16,32);
  const val = vals[Math.floor(Math.random() * vals.length)];
  orbs.push({id:nextId++, lane, x:laneX(lane,-40), y:-40, val,
    trail:[], merging:false, mergeT:0, pushY:0, alive:true,
    hue:(hueShift + lane * 60) % 360});
}

function addParticles(x, y, count, hue) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const spd = 60 + Math.random() * 120;
    particles.push({x, y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd,
      life:0.6+Math.random()*0.4, maxLife:1, r:2+Math.random()*3,
      hue:hue+(Math.random()-0.5)*40});
  }
}

function addFloat(x, y, text, hue) {
  floatTexts.push({x, y, text, hue, life:1.2, vy:-60});
}

function triggerShake(amt) { shakeAmt = amt; shakeT = SHAKE_DUR; }

function firePulse() {
  if (state !== 'playing') return;
  pulseActive = true; pulseT = 0;
  pulseX = CW / 2; pulseY = CH / 2;

  for (const o of orbs) o.x = laneX(o.lane, 0);

  const lanes = {};
  for (const o of orbs) {
    if (!o.alive) continue;
    if (!lanes[o.lane]) lanes[o.lane] = [];
    lanes[o.lane].push(o);
  }

  let comboChain = 0;
  for (const lid in lanes) {
    const col = lanes[lid].sort((a,b) => a.y - b.y);
    let merged = true;
    while (merged) {
      merged = false;
      for (let i = 0; i < col.length - 1; i++) {
        const a = col[i], b = col[i+1];
        if (!a.alive || !b.alive) continue;
        if (Math.abs(b.y - a.y) > ORB_R * 4) continue;
        if (a.val === b.val) {
          a.val *= 2; a.pushY = -30; a.merging = true; a.mergeT = 0;
          b.alive = false;
          addParticles(a.x, a.y, 16, a.hue);
          const pts = a.val * (1 + comboChain * 0.5);
          score += Math.round(pts);
          comboChain++;
          if (comboChain > 1) addFloat(a.x, a.y - 30, 'x' + comboChain + ' Combo!', a.hue);
          merged = true;
        }
      }
      for (let i = col.length - 1; i >= 0; i--) if (!col[i].alive) col.splice(i, 1);
    }
  }
  orbs = orbs.filter(o => o.alive);
  document.getElementById('ui-score').textContent = score;
}

function update(dt) {
  hueShift = (hueShift + dt * 15) % 360;
  if (state !== 'playing') return;

  gameTime += dt;
  const d = getDiff();
  numLanes = d.lanes;

  let windOffset = 0;
  windTimer += dt;
  if (gameTime >= 45) {
    if (!windActive && windTimer >= 8) {
      windActive = true; windT = 0; windTimer = 0;
      windDir = Math.random() < 0.5 ? 1 : -1;
    }
  }
  if (windActive) {
    windT += dt;
    const wDur = 3.5;
    if (windT < wDur) windOffset = windDir * 18 * Math.sin(Math.PI * windT / wDur);
    else { windActive = false; windOffset = 0; }
  }
  laneXs = getLaneXs(numLanes, windOffset);

  spawnTimer += dt;
  if (spawnTimer >= d.spawnInt) {
    spawnTimer = 0; spawnOrb();
    if (d.lanes >= 4 && Math.random() < 0.25) spawnOrb();
  }

  for (const o of orbs) {
    o.trail.push({x:o.x, y:o.y});
    if (o.trail.length > 8) o.trail.shift();
    o.y += d.speed * dt;
    if (o.pushY !== 0) {
      o.y += o.pushY * dt * 4;
      o.pushY *= (1 - dt * 6);
      if (Math.abs(o.pushY) < 0.5) o.pushY = 0;
    }
    o.x += (laneX(o.lane, windOffset) - o.x) * dt * 5;
    if (o.merging) { o.mergeT += dt; if (o.mergeT > 0.3) o.merging = false; }
    if (o.y >= hy() + ORB_R) { endGame(); return; }
  }

  for (const p of particles) {
    p.x += p.vx * dt; p.y += p.vy * dt; p.vy += 120 * dt; p.life -= dt;
  }
  particles = particles.filter(p => p.life > 0);

  for (const f of floatTexts) { f.y += f.vy * dt; f.life -= dt; }
  floatTexts = floatTexts.filter(f => f.life > 0);

  if (pulseActive) { pulseT += dt; if (pulseT >= PULSE_DUR) pulseActive = false; }
  if (shakeT > 0) shakeT -= dt;
  document.getElementById('ui-score').textContent = score;
}

function endGame() {
  state = 'gameover';
  if (score > best) { best = score; localStorage.setItem(LS_KEY, best); }
  document.getElementById('ui-best').textContent = best;
  triggerShake(10);
}

function startGame() {
  state = 'playing'; score = 0; gameTime = 0;
  orbs = []; particles = []; floatTexts = [];
  pulseActive = false; spawnTimer = 0; windTimer = 0; windActive = false;
  numLanes = 3; laneXs = getLaneXs(3, 0);
  document.getElementById('ui-score').textContent = '0';
  document.getElementById('ui-best').textContent = best;
  for (let i = 0; i < 3; i++) { spawnOrb(); orbs[orbs.length-1].y = 80 + i * 140; }
}

function drawStars() {
  if (!starsArr) {
    starsArr = [];
    for (let i = 0; i < 80; i++)
      starsArr.push({x:Math.random()*420, y:Math.random()*CH*0.6, r:Math.random()*1.5, blink:Math.random()*Math.PI*2});
  }
  const t = Date.now() / 1000;
  for (const s of starsArr) {
    const alpha = 0.3 + 0.5 * Math.abs(Math.sin(s.blink + t * 0.8));
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
    ctx.fillStyle = `rgba(255,220,255,${alpha})`;
    ctx.fill();
  }
}

function drawHorizon() {
  const y = hy();
  const grad = ctx.createLinearGradient(0, y-20, 0, y+20);
  grad.addColorStop(0, 'rgba(200,80,120,0)');
  grad.addColorStop(0.5, `hsla(${(hueShift+20)%360},80%,60%,0.7)`);
  grad.addColorStop(1, 'rgba(60,10,30,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, y-20, CW, 40);
  ctx.beginPath();
  ctx.moveTo(0, y); ctx.lineTo(CW, y);
  ctx.strokeStyle = `hsla(${(hueShift+20)%360},90%,70%,0.9)`;
  ctx.lineWidth = 1.5; ctx.stroke();
}

function drawLanes() {
  if (!laneXs.length) return;
  const horizY = hy();
  for (let i = 0; i < laneXs.length; i++) {
    ctx.save(); ctx.beginPath();
    const steps = 40;
    for (let s = 0; s <= steps; s++) {
      const y = (s/steps) * horizY;
      const x = laneX(i, 0);
      s === 0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
    }
    ctx.strokeStyle = `hsla(${(hueShift+i*60)%360},60%,60%,0.15)`;
    ctx.lineWidth = 1; ctx.setLineDash([6,10]); ctx.stroke(); ctx.setLineDash([]); ctx.restore();
    if (pulseActive) {
      const alpha = (1 - pulseT/PULSE_DUR) * 0.3;
      ctx.save(); ctx.beginPath();
      for (let s = 0; s <= steps; s++) {
        const y = (s/steps) * horizY;
        const x = laneX(i, 0);
        s === 0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
      }
      ctx.strokeStyle = `hsla(${(hueShift+i*60)%360},90%,80%,${alpha})`;
      ctx.lineWidth = 3; ctx.stroke(); ctx.restore();
    }
  }
}

function drawPulse() {
  const t = pulseT / PULSE_DUR;
  const r = t * CW * 0.9;
  const alpha = (1 - t) * 0.7;
  const grad = ctx.createRadialGradient(pulseX,pulseY,r*0.7, pulseX,pulseY,r);
  grad.addColorStop(0, `hsla(${hueShift},80%,70%,0)`);
  grad.addColorStop(0.7, `hsla(${hueShift},90%,80%,${alpha*0.3})`);
  grad.addColorStop(1, `hsla(${hueShift},90%,90%,${alpha})`);
  ctx.beginPath(); ctx.arc(pulseX, pulseY, r, 0, Math.PI*2);
  ctx.strokeStyle = `hsla(${hueShift},90%,85%,${alpha})`;
  ctx.lineWidth = 2; ctx.stroke();
  ctx.fillStyle = grad; ctx.fill();
}

function drawOrb(o) {
  for (let i = 0; i < o.trail.length; i++) {
    const tf = i / o.trail.length;
    const tr = o.trail[i];
    ctx.beginPath(); ctx.arc(tr.x, tr.y, ORB_R*0.5*tf, 0, Math.PI*2);
    ctx.fillStyle = `hsla(${o.hue},80%,65%,${tf*0.25})`; ctx.fill();
  }
  const scale = o.merging ? (1 + 0.3*Math.sin(o.mergeT*Math.PI/0.3)) : 1;
  ctx.save(); ctx.translate(o.x, o.y); ctx.scale(scale, scale);
  const warn = Math.max(0, 1 - (hy()-o.y)/(hy()*0.35));
  const warnAlpha = warn * (0.5 + 0.5*Math.sin(Date.now()*0.008));
  const glow = ctx.createRadialGradient(0,0,ORB_R*0.3, 0,0,ORB_R*1.8);
  glow.addColorStop(0, `hsla(${o.hue},90%,80%,0.5)`);
  glow.addColorStop(1, `hsla(${o.hue},90%,60%,0)`);
  ctx.beginPath(); ctx.arc(0,0,ORB_R*1.8, 0, Math.PI*2); ctx.fillStyle=glow; ctx.fill();
  if (warn > 0) {
    const wg = ctx.createRadialGradient(0,0,0, 0,0,ORB_R*2.2);
    wg.addColorStop(0, `hsla(0,100%,70%,${warnAlpha*0.6})`);
    wg.addColorStop(1, `hsla(0,100%,60%,0)`);
    ctx.beginPath(); ctx.arc(0,0,ORB_R*2.2,0,Math.PI*2); ctx.fillStyle=wg; ctx.fill();
  }
  const grad = ctx.createRadialGradient(-ORB_R*0.3,-ORB_R*0.3,2, 0,0,ORB_R);
  grad.addColorStop(0, `hsla(${o.hue},70%,90%,0.95)`);
  grad.addColorStop(0.5, `hsla(${o.hue},80%,65%,0.9)`);
  grad.addColorStop(1, `hsla(${(o.hue+30)%360},90%,40%,0.85)`);
  ctx.beginPath(); ctx.arc(0,0,ORB_R,0,Math.PI*2);
  ctx.fillStyle=grad; ctx.fill();
  ctx.strokeStyle=`hsla(${o.hue},90%,85%,0.7)`; ctx.lineWidth=1.5; ctx.stroke();
  ctx.fillStyle='#fff';
  ctx.font=`bold ${o.val>=100?13:o.val>=10?15:17}px 'Segoe UI',sans-serif`;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.shadowColor=`hsla(${o.hue},90%,80%,1)`; ctx.shadowBlur=6;
  ctx.fillText(o.val, 0, 0); ctx.shadowBlur=0;
  ctx.restore();
}

function drawParticles() {
  for (const p of particles) {
    const alpha = p.life / p.maxLife;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r*alpha,0,Math.PI*2);
    ctx.fillStyle=`hsla(${p.hue},90%,80%,${alpha})`; ctx.fill();
  }
}

function drawFloatTexts() {
  for (const f of floatTexts) {
    ctx.save(); ctx.globalAlpha=Math.min(1,f.life);
    ctx.font='bold 18px Segoe UI,sans-serif';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillStyle=`hsl(${f.hue},90%,80%)`;
    ctx.shadowColor=`hsl(${f.hue},90%,60%)`; ctx.shadowBlur=8;
    ctx.fillText(f.text, f.x, f.y); ctx.restore();
  }
}

function drawStartScreen() {
  ctx.save();
  ctx.fillStyle='rgba(10,4,24,0.75)'; ctx.fillRect(0,0,CW,CH);
  const t = Date.now()/1000;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.font='bold 46px Segoe UI,sans-serif';
  ctx.fillStyle=`hsl(${hueShift},80%,75%)`;
  ctx.shadowColor=`hsl(${hueShift},90%,60%)`; ctx.shadowBlur=20;
  ctx.fillText('Dusk Drift', CW/2, CH*0.3); ctx.shadowBlur=0;
  ctx.font='18px Segoe UI,sans-serif';
  ctx.fillStyle=`hsla(${(hueShift+40)%360},70%,80%,0.85)`;
  ctx.fillText('Pulse Merge', CW/2, CH*0.3+52);
  ctx.font='14px Segoe UI,sans-serif';
  ctx.fillStyle='rgba(200,180,255,0.7)';
  ctx.fillText('Tap/Click to emit a Dusk Pulse', CW/2, CH*0.52);
  ctx.fillText('Merge equal orbs before they', CW/2, CH*0.52+24);
  ctx.fillText('cross the horizon!', CW/2, CH*0.52+48);
  const pulse = 0.7+0.3*Math.sin(t*3);
  ctx.globalAlpha=pulse;
  ctx.font='bold 20px Segoe UI,sans-serif';
  ctx.fillStyle=`hsl(${(hueShift+60)%360},80%,80%)`;
  ctx.shadowColor=`hsl(${(hueShift+60)%360},90%,70%)`; ctx.shadowBlur=12;
  ctx.fillText('Tap to Start', CW/2, CH*0.72); ctx.shadowBlur=0;
  ctx.restore();
}

function drawGameOverScreen() {
  ctx.save();
  ctx.fillStyle='rgba(10,4,24,0.82)'; ctx.fillRect(0,0,CW,CH);
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.font='bold 38px Segoe UI,sans-serif';
  ctx.fillStyle='hsl(0,80%,70%)';
  ctx.shadowColor='rgba(255,80,80,0.8)'; ctx.shadowBlur=18;
  ctx.fillText('Game Over', CW/2, CH*0.3); ctx.shadowBlur=0;
  ctx.font='22px Segoe UI,sans-serif';
  ctx.fillStyle='rgba(220,200,255,0.9)';
  ctx.fillText('Score: '+score, CW/2, CH*0.3+60);
  ctx.font='16px Segoe UI,sans-serif';
  ctx.fillStyle='rgba(180,160,220,0.7)';
  ctx.fillText('Best: '+best, CW/2, CH*0.3+92);
  const t = Date.now()/1000;
  const pulse = 0.7+0.3*Math.sin(t*3);
  ctx.globalAlpha=pulse;
  ctx.font='bold 20px Segoe UI,sans-serif';
  ctx.fillStyle=`hsl(${hueShift},80%,80%)`;
  ctx.shadowColor=`hsl(${hueShift},90%,70%)`; ctx.shadowBlur=12;
  ctx.fillText('Tap to Retry', CW/2, CH*0.72); ctx.shadowBlur=0;
  ctx.restore();
}

function draw() {
  let sx=0, sy=0;
  if (shakeT > 0) {
    const s = (shakeT/SHAKE_DUR)*shakeAmt;
    sx=(Math.random()-0.5)*s*2; sy=(Math.random()-0.5)*s*2;
  }
  ctx.save(); ctx.translate(sx, sy);
  const bg = ctx.createLinearGradient(0,0,0,CH);
  bg.addColorStop(0,'#0d0618'); bg.addColorStop(0.4,'#1a0a2e');
  bg.addColorStop(0.75,'#2d1044'); bg.addColorStop(1,'#3d1a22');
  ctx.fillStyle=bg; ctx.fillRect(0,0,CW,CH);
  drawStars(); drawHorizon();
  if (state==='playing'||state==='gameover') {
    drawLanes();
    if (pulseActive) drawPulse();
    for (const o of orbs) drawOrb(o);
    drawParticles(); drawFloatTexts();
  }
  if (state==='start') drawStartScreen();
  if (state==='gameover') drawGameOverScreen();
  ctx.restore();
}

function handleInput() {
  if (state==='start') startGame();
  else if (state==='playing') firePulse();
  else if (state==='gameover') startGame();
}

canvas.addEventListener('pointerdown', e => { e.preventDefault(); handleInput(); });
window.addEventListener('keydown', e => {
  if (e.code==='Space'||e.code==='Enter') { e.preventDefault(); handleInput(); }
});

function loop(ts) {
  if (lastTime===null) lastTime=ts;
  let dt = Math.min((ts-lastTime)/1000, 0.05);
  lastTime = ts;
  update(dt); draw();
  requestAnimationFrame(loop);
}

laneXs = getLaneXs(3, 0);
document.getElementById('ui-best').textContent = best;
requestAnimationFrame(loop);
})();
</script>
</body>
</html>
