<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Neon Coil - Free HTML5 Game</title>
  <meta name="description" content="Play Neon Coil - Dodge obstacles and grab randomly spawning powerups as your neon snake rapidly grows.">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#05060a">
  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Neon Coil - Free HTML5 Game">
  <meta property="og:description" content="Play Neon Coil - Dodge obstacles and grab randomly spawning powerups as your neon snake rapidly grows.">
  <meta property="og:url" content="https://balinti.github.io/neon-coil/">
  <meta property="og:image" content="https://balinti.github.io/neon-coil/og.png">
  <!-- AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      height: 100%;
      background: #05060a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      font-family: 'Segoe UI', system-ui, sans-serif;
      color: #e0e0ff;
      overflow-x: hidden;
    }
    #game-wrap {
      position: relative;
      width: 100%;
      max-width: 420px;
      flex-shrink: 0;
    }
    #canvas-container {
      position: relative;
      width: 100%;
      background: #05060a;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    #ui-overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 14px 16px 0;
    }
    #score-row {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    .ui-label { font-size: 11px; letter-spacing: 0.12em; text-transform: uppercase; opacity: 0.5; line-height: 1; }
    .ui-value { font-size: 26px; font-weight: 700; line-height: 1.1; letter-spacing: 0.04em; }
    #mult-display {
      position: absolute;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }
    #mult-value {
      font-size: 20px;
      font-weight: 800;
      letter-spacing: 0.06em;
    }
    #how-to {
      width: 100%;
      max-width: 420px;
      padding: 0 12px 24px;
    }
    details {
      border-top: 1px solid rgba(255,255,255,0.08);
      margin-top: 8px;
    }
    summary {
      padding: 10px 4px;
      font-size: 12px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      opacity: 0.5;
      cursor: pointer;
      user-select: none;
      list-style: none;
    }
    summary::-webkit-details-marker { display: none; }
    summary::before { content: '▶  '; font-size: 9px; }
    details[open] summary::before { content: '▼  '; }
    .how-content {
      padding: 8px 4px 4px;
      font-size: 13px;
      line-height: 1.7;
      opacity: 0.6;
    }
    .how-content p { margin-bottom: 6px; }
    .how-content strong { color: #aaefff; }
  </style>
</head>
<body>
<div id="game-wrap">
  <div id="canvas-container">
    <canvas id="c"></canvas>
    <div id="ui-overlay">
      <div id="score-row">
        <div>
          <div class="ui-label">Score</div>
          <div class="ui-value" id="score-val">0</div>
        </div>
        <div id="mult-display">
          <div class="ui-label">Streak</div>
          <div id="mult-value">x1</div>
        </div>
        <div style="text-align:right">
          <div class="ui-label">Best</div>
          <div class="ui-value" id="best-val">0</div>
        </div>
      </div>
    </div>
  </div>
</div>
<div id="how-to">
  <details>
    <summary>How to Play</summary>
    <div class="how-content">
      <p><strong>Tap / Space / Enter</strong> to flip orbit direction (clockwise ↔ counterclockwise).</p>
      <p><strong>Energy Nodes</strong> (glowing dots on orbit path) give points. Collect them to build a streak multiplier up to <strong>×6</strong>. Missing a node resets the streak.</p>
      <p><strong>Hazard Gates</strong> (laser arcs) appear on one side of the orbit. A yellow telegraph shows which side is dangerous — flip to the safe side before it turns red and active.</p>
      <p>Avoid letting your <strong>head or tail</strong> touch an active gate. The coil trail grows longer as you collect nodes, increasing the challenge.</p>
      <p>Speed and gate frequency increase over time. Survive as long as possible for the highest score!</p>
    </div>
  </details>
</div>
<script>
(function(){
'use strict';

// ─── Constants ───────────────────────────────────────────────────────────────
const W = 420, H = 750;
const DPR = Math.min(window.devicePixelRatio || 1, 2);
const LS_KEY = 'neonCoil_best_v1';
const ORBIT_R = 80;
const CORE_R = 22;
const NODE_R = 10;
const HEAD_R = 7;
const TRAIL_SPACING = 12;
const BASE_SPEED = 90;      // px/s world units
const MAX_SPEED = 240;
const SPEED_RAMP = 10;      // per second increase cap
const BASE_ORBIT_SPD = 2.2; // rad/s
const TELEGRAPH_BASE = 1.8; // seconds
const TELEGRAPH_MIN = 0.7;
const ACTIVE_DURATION = 1.0;
const INITIAL_TRAIL = 5;    // segments
const MAX_TRAIL = 32;
const GATE_HALF_ARC = Math.PI * 0.52; // slightly more than half orbit

// ─── Canvas setup ────────────────────────────────────────────────────────────
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvas-container');

function resize() {
  const cw = Math.min(container.clientWidth, 420);
  const ch = Math.round(cw * (H / W));
  container.style.height = ch + 'px';
  canvas.width = Math.round(cw * DPR);
  canvas.height = Math.round(ch * DPR);
  canvas.style.width = cw + 'px';
  canvas.style.height = ch + 'px';
}
resize();
window.addEventListener('resize', resize);

function getScale() {
  return canvas.width / (W * DPR) * DPR;
}

// ─── Persistence ─────────────────────────────────────────────────────────────
let bestScore = parseInt(localStorage.getItem(LS_KEY) || '0', 10);
document.getElementById('best-val').textContent = bestScore;

// ─── State ───────────────────────────────────────────────────────────────────
const STATE = { START: 0, PLAYING: 1, GAMEOVER: 2 };
let state = STATE.START;

// ─── Game variables ──────────────────────────────────────────────────────────
let angle, dir, orbitSpeed;
let trailPos, trailLength;
let score, streak, mult;
let scrollY;          // accumulated scroll (world units, gates/nodes move down)
let elapsed;
let scrollSpeed;
let nodes, gates, particles;
let shakeAmt, shakeDecay;
let flashAlpha;
let hue;
let gatePattern, patternIdx;
let lastNodeY;        // for spacing
let lastGateY;
let peakMult;
let gameOverTimer;
let doubleGateAllowed;

// ─── Pattern generator ───────────────────────────────────────────────────────
function buildPattern(t) {
  // Mostly alternating, some repeats, double-gate after 20s
  const sides = [];
  let last = -1;
  for (let i = 0; i < 40; i++) {
    if (doubleGateAllowed && i > 0 && Math.random() < 0.18) {
      sides.push(last); // repeat (double gate)
    } else if (Math.random() < 0.15) {
      sides.push(last === -1 ? 0 : last); // occasional repeat
    } else {
      sides.push(last === 1 ? 0 : 1);
      last = sides[sides.length - 1];
    }
    last = sides[sides.length - 1];
  }
  return sides;
}

function initGame() {
  angle = -Math.PI / 2; // start at top
  dir = 1;
  orbitSpeed = BASE_ORBIT_SPD;
  trailPos = [];
  trailLength = INITIAL_TRAIL;
  score = 0;
  streak = 0;
  mult = 1;
  peakMult = 1;
  scrollY = 0;
  elapsed = 0;
  scrollSpeed = BASE_SPEED;
  nodes = [];
  gates = [];
  particles = [];
  shakeAmt = 0;
  shakeDecay = 0.85;
  flashAlpha = 0;
  hue = 180;
  lastNodeY = -200;
  lastGateY = -400;
  patternIdx = 0;
  doubleGateAllowed = false;
  gatePattern = buildPattern(0);

  // Seed initial nodes
  for (let i = 0; i < 3; i++) {
    spawnNode(-200 - i * 160);
  }
  // Seed initial gate
  spawnGate(-500);

  updateUI();
}

// ─── Spawning ────────────────────────────────────────────────────────────────
function spawnNode(y) {
  const side = Math.random() < 0.5 ? 0 : 1; // 0=left, 1=right
  const nx = W / 2 + (side === 0 ? -ORBIT_R : ORBIT_R);
  nodes.push({ x: nx, y: y, side: side, alive: true, scale: 1.0, pulseT: Math.random() * Math.PI * 2 });
  lastNodeY = y;
}

function spawnGate(y) {
  if (patternIdx >= gatePattern.length) {
    patternIdx = 0;
    gatePattern = buildPattern(elapsed);
  }
  const hazardSide = gatePattern[patternIdx++]; // 0=left hazardous, 1=right hazardous
  const tTelegraph = Math.max(TELEGRAPH_MIN, TELEGRAPH_BASE - elapsed * 0.018);
  gates.push({
    y: y,
    hazardSide: hazardSide,
    phase: 'telegraph', // telegraph -> active -> dead
    timer: tTelegraph,
    telegraphDur: tTelegraph,
    activeDur: ACTIVE_DURATION,
    alive: true
  });
  lastGateY = y;
}

// ─── Input ───────────────────────────────────────────────────────────────────
function onAction() {
  if (state === STATE.START) {
    state = STATE.PLAYING;
    initGame();
    return;
  }
  if (state === STATE.GAMEOVER) {
    if (gameOverTimer <= 0) {
      state = STATE.PLAYING;
      initGame();
    }
    return;
  }
  if (state === STATE.PLAYING) {
    dir *= -1;
  }
}

canvas.addEventListener('pointerdown', onAction);
document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); onAction(); }
});

// ─── UI ──────────────────────────────────────────────────────────────────────
function updateUI() {
  document.getElementById('score-val').textContent = score;
  document.getElementById('best-val').textContent = bestScore;
  const mv = document.getElementById('mult-value');
  mv.textContent = 'x' + mult;
  mv.style.color = mult >= 4 ? `hsl(${hue+40},100%,70%)` : mult >= 2 ? `hsl(${hue+20},90%,65%)` : `hsl(${hue},70%,60%)`;
}

// ─── Particles ───────────────────────────────────────────────────────────────
function spawnPickupParticles(x, y, h) {
  for (let i = 0; i < 14; i++) {
    const a = (i / 14) * Math.PI * 2;
    const sp = 60 + Math.random() * 100;
    particles.push({
      x, y,
      vx: Math.cos(a) * sp,
      vy: Math.sin(a) * sp,
      life: 0.6 + Math.random() * 0.3,
      maxLife: 0.9,
      r: 2 + Math.random() * 3,
      hue: h,
      type: 'spark'
    });
  }
}

function spawnDeathParticles(x, y) {
  for (let i = 0; i < 30; i++) {
    const a = Math.random() * Math.PI * 2;
    const sp = 40 + Math.random() * 180;
    particles.push({
      x, y,
      vx: Math.cos(a) * sp,
      vy: Math.sin(a) * sp,
      life: 0.8 + Math.random() * 0.6,
      maxLife: 1.4,
      r: 2 + Math.random() * 5,
      hue: Math.random() * 360,
      type: 'death'
    });
  }
}

function spawnGateParticles(gate) {
  const cx = W / 2, cy = gate.y;
  for (let i = 0; i < 12; i++) {
    const a = (gate.hazardSide === 0 ? Math.PI : 0) + (Math.random() - 0.5) * Math.PI;
    const r = ORBIT_R * (0.7 + Math.random() * 0.6);
    const px = cx + Math.cos(a) * r;
    const py = cy + Math.sin(a) * r;
    particles.push({
      x: px, y: py,
      vx: (Math.random() - 0.5) * 60,
      vy: (Math.random() - 0.5) * 60,
      life: 0.5,
      maxLife: 0.5,
      r: 1.5 + Math.random() * 2.5,
      hue: 0,
      type: 'gate'
    });
  }
}

// ─── Trail helpers ───────────────────────────────────────────────────────────
function getHeadPos() {
  return {
    x: W / 2 + Math.cos(angle) * ORBIT_R,
    y: H / 2 + Math.sin(angle) * ORBIT_R
  };
}

// ─── Collision helpers ───────────────────────────────────────────────────────
function segmentInGate(sx, sy, gate) {
  // Gate is active; hazardous arc on one side (left or right half of orbit circle)
  // Check: is this point near orbit ring AND within gate y-slice AND on hazard side?
  const cx = W / 2;
  const dy = sy - gate.y;
  if (Math.abs(dy) > 28) return false; // outside y-slice of gate
  const dx = sx - cx;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < ORBIT_R - 24 || dist > ORBIT_R + 24) return false; // outside orbit band
  // Side check
  if (gate.hazardSide === 0 && dx < 8) return true;  // left hazardous
  if (gate.hazardSide === 1 && dx > -8) return true;  // right hazardous
  return false;
}

// ─── Main loop ───────────────────────────────────────────────────────────────
let lastTime = 0;
function loop(ts) {
  requestAnimationFrame(loop);
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;

  if (state === STATE.PLAYING) update(dt);
  draw(dt);
}

function update(dt) {
  elapsed += dt;
  if (elapsed > 20) doubleGateAllowed = true;

  // Scroll speed
  scrollSpeed = Math.min(BASE_SPEED + elapsed * SPEED_RAMP, MAX_SPEED);
  const dScroll = scrollSpeed * dt;

  // Orbit speed increases with score
  orbitSpeed = BASE_ORBIT_SPD + score * 0.004;

  // Move angle
  angle += dir * orbitSpeed * dt;

  // Head position
  const head = getHeadPos();

  // Record trail
  trailPos.unshift({ x: head.x, y: head.y });
  // Keep enough history
  const maxHistory = trailLength * TRAIL_SPACING * 2.5;
  if (trailPos.length > maxHistory + 10) trailPos.length = Math.ceil(maxHistory + 10);

  // Color cycling
  hue = (hue + 28 * dt) % 360;

  // Shake decay
  shakeAmt *= shakeDecay;
  if (shakeAmt < 0.1) shakeAmt = 0;

  // Flash decay
  flashAlpha = Math.max(0, flashAlpha - dt * 3.5);

  // ── Move nodes down (scroll) ──
  for (let i = nodes.length - 1; i >= 0; i--) {
    const n = nodes[i];
    n.y += dScroll;
    n.pulseT += dt * 3;
    if (!n.alive) { n.scale -= dt * 4; if (n.scale <= 0) nodes.splice(i, 1); continue; }
    if (n.y > H + 20) {
      // Missed node — reset streak
      streak = 0;
      mult = 1;
      nodes.splice(i, 1);
      updateUI();
      continue;
    }
    // Collect check
    const dx = head.x - n.x, dy = head.y - n.y;
    if (dx * dx + dy * dy < (HEAD_R + NODE_R) * (HEAD_R + NODE_R)) {
      streak++;
      mult = Math.min(1 + Math.floor(streak / 5), 6);
      if (mult > peakMult) peakMult = mult;
      score += mult * 10;
      if (score > bestScore) { bestScore = score; localStorage.setItem(LS_KEY, bestScore); }
      trailLength = Math.min(trailLength + 1, MAX_TRAIL);
      spawnPickupParticles(n.x, n.y, hue);
      n.alive = false;
      updateUI();
    }
  }

  // Spawn new nodes
  const nodeGap = 140 + Math.max(0, 80 - elapsed * 1.5);
  if (nodes.length < 5) {
    const topNode = nodes.reduce((m, n) => n.y < m ? n.y : m, 9999);
    if (topNode > -(nodeGap * 0.5)) spawnNode(topNode - nodeGap - Math.random() * 40);
  }

  // ── Move gates down ──
  for (let i = gates.length - 1; i >= 0; i--) {
    const g = gates[i];
    g.y += dScroll;
    g.timer -= dt;
    if (g.phase === 'telegraph' && g.timer <= 0) {
      g.phase = 'active';
      g.timer = g.activeDur;
      spawnGateParticles(g);
    } else if (g.phase === 'active') {
      if (g.timer <= 0) { g.phase = 'dead'; gates.splice(i, 1); continue; }
      // Collision check against head and all trail segments
      let hit = false;
      if (segmentInGate(head.x, head.y, g)) hit = true;
      if (!hit) {
        // Sample trail
        let dist = 0;
        let prev = trailPos[0];
        for (let j = 1; j < trailPos.length && dist < trailLength * TRAIL_SPACING; j++) {
          const tp = trailPos[j];
          dist += Math.hypot(tp.x - prev.x, tp.y - prev.y);
          if (segmentInGate(tp.x, tp.y, g)) { hit = true; break; }
          prev = tp;
        }
      }
      if (hit) { die(head.x, head.y); return; }
    }
    if (g.y > H + 60) { gates.splice(i, 1); continue; }
  }

  // Spawn new gates
  const gateGap = 320 - Math.min(120, elapsed * 2.5);
  if (gates.length < 3) {
    const topGate = gates.reduce((m, g) => g.y < m ? g.y : m, 9999);
    if (topGate > -(gateGap * 0.5)) spawnGate(topGate - gateGap - Math.random() * 40);
  }

  // ── Particles ──
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt + dScroll; // scroll with world
    p.vx *= 0.92;
    p.vy *= 0.92;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function die(hx, hy) {
  spawnDeathParticles(hx, hy);
  shakeAmt = 18;
  flashAlpha = 1.0;
  state = STATE.GAMEOVER;
  gameOverTimer = 1.0;
  updateUI();
}

// ─── Draw ────────────────────────────────────────────────────────────────────
function draw(dt) {
  if (state === STATE.GAMEOVER) gameOverTimer = Math.max(0, gameOverTimer - dt);

  const s = canvas.width / W;
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Shake offset
  let sx = 0, sy = 0;
  if (shakeAmt > 0.5) {
    sx = (Math.random() - 0.5) * shakeAmt * s;
    sy = (Math.random() - 0.5) * shakeAmt * s;
  }

  ctx.setTransform(s, 0, 0, s, sx, sy);

  // ── Background ──
  ctx.fillStyle = '#05060a';
  ctx.fillRect(0, 0, W, H);
  drawGrid();

  if (state === STATE.START) {
    drawStartScreen();
    return;
  }

  drawParticles();
  drawNodes();
  drawGates();
  drawCore();
  drawTrail();
  drawHead();

  // Flash overlay
  if (flashAlpha > 0) {
    ctx.globalAlpha = flashAlpha * 0.75;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;
  }

  if (state === STATE.GAMEOVER) drawGameOver();
}

function drawGrid() {
  // Scrolling tunnel grid
  const lineColor = 'rgba(60,80,160,0.12)';
  const t = (scrollY % 60) / 60; // not used directly, use elapsed
  const offset = (elapsed * scrollSpeed * 0.2) % 60;
  ctx.strokeStyle = lineColor;
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  for (let y = -60 + offset % 60; y < H + 60; y += 60) {
    ctx.moveTo(0, y); ctx.lineTo(W, y);
  }
  for (let x = 0; x < W; x += 60) {
    ctx.moveTo(x, 0); ctx.lineTo(x, H);
  }
  ctx.stroke();
}

function drawCore() {
  const cx = W / 2, cy = H / 2;
  // Outer glow
  const g1 = ctx.createRadialGradient(cx, cy, 0, cx, cy, CORE_R * 2.4);
  g1.addColorStop(0, `hsla(${hue},100%,70%,0.25)`);
  g1.addColorStop(1, 'transparent');
  ctx.fillStyle = g1;
  ctx.beginPath();
  ctx.arc(cx, cy, CORE_R * 2.4, 0, Math.PI * 2);
  ctx.fill();
  // Core
  const g2 = ctx.createRadialGradient(cx, cy, 0, cx, cy, CORE_R);
  g2.addColorStop(0, `hsl(${hue},100%,90%)`);
  g2.addColorStop(0.5, `hsl(${hue},100%,65%)`);
  g2.addColorStop(1, `hsl(${hue+30},80%,40%)`);
  ctx.fillStyle = g2;
  ctx.beginPath();
  ctx.arc(cx, cy, CORE_R, 0, Math.PI * 2);
  ctx.fill();
  // Orbit ring
  ctx.strokeStyle = `hsla(${hue},70%,60%,0.18)`;
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(cx, cy, ORBIT_R, 0, Math.PI * 2);
  ctx.stroke();
}

function drawTrail() {
  if (trailPos.length < 2) return;
  const segCount = Math.floor(trailLength);
  let dist = 0;
  let prev = trailPos[0];
  let segs = [trailPos[0]];
  for (let i = 1; i < trailPos.length; i++) {
    const p = trailPos[i];
    const d = Math.hypot(p.x - prev.x, p.y - prev.y);
    dist += d;
    if (dist > TRAIL_SPACING * segs.length) segs.push(p);
    if (segs.length >= segCount + 2) break;
    prev = p;
  }
  for (let i = 1; i < segs.length; i++) {
    const t = 1 - i / segs.length;
    const h = (hue + i * 4) % 360;
    const alpha = t * 0.85;
    const r = HEAD_R * (0.3 + t * 0.7);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = `hsl(${h},100%,65%)`;
    ctx.shadowColor = `hsl(${h},100%,70%)`;
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(segs[i].x, segs[i].y, r, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

function drawHead() {
  const h = getHeadPos();
  // Glow
  ctx.shadowColor = `hsl(${hue},100%,80%)`;
  ctx.shadowBlur = 18;
  ctx.fillStyle = `hsl(${hue},100%,80%)`;
  ctx.beginPath();
  ctx.arc(h.x, h.y, HEAD_R, 0, Math.PI * 2);
  ctx.fill();
  // Inner bright
  ctx.shadowBlur = 6;
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.arc(h.x, h.y, HEAD_R * 0.45, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
}

function drawNodes() {
  for (const n of nodes) {
    if (!n.alive && n.scale <= 0) continue;
    const sc = n.alive ? 1 : n.scale;
    const pulse = 0.85 + Math.sin(n.pulseT) * 0.15;
    const r = NODE_R * pulse * sc;
    const nh = (hue + 120) % 360;
    // Glow ring
    ctx.strokeStyle = `hsla(${nh},100%,70%,${0.5 * sc})`;
    ctx.lineWidth = 2;
    ctx.shadowColor = `hsl(${nh},100%,70%)`;
    ctx.shadowBlur = 14;
    ctx.beginPath();
    ctx.arc(n.x, n.y, r + 4, 0, Math.PI * 2);
    ctx.stroke();
    // Fill
    const g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, r);
    g.addColorStop(0, `hsl(${nh},100%,90%)`);
    g.addColorStop(1, `hsl(${nh+30},80%,55%)`);
    ctx.fillStyle = g;
    ctx.globalAlpha = sc;
    ctx.beginPath();
    ctx.arc(n.x, n.y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
  }
}

function drawGates() {
  for (const g of gates) {
    const cx = W / 2, cy = g.y;
    const progress = g.phase === 'telegraph'
      ? 1 - g.timer / g.telegraphDur
      : 1;

    // Arc spans hazardous half
    const startA = g.hazardSide === 0 ? Math.PI * 0.5 : -Math.PI * 0.5;
    const endA = startA + Math.PI;

    if (g.phase === 'telegraph') {
      // Yellow warning arc, grows from nothing
      const arcSpan = GATE_HALF_ARC * 2 * progress;
      ctx.strokeStyle = `hsla(50,100%,60%,${0.4 + 0.4 * progress})`;
      ctx.lineWidth = 3 + 2 * progress;
      ctx.shadowColor = 'hsla(50,100%,70%,0.7)';
      ctx.shadowBlur = 12;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.arc(cx, cy, ORBIT_R, startA - arcSpan / 2 + Math.PI * 0.5, startA + arcSpan / 2 + Math.PI * 0.5);
      ctx.stroke();
      // Warning icon on hazard side
      const ix = cx + (g.hazardSide === 0 ? -ORBIT_R * 1.5 : ORBIT_R * 1.5);
      ctx.globalAlpha = progress;
      ctx.fillStyle = `hsla(50,100%,60%,0.8)`;
      ctx.font = 'bold 13px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('⚡', ix, cy);
      ctx.globalAlpha = 1;
    } else {
      // Active: red/orange laser arc
      const flash = 0.7 + 0.3 * Math.sin(elapsed * 20);
      ctx.strokeStyle = `hsla(5,100%,55%,${flash})`;
      ctx.lineWidth = 5;
      ctx.shadowColor = 'hsla(0,100%,60%,0.9)';
      ctx.shadowBlur = 22;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.arc(cx, cy, ORBIT_R, startA + Math.PI * 0.5 - GATE_HALF_ARC, startA + Math.PI * 0.5 + GATE_HALF_ARC);
      ctx.stroke();
      // Danger cross-hatch lines
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = '#ff3030';
      ctx.lineWidth = 1;
      ctx.shadowBlur = 0;
      const sign = g.hazardSide === 0 ? -1 : 1;
      for (let xi = 0; xi < 3; xi++) {
        const lx = cx + sign * (ORBIT_R * 0.3 + xi * 20);
        ctx.beginPath();
        ctx.moveTo(lx - 14, cy - 22);
        ctx.lineTo(lx + 14, cy + 22);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }
    ctx.shadowBlur = 0;
  }
}

function drawParticles() {
  for (const p of particles) {
    const t = p.life / p.maxLife;
    ctx.globalAlpha = t * (p.type === 'death' ? 0.9 : 0.8);
    if (p.type === 'gate') {
      ctx.fillStyle = `hsl(10,100%,60%)`;
    } else if (p.type === 'death') {
      ctx.fillStyle = `hsl(${p.hue},100%,65%)`;
    } else {
      ctx.fillStyle = `hsl(${p.hue+120},100%,70%)`;
    }
    ctx.shadowColor = ctx.fillStyle;
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * (0.3 + t * 0.7), 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

function drawStartScreen() {
  // Draw core and orbit ring on start too
  drawCore();

  // Animated coil preview
  const previewAngle = (Date.now() / 800) % (Math.PI * 2);
  const hx = W / 2 + Math.cos(previewAngle) * ORBIT_R;
  const hy = H / 2 + Math.sin(previewAngle) * ORBIT_R;
  ctx.shadowColor = `hsl(${hue},100%,80%)`;
  ctx.shadowBlur = 18;
  ctx.fillStyle = `hsl(${hue},100%,80%)`;
  ctx.beginPath();
  ctx.arc(hx, hy, HEAD_R, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Title
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  ctx.shadowColor = `hsl(${hue},100%,60%)`;
  ctx.shadowBlur = 30;
  ctx.fillStyle = `hsl(${hue},100%,80%)`;
  ctx.font = 'bold 52px system-ui';
  ctx.fillText('NEON', W / 2, H * 0.28);
  ctx.fillStyle = `hsl(${(hue + 60) % 360},100%,80%)`;
  ctx.font = 'bold 52px system-ui';
  ctx.fillText('COIL', W / 2, H * 0.28 + 56);
  ctx.shadowBlur = 0;

  ctx.fillStyle = 'rgba(200,200,255,0.55)';
  ctx.font = '15px system-ui';
  ctx.fillText('Orbit. Collect. Survive.', W / 2, H * 0.28 + 110);

  // Tap to start pulse
  const pulse = 0.65 + 0.35 * Math.sin(Date.now() / 400);
  ctx.globalAlpha = pulse;
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 18px system-ui';
  ctx.fillText('TAP TO START', W / 2, H * 0.72);
  ctx.globalAlpha = 1;

  // Controls hint
  ctx.fillStyle = 'rgba(150,150,200,0.45)';
  ctx.font = '13px system-ui';
  ctx.fillText('Tap / Space / Enter to flip orbit', W / 2, H * 0.72 + 30);
}

function drawGameOver() {
  // Semi-transparent overlay
  ctx.fillStyle = 'rgba(5,6,10,0.72)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  ctx.shadowColor = '#ff3060';
  ctx.shadowBlur = 25;
  ctx.fillStyle = '#ff5080';
  ctx.font = 'bold 44px system-ui';
  ctx.fillText('GAME OVER', W / 2, H * 0.32);
  ctx.shadowBlur = 0;

  ctx.fillStyle = 'rgba(200,200,255,0.7)';
  ctx.font = '16px system-ui';
  ctx.fillText('Score', W / 2, H * 0.44);
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 42px system-ui';
  ctx.fillText(score, W / 2, H * 0.44 + 48);

  ctx.fillStyle = 'rgba(180,180,255,0.5)';
  ctx.font = '14px system-ui';
  ctx.fillText('Best: ' + bestScore, W / 2, H * 0.44 + 96);

  if (peakMult > 1) {
    ctx.fillStyle = `hsl(${hue+40},100%,65%)`;
    ctx.font = '14px system-ui';
    ctx.fillText('Peak Multiplier: ×' + peakMult, W / 2, H * 0.44 + 118);
  }

  if (gameOverTimer <= 0) {
    const pulse = 0.65 + 0.35 * Math.sin(Date.now() / 400);
    ctx.globalAlpha = pulse;
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 18px system-ui';
    ctx.fillText('TAP TO RETRY', W / 2, H * 0.72);
    ctx.globalAlpha = 1;
  }
}

// ─── Start ───────────────────────────────────────────────────────────────────
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
