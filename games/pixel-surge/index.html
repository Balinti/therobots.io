<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Pixel Surge - Free HTML5 Game</title>
<meta name="description" content="Play Pixel Surge - Swipe to avoid crashing drones and grab sporadic energy boosts in a pixelated cyber world.">
<meta name="theme-color" content="#0a0a1a">
<meta property="og:title" content="Pixel Surge - Free HTML5 Game">
<meta property="og:description" content="Play Pixel Surge - Swipe to avoid crashing drones and grab sporadic energy boosts in a pixelated cyber world.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://balinti.github.io/pixel-surge/">
<meta property="og:image" content="https://balinti.github.io/pixel-surge/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Pixel Surge - Free HTML5 Game">
<meta name="twitter:description" content="Play Pixel Surge - Swipe to avoid crashing drones and grab sporadic energy boosts in a pixelated cyber world.">
<meta name="twitter:image" content="https://balinti.github.io/pixel-surge/og-image.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#e0e0e0;touch-action:none;user-select:none;-webkit-user-select:none}
#app{position:relative;width:100%;max-width:420px;height:100%;max-height:750px;margin:0 auto;display:flex;flex-direction:column;overflow:hidden}
@media(min-height:751px){#app{top:50%;transform:translateY(-50%)}}
#topbar{height:0;flex-shrink:0}
#frame{position:relative;flex:1;min-height:0;overflow:hidden}
#gameCanvas{display:block;width:100%;height:100%;background:#0a0a1a}
#bottombar{height:0;flex-shrink:0}
#overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:10;background:rgba(6,6,20,0.82);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);transition:opacity .3s}
#overlay.hidden{opacity:0;pointer-events:none}
.panel{text-align:center;padding:28px 22px;max-width:340px;width:90%}
.panel h1{font-size:2rem;font-weight:800;letter-spacing:2px;margin-bottom:4px;background:linear-gradient(135deg,#00f0ff,#ff00e6);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;text-transform:uppercase}
.panel .sub{font-size:.82rem;color:#8af;margin-bottom:18px}
.panel .challenge{font-size:.78rem;color:#f0a;margin-bottom:10px}
.panel .score-big{font-size:2.6rem;font-weight:900;color:#fff;margin:8px 0 2px}
.panel .best-text{font-size:.85rem;color:#8af;margin-bottom:6px}
.panel .recap{font-size:.75rem;color:#889;margin-bottom:16px;line-height:1.6}
.btn-primary{display:inline-block;padding:14px 38px;font-size:1.05rem;font-weight:700;color:#fff;background:linear-gradient(135deg,#00c8ff,#a020f0);border:none;border-radius:30px;cursor:pointer;letter-spacing:1px;transition:transform .15s,box-shadow .15s;box-shadow:0 0 20px rgba(0,200,255,.3)}
.btn-primary:active{transform:scale(.95)}
.btn-share{display:inline-block;margin-top:10px;padding:8px 22px;font-size:.82rem;font-weight:600;color:#aef;background:rgba(0,200,255,.12);border:1px solid rgba(0,200,255,.3);border-radius:18px;cursor:pointer;transition:background .15s}
.btn-share:active{background:rgba(0,200,255,.25)}
#muteBtn{position:absolute;top:10px;right:10px;z-index:20;width:36px;height:36px;border-radius:50%;border:1px solid rgba(255,255,255,.2);background:rgba(0,0,0,.4);color:#aaa;font-size:1rem;cursor:pointer;display:flex;align-items:center;justify-content:center;line-height:1}
#muteBtn:active{background:rgba(255,255,255,.1)}
#privacyModal{position:fixed;inset:0;z-index:100;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.8)}
#privacyModal.show{display:flex}
#privacyModal .modal-inner{background:#111;border:1px solid #333;border-radius:12px;padding:24px;max-width:360px;width:90%;max-height:80vh;overflow-y:auto;font-size:.82rem;line-height:1.6;color:#bbb}
#privacyModal .modal-inner h2{color:#fff;margin-bottom:10px;font-size:1.1rem}
#privacyModal .close-modal{margin-top:14px;padding:8px 20px;background:#222;border:1px solid #444;color:#ddd;border-radius:8px;cursor:pointer;font-size:.82rem}
#about-section{max-width:420px;margin:0 auto;padding:10px 16px 30px;background:#0a0a1a;color:#889}
#about-section summary{cursor:pointer;font-size:.85rem;color:#8af;padding:6px 0}
#about-section .about-content{font-size:.78rem;line-height:1.7;padding-top:8px}
#about-section .about-content h2{font-size:.92rem;color:#ccc;margin:10px 0 4px}
#about-section .about-content p{margin-bottom:8px}
#about-section .about-content a{color:#8af;text-decoration:underline;cursor:pointer}
</style>
</head>
<body>
<div id="app">
<div id="topbar"></div>
<div id="frame">
<canvas id="gameCanvas"></canvas>
<button id="muteBtn" aria-label="Toggle sound">&#x1f50a;</button>
<div id="overlay">
<div class="panel" id="panelContent"></div>
</div>
</div>
<div id="bottombar"></div>
</div>

<div id="privacyModal">
<div class="modal-inner">
<h2>Privacy Policy</h2>
<p>This game stores your high score locally on your device using localStorage. No personal data is collected or transmitted to any server.</p>
<p>Third-party advertising (Google AdSense) may use cookies to serve ads. For more info visit <em>google.com/policies/privacy</em>.</p>
<p>This game does not require any account or login.</p>
<button class="close-modal" onclick="document.getElementById('privacyModal').classList.remove('show')">Close</button>
</div>
</div>

<section id="about-section">
<details>
<summary>About / How to Play</summary>
<div class="about-content">
<h2>Pixel Surge: Overclock Lane</h2>
<p>Pixel Surge is a free hyper-casual HTML5 game. Navigate three neon lanes while dodging descending drones in a stylish cyberpunk pixel world.</p>
<h2>How to Play</h2>
<p><strong>Controls:</strong> Tap the screen, or press Space/Enter to cycle lanes: Left &rarr; Mid &rarr; Right &rarr; Left.</p>
<p><strong>Near-miss:</strong> Pass close to a drone's danger ring for bonus points and Overclock charge. Risk vs reward!</p>
<p><strong>Overclock:</strong> When your charge bar fills, Overclock triggers automatically for 2 seconds &mdash; time slows, your multiplier ramps up, and your hit window widens.</p>
<p><strong>Overheat:</strong> Switching lanes too fast builds heat. If you overheat, controls lock for 0.6 seconds. Watch the heat bar!</p>
<p>No random boosts. Pure skill &amp; pattern reading.</p>
<h2>Links</h2>
<p><a onclick="document.getElementById('privacyModal').classList.add('show')">Privacy Policy</a></p>
</div>
</details>
</section>

<script>
'use strict';
(()=>{
/* ===== CONSTANTS ===== */
const LANE_X = [0.22, 0.50, 0.78];
const PLAYER_Y_FRAC = 0.82;
const PLAYER_R = 12;
const DRONE_R = 14;
const DANGER_RING_R = 32;
const NEAR_MISS_BAND = 6;
const MAX_PARTICLES = 600;
const MAX_POP_TEXTS = 40;
const OVERCLOCK_DURATION = 2;
const OVERCLOCK_TIME_SCALE = 0.55;
const OVERCLOCK_MAX_MULT = 3.5;
const OVERHEAT_PER_SWITCH = 0.18;
const OVERHEAT_COOL_RATE = 0.11;
const OVERHEAT_LOCKOUT_TIME = 0.6;
const OVERHEAT_RESET_VAL = 0.72;
const OC_PASSIVE_RATE = 0.06;
const OC_NEAR_MISS_BOOST = 0.22;
const SCORE_PER_SEC = 100;
const NEAR_MISS_SCORE = 120;
const LS_KEY = 'ps_best';

/* ===== DOM ===== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const panelContent = document.getElementById('panelContent');
const muteBtn = document.getElementById('muteBtn');

/* ===== STATE ===== */
let W, H, dpr;
let state = 'start'; // start | playing | gameover
let score, bestScore, multiplier, maxMult;
let playerLane, playerX, playerTargetX;
let overheat, overheatLocked, lockTimer;
let overclock, overclockActive, overclockTimer, overclockEase;
let timeScale, speedMul, spawnInterval, spawnTimer, gameTime;
let nearMissCount, lockoutCount;
let shakeX, shakeY, shakeMag;
let zoomFactor;
let bgHue;
let muted = false;
let challengeScore = 0;

/* ===== POOLS ===== */
const drones = [];
const particles = [];
const popTexts = [];
let particleIdx = 0;
let popIdx = 0;

// Pre-allocate particle pool
for(let i=0;i<MAX_PARTICLES;i++) particles.push({alive:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:1,size:2,r:255,g:255,b:255});
for(let i=0;i<MAX_POP_TEXTS;i++) popTexts.push({alive:false,x:0,y:0,vy:0,text:'',life:0,maxLife:1,r:255,g:255,b:255});

/* ===== DRONE PATTERNS ===== */
// Deterministic pattern chunks: each is an array of lane indices
const PATTERNS = [
  [1,0,2,1,0,2],
  [0,2,0,2,1,1],
  [2,1,0,0,1,2],
  [1,1,0,2,2,0],
  [0,0,2,1,1,2],
  [2,0,1,2,0,1],
  [1,2,0,1,0,2],
  [0,1,2,2,1,0],
  [2,2,1,0,0,1],
  [1,0,0,2,1,2]
];
let patternIdx = 0;
let patternStep = 0;
let currentPattern = PATTERNS[0];

function nextDroneLane(){
  const lane = currentPattern[patternStep];
  patternStep++;
  if(patternStep >= currentPattern.length){
    patternStep = 0;
    patternIdx = (patternIdx + 1) % PATTERNS.length;
    currentPattern = PATTERNS[patternIdx];
  }
  return lane;
}

/* ===== AUDIO (simple synth beeps) ===== */
let audioCtx = null;
function initAudio(){
  if(!audioCtx){
    try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){}
  }
}
function beep(freq, dur, vol, type){
  if(muted || !audioCtx) return;
  try{
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type || 'square';
    o.frequency.value = freq;
    g.gain.value = vol || 0.08;
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    o.connect(g);
    g.connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + dur);
  }catch(e){}
}
function sndSwitch(){ beep(520, 0.06, 0.06, 'square'); }
function sndNearMiss(){ beep(880, 0.12, 0.08, 'sine'); beep(1100, 0.08, 0.05, 'sine'); }
function sndCrash(){ beep(120, 0.3, 0.12, 'sawtooth'); beep(80, 0.4, 0.1, 'square'); }
function sndOverclock(){ beep(660, 0.15, 0.07, 'sine'); beep(990, 0.2, 0.06, 'sine'); beep(1320, 0.25, 0.05, 'sine'); }
function sndOverheat(){ beep(200, 0.2, 0.1, 'sawtooth'); }

muteBtn.addEventListener('click', (e)=>{
  e.stopPropagation();
  muted = !muted;
  muteBtn.textContent = muted ? '\u{1F507}' : '\u{1F50A}';
});

/* ===== RESIZE ===== */
function resize(){
  const rect = canvas.parentElement.getBoundingClientRect();
  dpr = Math.min(window.devicePixelRatio || 1, 3);
  W = rect.width;
  H = rect.height;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
}
window.addEventListener('resize', resize);
resize();

/* ===== CHALLENGE SCORE FROM URL ===== */
(()=>{
  try{
    const p = new URLSearchParams(window.location.search);
    const cs = parseInt(p.get('score'),10);
    if(cs > 0) challengeScore = cs;
  }catch(e){}
})();

/* ===== HELPERS ===== */
function clamp(v, mn, mx){ return v < mn ? mn : v > mx ? mx : v; }
function lerp(a, b, t){ return a + (b - a) * t; }
function easeOutQuad(t){ return t * (2 - t); }
function rand(a, b){ return a + Math.random() * (b - a); }

function spawnParticle(x, y, vx, vy, life, size, r, g, b){
  const p = particles[particleIdx % MAX_PARTICLES];
  particleIdx++;
  p.alive = true; p.x = x; p.y = y;
  p.vx = vx; p.vy = vy;
  p.life = life; p.maxLife = life;
  p.size = size; p.r = r; p.g = g; p.b = b;
}
function spawnPopText(x, y, text, r, g, b){
  const p = popTexts[popIdx % MAX_POP_TEXTS];
  popIdx++;
  p.alive = true; p.x = x; p.y = y; p.vy = -60;
  p.text = text; p.life = 0.8; p.maxLife = 0.8;
  p.r = r; p.g = g; p.b = b;
}

/* ===== GAME INIT ===== */
function initGame(){
  score = 0;
  multiplier = 1;
  maxMult = 1;
  playerLane = 1;
  playerX = LANE_X[1] * W;
  playerTargetX = playerX;
  overheat = 0;
  overheatLocked = false;
  lockTimer = 0;
  overclock = 0;
  overclockActive = false;
  overclockTimer = 0;
  overclockEase = 0;
  timeScale = 1;
  speedMul = 1;
  spawnInterval = 0.95;
  spawnTimer = 0.5;
  gameTime = 0;
  nearMissCount = 0;
  lockoutCount = 0;
  shakeX = 0; shakeY = 0; shakeMag = 0;
  zoomFactor = 1;
  bgHue = 240;
  drones.length = 0;
  patternIdx = 0;
  patternStep = 0;
  currentPattern = PATTERNS[0];
  for(let i=0;i<MAX_PARTICLES;i++) particles[i].alive = false;
  for(let i=0;i<MAX_POP_TEXTS;i++) popTexts[i].alive = false;
}

function loadBest(){
  try{ bestScore = parseInt(localStorage.getItem(LS_KEY),10) || 0; }catch(e){ bestScore = 0; }
}
function saveBest(){
  if(score > bestScore){ bestScore = score; try{ localStorage.setItem(LS_KEY, bestScore); }catch(e){} }
}

/* ===== INPUT ===== */
function handleInput(){
  if(state === 'start'){
    initAudio();
    initGame();
    state = 'playing';
    overlay.classList.add('hidden');
    return;
  }
  if(state === 'gameover'){
    initGame();
    state = 'playing';
    overlay.classList.add('hidden');
    return;
  }
  if(state === 'playing'){
    if(overheatLocked) return;
    initAudio();
    playerLane = (playerLane + 1) % 3;
    playerTargetX = LANE_X[playerLane] * W;
    overheat = Math.min(1, overheat + OVERHEAT_PER_SWITCH);
    if(overheat >= 1 && !overheatLocked){
      overheatLocked = true;
      lockTimer = OVERHEAT_LOCKOUT_TIME;
      lockoutCount++;
      sndOverheat();
      shakeMag = Math.max(shakeMag, 4);
    } else {
      sndSwitch();
    }
  }
}

canvas.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  handleInput();
});
document.addEventListener('keydown', (e)=>{
  if(e.code === 'Space' || e.code === 'Enter'){
    e.preventDefault();
    handleInput();
  }
});

/* ===== OVERLAYS ===== */
function showStart(){
  let html = '<h1>Pixel Surge</h1><p class="sub">Overclock Lane</p>';
  if(challengeScore > 0) html += `<p class="challenge">Challenge: beat ${challengeScore}!</p>`;
  loadBest();
  if(bestScore > 0) html += `<p class="best-text">Best: ${bestScore}</p>`;
  html += '<br><button class="btn-primary" id="startBtn">Tap to Start</button>';
  panelContent.innerHTML = html;
  overlay.classList.remove('hidden');
  document.getElementById('startBtn').addEventListener('pointerdown', (e)=>{ e.stopPropagation(); handleInput(); });
  document.getElementById('startBtn').addEventListener('click', (e)=>{ e.stopPropagation(); });
}

function showGameOver(){
  saveBest();
  const s = Math.floor(score);
  const isNew = s >= bestScore && s > 0;
  let html = `<h1>Game Over</h1>`;
  html += `<div class="score-big">${s}</div>`;
  html += `<p class="best-text">${isNew ? 'NEW BEST!' : 'Best: ' + bestScore}</p>`;
  html += `<p class="recap">Near-misses: ${nearMissCount} &bull; Max multiplier: x${maxMult.toFixed(1)} &bull; Lockouts: ${lockoutCount}</p>`;
  html += `<button class="btn-primary" id="retryBtn">Tap to Retry</button><br>`;
  html += `<button class="btn-share" id="shareBtn">Share Score</button>`;
  panelContent.innerHTML = html;
  overlay.classList.remove('hidden');
  document.getElementById('retryBtn').addEventListener('pointerdown', (e)=>{ e.stopPropagation(); handleInput(); });
  document.getElementById('retryBtn').addEventListener('click', (e)=>{ e.stopPropagation(); });
  document.getElementById('shareBtn').addEventListener('click', (e)=>{ e.stopPropagation(); shareScore(s); });
}

function shareScore(s){
  const url = window.location.origin + window.location.pathname + '?ref=share&score=' + s;
  const text = `I scored ${s} in Pixel Surge! Can you beat me?`;
  if(navigator.share){
    navigator.share({title:'Pixel Surge', text, url}).catch(()=>{});
  } else {
    navigator.clipboard.writeText(text + ' ' + url).then(()=>{
      const btn = document.getElementById('shareBtn');
      if(btn){ btn.textContent = 'Link copied!'; setTimeout(()=>{ btn.textContent = 'Share Score'; }, 2000); }
    }).catch(()=>{});
  }
}

/* ===== GAME OVER ===== */
function triggerGameOver(){
  state = 'gameover';
  sndCrash();
  shakeMag = 12;
  // crash burst particles
  const px = playerX, py = PLAYER_Y_FRAC * H;
  for(let i=0;i<60;i++){
    const a = rand(0, Math.PI*2), sp = rand(60, 250);
    spawnParticle(px, py, Math.cos(a)*sp, Math.sin(a)*sp, rand(0.4,1), rand(2,5), 255, rand(60,160), 0);
  }
  showGameOver();
}

/* ===== UPDATE ===== */
function update(dt){
  if(state !== 'playing') return;

  const rawDt = dt;
  // Overclock time scale
  if(overclockActive) timeScale = OVERCLOCK_TIME_SCALE;
  else timeScale = 1;
  const gdt = dt * timeScale;

  gameTime += gdt;

  // Difficulty
  const t = gameTime;
  speedMul = 1 + 0.012 * t + 0.00018 * t * t;
  spawnInterval = clamp(0.95 - 0.0065 * t, 0.34, 0.95);

  // Overheat
  if(overheatLocked){
    lockTimer -= rawDt;
    if(lockTimer <= 0){
      overheatLocked = false;
      overheat = OVERHEAT_RESET_VAL;
    }
  } else {
    overheat = Math.max(0, overheat - OVERHEAT_COOL_RATE * rawDt);
  }

  // Overclock charge
  if(!overclockActive){
    overclock = Math.min(1, overclock + OC_PASSIVE_RATE * gdt);
    if(overclock >= 1){
      overclockActive = true;
      overclockTimer = OVERCLOCK_DURATION;
      overclockEase = 0;
      sndOverclock();
      shakeMag = Math.max(shakeMag, 3);
      zoomFactor = 1.03;
      // pulse particles
      const px = playerX, py = PLAYER_Y_FRAC * H;
      for(let i=0;i<30;i++){
        const a = rand(0, Math.PI*2), sp = rand(80, 200);
        spawnParticle(px, py, Math.cos(a)*sp, Math.sin(a)*sp, rand(0.3,0.7), rand(2,4), 0, 200, 255);
      }
    }
  } else {
    overclockTimer -= rawDt;
    overclockEase = clamp(1 - overclockTimer / OVERCLOCK_DURATION, 0, 1);
    multiplier = 1 + (OVERCLOCK_MAX_MULT - 1) * easeOutQuad(overclockEase);
    maxMult = Math.max(maxMult, multiplier);
    // trail particles during overclock
    if(Math.random() < 0.6){
      const px = playerX, py = PLAYER_Y_FRAC * H;
      spawnParticle(px + rand(-6,6), py + rand(4,14), rand(-20,20), rand(40,100), rand(0.2,0.5), rand(1,3), 0, rand(180,255), 255);
    }
    if(overclockTimer <= 0){
      overclockActive = false;
      overclock = 0;
      multiplier = 1;
      zoomFactor = 1;
    }
  }

  // Player position ease
  playerX = lerp(playerX, playerTargetX, Math.min(1, 18 * rawDt));

  // Spawn drones
  spawnTimer -= gdt;
  if(spawnTimer <= 0){
    spawnTimer += spawnInterval;
    const lane = nextDroneLane();
    drones.push({
      x: LANE_X[lane] * W,
      y: -30,
      lane,
      speed: (200 + 60 * speedMul) * (0.9 + Math.random() * 0.2),
      nearMissed: false,
      passed: false
    });
  }

  // Update drones
  const py = PLAYER_Y_FRAC * H;
  const forgiveness = overclockActive ? 1.35 : 1;
  for(let i = drones.length - 1; i >= 0; i--){
    const d = drones[i];
    d.y += d.speed * gdt;
    // Remove off-screen
    if(d.y > H + 50){ drones.splice(i, 1); continue; }

    const dx = d.x - playerX;
    const dy = d.y - py;
    const dist = Math.sqrt(dx*dx + dy*dy);

    // Collision
    const hitR = (PLAYER_R + DRONE_R - 4) / forgiveness;
    if(dist < hitR){
      triggerGameOver();
      return;
    }

    // Near-miss: drone crosses player y band & within danger ring
    if(!d.nearMissed && !d.passed && d.y >= py - NEAR_MISS_BAND && d.y <= py + NEAR_MISS_BAND){
      if(dist < DANGER_RING_R + PLAYER_R && dist >= hitR){
        d.nearMissed = true;
        nearMissCount++;
        const bonus = Math.floor(NEAR_MISS_SCORE * multiplier);
        score += bonus;
        overclock = Math.min(1, overclock + OC_NEAR_MISS_BOOST);
        sndNearMiss();
        shakeMag = Math.max(shakeMag, 2);
        spawnPopText(playerX, py - 20, '+' + bonus, 0, 255, 200);
        // sparks
        for(let j=0;j<15;j++){
          const a = rand(0, Math.PI*2), sp = rand(50, 160);
          spawnParticle(playerX, py, Math.cos(a)*sp, Math.sin(a)*sp, rand(0.2,0.5), rand(1,3), 0, 255, rand(150,255));
        }
      }
    }
    if(d.y > py + 20) d.passed = true;
  }

  // Score
  score += SCORE_PER_SEC * multiplier * gdt;

  // Screen shake decay
  shakeMag *= Math.pow(0.02, rawDt);
  if(shakeMag < 0.1) shakeMag = 0;
  shakeX = (Math.random() - 0.5) * 2 * shakeMag;
  shakeY = (Math.random() - 0.5) * 2 * shakeMag;

  // Overclock rumble
  if(overclockActive){
    shakeX += (Math.random() - 0.5) * 1.2;
    shakeY += (Math.random() - 0.5) * 1.2;
  }

  // Zoom decay
  zoomFactor = lerp(zoomFactor, 1, Math.min(1, 3 * rawDt));

  // BG hue cycle
  bgHue = (bgHue + 8 * gdt) % 360;

  // Update particles
  for(let i=0;i<MAX_PARTICLES;i++){
    const p = particles[i];
    if(!p.alive) continue;
    p.life -= rawDt;
    if(p.life <= 0){ p.alive = false; continue; }
    p.x += p.vx * rawDt;
    p.y += p.vy * rawDt;
    p.vx *= 0.96;
    p.vy *= 0.96;
  }
  // Pop texts
  for(let i=0;i<MAX_POP_TEXTS;i++){
    const p = popTexts[i];
    if(!p.alive) continue;
    p.life -= rawDt;
    if(p.life <= 0){ p.alive = false; continue; }
    p.y += p.vy * rawDt;
    p.vy *= 0.95;
  }
}

/* ===== DRAW ===== */
function draw(){
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.clearRect(0, 0, W, H);

  // Save for shake/zoom
  ctx.save();
  if(state === 'playing' || state === 'gameover'){
    const cx = W/2, cy = H/2;
    ctx.translate(cx + shakeX, cy + shakeY);
    ctx.scale(zoomFactor, zoomFactor);
    ctx.translate(-cx, -cy);
  }

  // BG gradient
  const bg1 = `hsl(${bgHue}, 30%, 6%)`;
  const bg2 = `hsl(${(bgHue + 40) % 360}, 40%, 10%)`;
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, bg1);
  grad.addColorStop(1, bg2);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  if(state === 'playing' || state === 'gameover'){
    // Lane lines
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    for(let i=0;i<3;i++){
      const lx = LANE_X[i] * W;
      ctx.beginPath();
      ctx.moveTo(lx, 0);
      ctx.lineTo(lx, H);
      ctx.stroke();
    }

    // Road lines (scrolling dashes)
    const dashOffset = (gameTime * 180) % 40;
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.lineWidth = 1;
    ctx.setLineDash([12, 28]);
    const laneEdges = [0.36, 0.64];
    for(const frac of laneEdges){
      const lx = frac * W;
      ctx.beginPath();
      ctx.lineDashOffset = -dashOffset;
      ctx.moveTo(lx, 0);
      ctx.lineTo(lx, H);
      ctx.stroke();
    }
    ctx.setLineDash([]);

    // Drones
    for(const d of drones){
      // Danger ring
      ctx.beginPath();
      ctx.arc(d.x, d.y, DANGER_RING_R, 0, Math.PI*2);
      ctx.strokeStyle = `hsla(0, 100%, 60%, ${0.15 + 0.1 * Math.sin(gameTime * 8)})`;
      ctx.lineWidth = 2;
      ctx.stroke();

      // Core
      ctx.beginPath();
      ctx.arc(d.x, d.y, DRONE_R, 0, Math.PI*2);
      const dHue = overclockActive ? 200 : 0;
      ctx.fillStyle = `hsl(${dHue}, 80%, 50%)`;
      ctx.fill();

      // Inner glow
      ctx.beginPath();
      ctx.arc(d.x, d.y, DRONE_R * 0.5, 0, Math.PI*2);
      ctx.fillStyle = `hsla(${dHue}, 90%, 70%, 0.6)`;
      ctx.fill();
    }

    // Player
    const py = PLAYER_Y_FRAC * H;
    const px = playerX;
    const pHue = overclockActive ? 195 : 160;
    const pLight = overclockActive ? 65 : 55;
    const pGlow = overclockActive ? 20 : 10;

    // Glow
    ctx.beginPath();
    ctx.arc(px, py, PLAYER_R + pGlow, 0, Math.PI*2);
    ctx.fillStyle = `hsla(${pHue}, 100%, ${pLight}%, 0.15)`;
    ctx.fill();

    // Body
    ctx.beginPath();
    ctx.arc(px, py, PLAYER_R, 0, Math.PI*2);
    ctx.fillStyle = `hsl(${pHue}, 90%, ${pLight}%)`;
    ctx.fill();

    // Inner highlight
    ctx.beginPath();
    ctx.arc(px - 2, py - 2, PLAYER_R * 0.45, 0, Math.PI*2);
    ctx.fillStyle = `hsla(${pHue}, 100%, 85%, 0.5)`;
    ctx.fill();

    // Overheat warning flash on player
    if(overheat > 0.75 && !overheatLocked){
      const flashAlpha = 0.3 * Math.sin(gameTime * 14) + 0.3;
      ctx.beginPath();
      ctx.arc(px, py, PLAYER_R + 4, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(255, 80, 0, ${flashAlpha})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    if(overheatLocked){
      ctx.beginPath();
      ctx.arc(px, py, PLAYER_R + 6, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(255, 30, 0, ${0.5 + 0.3 * Math.sin(gameTime * 20)})`;
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Particles
    for(let i=0;i<MAX_PARTICLES;i++){
      const p = particles[i];
      if(!p.alive) continue;
      const a = p.life / p.maxLife;
      ctx.fillStyle = `rgba(${p.r},${p.g},${p.b},${a})`;
      ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    }

    // Pop texts
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    for(let i=0;i<MAX_POP_TEXTS;i++){
      const p = popTexts[i];
      if(!p.alive) continue;
      const a = p.life / p.maxLife;
      ctx.font = `bold ${12 + 4 * a}px monospace`;
      ctx.fillStyle = `rgba(${p.r},${p.g},${p.b},${a})`;
      ctx.fillText(p.text, p.x, p.y);
    }

    // HUD - Score & Best
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.font = 'bold 16px monospace';
    ctx.fillStyle = '#fff';
    ctx.fillText(Math.floor(score) + '', 12, 12);
    ctx.font = '11px monospace';
    ctx.fillStyle = '#8af';
    ctx.fillText('BEST ' + bestScore, 12, 32);

    // Multiplier
    if(multiplier > 1.01){
      ctx.textAlign = 'right';
      ctx.font = 'bold 14px monospace';
      ctx.fillStyle = '#0ff';
      ctx.fillText('x' + multiplier.toFixed(1), W - 12, 12);
    }

    // Overclock bar
    const barW = 80, barH = 6, barX = W - barW - 12, barY = 34;
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillRect(barX, barY, barW, barH);
    const ocFill = overclockActive ? 1 : overclock;
    const ocColor = overclockActive ? '#0ff' : `hsl(${195}, 80%, ${40 + 20 * overclock}%)`;
    ctx.fillStyle = ocColor;
    ctx.fillRect(barX, barY, barW * ocFill, barH);
    ctx.font = '8px monospace';
    ctx.textAlign = 'right';
    ctx.fillStyle = '#68a';
    ctx.fillText('OC', barX - 3, barY - 1);

    // Overheat bar
    const hBarY = barY + 12;
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillRect(barX, hBarY, barW, barH);
    const heatCol = overheat > 0.75 ? `hsl(${10 - overheat * 10}, 100%, ${50 + 10 * Math.sin(gameTime*10)}%)` : `hsl(${30 - overheat * 20}, 80%, 50%)`;
    ctx.fillStyle = heatCol;
    ctx.fillRect(barX, hBarY, barW * overheat, barH);
    ctx.font = '8px monospace';
    ctx.fillStyle = overheat > 0.75 ? '#f64' : '#865';
    ctx.fillText('HEAT', barX - 3, hBarY - 1);

    // Overheat lockout warning
    if(overheatLocked){
      ctx.textAlign = 'center';
      ctx.font = 'bold 18px monospace';
      ctx.fillStyle = `rgba(255, 60, 0, ${0.6 + 0.3 * Math.sin(gameTime * 16)})`;
      ctx.fillText('OVERHEATED', W/2, H * 0.45);
    }
  }

  ctx.restore();
}

/* ===== LOOP ===== */
let lastTime = 0;
function loop(ts){
  const now = ts / 1000;
  let dt = now - lastTime;
  lastTime = now;
  if(dt > 0.1) dt = 0.016;
  if(dt <= 0) dt = 0.016;

  update(dt);
  draw();
  requestAnimationFrame(loop);
}

/* ===== BOOT ===== */
loadBest();
showStart();
requestAnimationFrame((ts)=>{
  lastTime = ts / 1000;
  loop(ts);
});

})();
</script>
</body>
</html>
