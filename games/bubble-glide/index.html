<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bubble Glide - Free HTML5 Game</title>
<meta name="description" content="Play Bubble Glide - Tap to navigate a bubble through underwater coral while building combo multipliers.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a1628">
<meta property="og:type" content="website">
<meta property="og:title" content="Bubble Glide - Free HTML5 Game">
<meta property="og:description" content="Play Bubble Glide - Tap to navigate a bubble through underwater coral while building combo multipliers.">
<meta property="og:url" content="https://balinti.github.io/bubble-glide/">
<meta property="og:image" content="https://balinti.github.io/bubble-glide/og-image.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Bubble Glide - Free HTML5 Game">
<meta name="twitter:description" content="Play Bubble Glide - Tap to navigate a bubble through underwater coral while building combo multipliers.">
<meta name="twitter:image" content="https://balinti.github.io/bubble-glide/og-image.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "VideoGame",
  "name": "Bubble Glide",
  "description": "Tap to navigate a bubble through underwater coral while building combo multipliers.",
  "url": "https://balinti.github.io/bubble-glide/",
  "genre": "Casual",
  "gamePlatform": "Web Browser",
  "applicationCategory": "Game",
  "operatingSystem": "Any",
  "playMode": "SinglePlayer",
  "offers": { "@type": "Offer", "price": "0", "priceCurrency": "USD" }
}
</script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a1628;touch-action:none;-webkit-tap-highlight-color:transparent;user-select:none}
body{display:flex;align-items:center;justify-content:center;font-family:'Segoe UI',system-ui,-apple-system,sans-serif}
#wrap{position:relative;width:100%;max-width:420px;height:100vh;max-height:750px;overflow:hidden;border-radius:0}
canvas{display:block;width:100%;height:100%}
@media(min-width:421px){#wrap{border-radius:18px;box-shadow:0 0 60px rgba(0,180,255,.15)}}
</style>
</head>
<body>
<div id="wrap"><canvas id="c"></canvas></div>
<script>
'use strict';
(()=>{
// ── Helpers ──
const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
const lerp=(a,b,t)=>a+(b-a)*t;
const rand=(lo,hi)=>lo+Math.random()*(hi-lo);
const randInt=(lo,hi)=>Math.floor(rand(lo,hi+1));
const hsl=(h,s,l)=>`hsl(${h},${s}%,${l}%)`;
const hsla=(h,s,l,a)=>`hsla(${h},${s}%,${l}%,${a})`;
const dist=(x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1);

// ── Canvas Setup ──
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
const wrap=document.getElementById('wrap');
let W,H,dpr;

function resize(){
  W=wrap.clientWidth;
  H=wrap.clientHeight;
  dpr=Math.min(window.devicePixelRatio||1,2);
  canvas.width=W*dpr;
  canvas.height=H*dpr;
  canvas.style.width=W+'px';
  canvas.style.height=H+'px';
}
resize();
window.addEventListener('resize',resize);

// ── State ──
let state='start'; // start | playing | gameover
let score=0, best=parseInt(localStorage.getItem('bg_best'))||0;
let combo=0, maxCombo=0, comboTier=0, comboMult=1;
let boostTimer=0;
let gameTime=0;
let hueShift=0;

// ── Input ──
let pressing=false;
function onDown(e){e.preventDefault();pressing=true;if(state==='start'){startGame();}else if(state==='gameover'){startGame();}}
function onUp(e){e.preventDefault();pressing=false;}
canvas.addEventListener('pointerdown',onDown);
canvas.addEventListener('pointerup',onUp);
canvas.addEventListener('pointercancel',onUp);
document.addEventListener('keydown',e=>{
  if(e.code==='Space'||e.code==='Enter'){e.preventDefault();pressing=true;if(state==='start')startGame();else if(state==='gameover')startGame();}
});
document.addEventListener('keyup',e=>{
  if(e.code==='Space'||e.code==='Enter'){e.preventDefault();pressing=false;}
});

// ── Combo System ──
const COMBO_TIERS=[
  {threshold:0,mult:1,name:''},
  {threshold:3,mult:1.15,name:'x2'},
  {threshold:7,mult:1.35,name:'x3'},
  {threshold:12,mult:1.6,name:'x4'},
  {threshold:20,mult:1.9,name:'x5'},
  {threshold:30,mult:2.3,name:'MAX'}
];
function updateComboTier(){
  comboTier=0;comboMult=1;
  for(let i=COMBO_TIERS.length-1;i>=0;i--){
    if(combo>=COMBO_TIERS[i].threshold){comboTier=i;comboMult=COMBO_TIERS[i].mult;break;}
  }
}

// ── Bubble ──
let bubble={x:0,y:0,vy:0,radius:14,trail:[]};
const GRAVITY=-320;   // buoyancy: rises when not pressing
const SINK_FORCE=580;  // pressing sinks

// ── Camera / Scroll ──
let camera={x:0};
let baseSpeed=120;
let scrollSpeed=120;

// ── Tunnel ──
let tunnelSeed=42;
function seededRand(){tunnelSeed=(tunnelSeed*16807)%2147483647;return(tunnelSeed-1)/2147483646;}
function tunnelCenter(x){
  return H*0.5+Math.sin(x*0.003)*H*0.12+Math.sin(x*0.0007+2)*H*0.08+Math.sin(x*0.0015+5)*H*0.05;
}
function tunnelHalfHeight(x){
  let base=H*0.32;
  let narrowing=clamp(gameTime/120,0,0.35);
  base*=(1-narrowing*0.45);
  base+=Math.sin(x*0.002+1)*H*0.04;
  return Math.max(base,H*0.1);
}

// ── Rings ──
let rings=[];
let nextRingX=0;
const RING_GAP_BASE=220;

function spawnRing(x,isFirst){
  let cy=tunnelCenter(x);
  let hh=tunnelHalfHeight(x);
  let top=cy-hh+30;
  let bot=cy+hh-30;
  let ry,rRadius;
  if(isFirst){
    ry=cy;
    rRadius=55;
  }else{
    let offset=rand(-0.35,0.35)*hh;
    ry=clamp(cy+offset,top+20,bot-20);
    rRadius=rand(28,42);
  }
  let isFake=!isFirst&&gameTime>15&&Math.random()<0.12;
  let isMoving=!isFirst&&!isFake&&gameTime>25&&Math.random()<0.18;
  let moveAmp=isMoving?rand(20,40):0;
  let moveSpeed=isMoving?rand(1.5,3):0;
  let movePhase=rand(0,Math.PI*2);
  rings.push({x,baseY:ry,y:ry,radius:rRadius,passed:false,missed:false,fake:isFake,moving:isMoving,moveAmp,moveSpeed,movePhase,hue:rand(160,260)});
}

// ── Particles ──
let particles=[];
function emitParticles(x,y,count,hue,speed,life){
  for(let i=0;i<count;i++){
    let angle=rand(0,Math.PI*2);
    let spd=rand(speed*0.3,speed);
    particles.push({x,y,vx:Math.cos(angle)*spd,vy:Math.sin(angle)*spd,life:rand(life*0.5,life),maxLife:life,radius:rand(2,5),hue:hue+rand(-20,20),sat:rand(60,100),lit:rand(50,80),drag:0.97});
  }
}
function emitBubbleTrail(){
  if(Math.random()>0.4)return;
  particles.push({x:bubble.x-bubble.radius,y:bubble.y+rand(-4,4),vx:rand(-15,-5),vy:rand(-8,8),life:rand(0.3,0.7),maxLife:0.7,radius:rand(1.5,3.5),hue:190,sat:80,lit:75,drag:0.95});
}

// ── Screen Shake ──
let shakeX=0,shakeY=0,shakeMag=0,shakeTimer=0;
function startShake(mag,dur){shakeMag=mag;shakeTimer=dur;}

// ── Pressure Pulse ──
let pulseActive=false, pulseTimer=0, pulseCooldown=0;
let pulseWarning=false, pulseWarningTimer=0;
const PULSE_DURATION=1.0;
const PULSE_WARNING=1.2;

// ── Coral Silhouettes (decorative) ──
function drawCoralSilhouette(x,yBase,flip){
  ctx.save();
  ctx.translate(x-camera.x,yBase);
  if(flip)ctx.scale(1,-1);
  ctx.fillStyle=hsla(220+Math.sin(x*0.01)*20,40,12,0.7);
  ctx.beginPath();
  let w=rand(15,35);
  let h=rand(25,55);
  ctx.moveTo(-w*0.5,0);
  ctx.quadraticCurveTo(-w*0.3,-h*0.5,0,-h);
  ctx.quadraticCurveTo(w*0.3,-h*0.5,w*0.5,0);
  ctx.fill();
  ctx.restore();
}

// ── Behind camera timer ──
let behindTimer=0;

// ── Start / Reset ──
function startGame(){
  state='playing';
  score=0;combo=0;maxCombo=0;comboTier=0;comboMult=1;
  boostTimer=0;gameTime=0;
  camera.x=0;scrollSpeed=baseSpeed;
  bubble.x=W*0.28;bubble.y=H*0.5;bubble.vy=0;bubble.trail=[];
  rings=[];particles=[];
  tunnelSeed=42+Date.now()%10000;
  nextRingX=camera.x+W*0.6;
  spawnRing(nextRingX,true);
  nextRingX+=RING_GAP_BASE;
  behindTimer=0;
  pulseActive=false;pulseTimer=0;pulseCooldown=12;pulseWarning=false;
  shakeMag=0;shakeTimer=0;
  pressing=false;
}

function gameOver(){
  state='gameover';
  if(score>best){best=score;localStorage.setItem('bg_best',best);}
  startShake(12,0.5);
  emitParticles(bubble.x-camera.x,bubble.y,40,0,200,1.2);
}

// ── Main Loop ──
let lastTime=0;
function loop(ts){
  requestAnimationFrame(loop);
  let dt=(ts-lastTime)/1000;
  lastTime=ts;
  dt=clamp(dt,0,0.05);
  hueShift+=dt*15;

  // Setup transform
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,W,H);

  if(state==='start'){drawStart(dt);return;}
  if(state==='gameover'){drawGameOver(dt);return;}

  update(dt);
  render(dt);
}

// ── Update ──
function update(dt){
  gameTime+=dt;

  // Pressure Pulse
  if(gameTime>70){
    pulseCooldown-=dt;
    if(!pulseActive&&!pulseWarning&&pulseCooldown<=0){
      pulseWarning=true;pulseWarningTimer=PULSE_WARNING;
    }
    if(pulseWarning){
      pulseWarningTimer-=dt;
      if(pulseWarningTimer<=0){
        pulseWarning=false;pulseActive=true;pulseTimer=PULSE_DURATION;
      }
    }
    if(pulseActive){
      pulseTimer-=dt;
      if(pulseTimer<=0){pulseActive=false;pulseCooldown=rand(10,15);}
    }
  }

  // Speed
  let diffMult=1+clamp(gameTime/90,0,0.8);
  scrollSpeed=baseSpeed*comboMult*diffMult;
  if(boostTimer>0){scrollSpeed*=1.3;boostTimer-=dt;}

  // Camera
  camera.x+=scrollSpeed*dt;

  // Bubble physics
  let grav=GRAVITY;
  let sink=SINK_FORCE;
  if(pulseActive){grav=-grav;sink=-sink;} // flip buoyancy

  if(pressing){
    bubble.vy+=sink*dt;
  }else{
    bubble.vy+=grav*dt;
  }
  bubble.vy*=0.985; // drag
  bubble.y+=bubble.vy*dt;

  // Anchor bubble X relative to camera
  let targetX=camera.x+W*0.28;
  bubble.x=lerp(bubble.x,targetX,0.12);

  // Trail
  bubble.trail.unshift({x:bubble.x,y:bubble.y});
  if(bubble.trail.length>20)bubble.trail.pop();

  // Tunnel collision
  let tc=tunnelCenter(bubble.x);
  let th=tunnelHalfHeight(bubble.x);
  let margin=bubble.radius+4;
  let topWall=tc-th+margin;
  let botWall=tc+th-margin;
  if(bubble.y<topWall||bubble.y>botWall){
    emitParticles(bubble.x-camera.x,bubble.y,15,200,100,0.6);
    gameOver();return;
  }

  // Behind camera check
  if(bubble.x<camera.x+W*0.10){
    behindTimer+=dt;
    if(behindTimer>0.35){gameOver();return;}
  }else{behindTimer=0;}

  // Rings update & spawn
  let prevBX=bubble.x-scrollSpeed*dt;
  for(let r of rings){
    if(r.moving)r.y=r.baseY+Math.sin(gameTime*r.moveSpeed+r.movePhase)*r.moveAmp;
    if(!r.passed&&!r.missed){
      // Check crossing
      if(prevBX<=r.x&&bubble.x>r.x){
        let d=Math.abs(bubble.y-r.y);
        if(d<r.radius+bubble.radius*0.5){
          if(!r.fake){
            // Passed ring!
            r.passed=true;
            score+=Math.ceil(10*comboMult);
            combo++;
            if(combo>maxCombo)maxCombo=combo;
            updateComboTier();
            boostTimer=1.0;
            emitParticles(r.x-camera.x,r.y,20,r.hue,150,0.8);
            startShake(2.5,0.12);
          }else{
            // Fake ring - just pass through, no score
            r.passed=true;
            emitParticles(r.x-camera.x,r.y,5,0,60,0.4);
          }
        }
      }
      // Miss detection: ring is behind bubble
      if(r.x<bubble.x-30&&!r.passed){
        r.missed=true;
        if(!r.fake){
          combo=0;updateComboTier();
          boostTimer=0;
          emitParticles(r.x-camera.x,r.y,6,40,40,0.4);
        }
      }
    }
  }

  // Remove offscreen rings
  rings=rings.filter(r=>r.x>camera.x-100);

  // Spawn rings
  while(nextRingX<camera.x+W+300){
    let gap=RING_GAP_BASE-clamp(gameTime*0.4,0,60)+rand(-30,30);
    gap=Math.max(gap,110);
    spawnRing(nextRingX,false);
    // Occasionally spawn double ring (side by side)
    if(gameTime>20&&Math.random()<0.15){
      let tc2=tunnelCenter(nextRingX);
      let hh2=tunnelHalfHeight(nextRingX);
      let offset=rand(0.2,0.4)*hh2*(Math.random()>0.5?1:-1);
      let ry2=clamp(tc2+offset,tc2-hh2+30,tc2+hh2-30);
      rings.push({x:nextRingX,baseY:ry2,y:ry2,radius:rand(26,36),passed:false,missed:false,fake:false,moving:false,moveAmp:0,moveSpeed:0,movePhase:0,hue:rand(40,120)});
    }
    nextRingX+=gap;
  }

  // Particles
  emitBubbleTrail();
  for(let p of particles){
    p.vx*=p.drag;p.vy*=p.drag;
    p.x+=p.vx*dt;p.y+=p.vy*dt;
    p.life-=dt;
  }
  particles=particles.filter(p=>p.life>0);

  // Shake
  if(shakeTimer>0){
    shakeTimer-=dt;
    let t=shakeTimer/0.5;
    shakeX=(Math.random()-0.5)*shakeMag*t;
    shakeY=(Math.random()-0.5)*shakeMag*t;
  }else{shakeX=0;shakeY=0;}
}

// ── Render ──
function render(dt){
  ctx.save();
  ctx.translate(shakeX,shakeY);

  // BG gradient
  let grad=ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0,hsl(220+hueShift%30,55,10));
  grad.addColorStop(0.5,hsl(210+hueShift%20,50,14));
  grad.addColorStop(1,hsl(200+hueShift%15,60,8));
  ctx.fillStyle=grad;
  ctx.fillRect(-20,-20,W+40,H+40);

  // Tunnel walls
  drawTunnel();

  // Rings
  for(let r of rings){
    if(r.x<camera.x-50||r.x>camera.x+W+50)continue;
    let sx=r.x-camera.x;
    let sy=r.y;
    ctx.save();
    if(r.fake){
      ctx.globalAlpha=0.25;
      ctx.strokeStyle=hsla(0,0,60,0.3);
    }else if(r.passed){
      ctx.globalAlpha=0.2;
      ctx.strokeStyle=hsla(r.hue,80,70,0.3);
    }else{
      ctx.globalAlpha=1;
      ctx.strokeStyle=hsla(r.hue,85,65,0.9);
      // Glow
      ctx.shadowColor=hsla(r.hue,90,60,0.5);
      ctx.shadowBlur=15;
    }
    ctx.lineWidth=r.fake?2:3.5;
    ctx.beginPath();
    ctx.arc(sx,sy,r.radius,0,Math.PI*2);
    ctx.stroke();
    if(!r.fake&&!r.passed){
      ctx.beginPath();
      ctx.arc(sx,sy,r.radius-2,Math.PI*0.8,Math.PI*1.2);
      ctx.strokeStyle=hsla(r.hue,90,85,0.5);
      ctx.lineWidth=2;
      ctx.stroke();
    }
    ctx.restore();
  }

  // Bubble
  let bx=bubble.x-camera.x;
  let by=bubble.y;
  // Bubble body
  ctx.save();
  let bHue=pulseActive?0:190+Math.sin(gameTime*2)*15;
  let bGrad=ctx.createRadialGradient(bx-3,by-3,2,bx,by,bubble.radius);
  bGrad.addColorStop(0,hsla(bHue,80,85,0.9));
  bGrad.addColorStop(0.5,hsla(bHue,75,60,0.7));
  bGrad.addColorStop(1,hsla(bHue,70,40,0.4));
  ctx.fillStyle=bGrad;
  ctx.beginPath();
  ctx.arc(bx,by,bubble.radius,0,Math.PI*2);
  ctx.fill();
  // Highlight
  ctx.fillStyle=hsla(bHue,60,90,0.5);
  ctx.beginPath();
  ctx.arc(bx-4,by-4,bubble.radius*0.3,0,Math.PI*2);
  ctx.fill();
  // Trail
  for(let i=1;i<bubble.trail.length;i++){
    let t=bubble.trail[i];
    let a=1-i/bubble.trail.length;
    ctx.fillStyle=hsla(bHue,70,60,a*0.25);
    ctx.beginPath();
    ctx.arc(t.x-camera.x,t.y,bubble.radius*(1-i*0.04),0,Math.PI*2);
    ctx.fill();
  }
  ctx.restore();

  // Pulse warning
  if(pulseWarning){
    let flash=Math.sin(gameTime*18)*0.5+0.5;
    ctx.fillStyle=hsla(0,80,50,flash*0.12);
    ctx.fillRect(0,0,W,H);
    // Ripple line
    ctx.strokeStyle=hsla(0,90,60,flash*0.5);
    ctx.lineWidth=2;
    let rx=W*0.5+Math.sin(gameTime*6)*W*0.3;
    ctx.beginPath();ctx.moveTo(rx,0);ctx.lineTo(rx,H);ctx.stroke();
  }
  if(pulseActive){
    ctx.fillStyle=hsla(280,60,40,0.08+Math.sin(gameTime*12)*0.04);
    ctx.fillRect(0,0,W,H);
  }

  // Particles
  for(let p of particles){
    let a=clamp(p.life/p.maxLife,0,1);
    ctx.fillStyle=hsla(p.hue,p.sat,p.lit,a*0.8);
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.radius*a,0,Math.PI*2);
    ctx.fill();
  }

  // HUD
  drawHUD();

  ctx.restore();
}

function drawTunnel(){
  // Top wall
  ctx.fillStyle=hsla(210+hueShift%20,45,8,0.95);
  ctx.beginPath();
  ctx.moveTo(-10,0);
  for(let px=0;px<=W+20;px+=8){
    let wx=camera.x+px;
    let tc=tunnelCenter(wx);
    let th=tunnelHalfHeight(wx);
    let topY=tc-th;
    // Add jagged coral effect
    let jag=Math.sin(wx*0.05)*4+Math.sin(wx*0.12)*2;
    ctx.lineTo(px,topY+jag);
  }
  ctx.lineTo(W+20,0);
  ctx.closePath();
  ctx.fill();

  // Bottom wall
  ctx.fillStyle=hsla(215+hueShift%20,40,6,0.95);
  ctx.beginPath();
  ctx.moveTo(-10,H);
  for(let px=0;px<=W+20;px+=8){
    let wx=camera.x+px;
    let tc=tunnelCenter(wx);
    let th=tunnelHalfHeight(wx);
    let botY=tc+th;
    let jag=Math.sin(wx*0.06+3)*4+Math.sin(wx*0.1+1)*2;
    ctx.lineTo(px,botY+jag);
  }
  ctx.lineTo(W+20,H);
  ctx.closePath();
  ctx.fill();

  // Coral decorations on walls
  for(let px=0;px<W;px+=60){
    let wx=camera.x+px;
    let tc=tunnelCenter(wx);
    let th=tunnelHalfHeight(wx);
    if(Math.sin(wx*0.037)>0.3){
      drawCoralSilhouette(wx,tc+th,false);
    }
    if(Math.sin(wx*0.041+2)>0.4){
      drawCoralSilhouette(wx,tc-th,true);
    }
  }
}

function drawHUD(){
  // Score top-left
  ctx.save();
  ctx.font='bold 22px "Segoe UI",system-ui,sans-serif';
  ctx.textAlign='left';
  ctx.textBaseline='top';
  ctx.fillStyle=hsla(0,0,100,0.9);
  ctx.shadowColor='rgba(0,0,0,0.5)';ctx.shadowBlur=4;
  ctx.fillText(score,16,16);

  // Best + combo top-right
  ctx.textAlign='right';
  ctx.font='14px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle=hsla(0,0,80,0.6);
  ctx.fillText('BEST '+best,W-16,16);

  if(comboTier>0){
    ctx.font='bold 18px "Segoe UI",system-ui,sans-serif';
    let ch=40+comboTier*40;
    ctx.fillStyle=hsla(ch,85,65,0.9);
    ctx.fillText(COMBO_TIERS[comboTier].name,W-16,36);
  }

  // Boost indicator
  if(boostTimer>0){
    ctx.fillStyle=hsla(50,90,65,0.7);
    ctx.fillRect(W*0.3,8,W*0.4*(boostTimer/1.0),4);
  }

  // Pulse warning text
  if(pulseWarning||pulseActive){
    ctx.textAlign='center';
    ctx.font='bold 14px "Segoe UI",system-ui,sans-serif';
    let flash=Math.sin(gameTime*14)*0.5+0.5;
    ctx.fillStyle=hsla(0,80,60,pulseActive?0.8:flash*0.8);
    ctx.fillText(pulseActive?'PRESSURE PULSE!':'WARNING',W*0.5,H*0.08);
  }
  ctx.restore();
}

// ── Start Screen ──
function drawStart(dt){
  // BG
  let grad=ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0,hsl(220,55,10));
  grad.addColorStop(0.5,hsl(210,50,14));
  grad.addColorStop(1,hsl(200,60,8));
  ctx.fillStyle=grad;
  ctx.fillRect(0,0,W,H);

  // Decorative bubbles
  for(let i=0;i<8;i++){
    let bx=W*0.15+i*W*0.1;
    let by=H*0.5+Math.sin(hueShift*0.05+i*1.2)*H*0.15;
    ctx.fillStyle=hsla(190+i*10,60,60,0.1);
    ctx.beginPath();
    ctx.arc(bx,by,15+i*3,0,Math.PI*2);
    ctx.fill();
  }

  ctx.save();
  ctx.textAlign='center';

  // Title
  ctx.font='bold 42px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle=hsla(195,80,75,0.95);
  ctx.shadowColor=hsla(200,90,50,0.4);ctx.shadowBlur=20;
  ctx.fillText('Bubble Glide',W*0.5,H*0.3);

  // Subtitle
  ctx.shadowBlur=0;
  ctx.font='18px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle=hsla(180,60,65,0.7);
  ctx.fillText('Current Rings',W*0.5,H*0.3+36);

  // Instructions
  ctx.font='15px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle=hsla(0,0,80,0.6);
  ctx.fillText('Tap & Hold to Sink',W*0.5,H*0.52);
  ctx.fillText('Release to Rise',W*0.5,H*0.52+24);

  // Best
  if(best>0){
    ctx.fillStyle=hsla(50,70,70,0.5);
    ctx.fillText('Best: '+best,W*0.5,H*0.52+60);
  }

  // CTA
  let pulse=0.6+Math.sin(hueShift*0.1)*0.3;
  ctx.font='bold 20px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle=hsla(195,80,75,pulse);
  ctx.fillText('Tap to Start',W*0.5,H*0.72);

  ctx.restore();
}

// ── Game Over Screen ──
function drawGameOver(dt){
  // Update shake
  if(shakeTimer>0){
    shakeTimer-=dt;
    let t=shakeTimer/0.5;
    shakeX=(Math.random()-0.5)*shakeMag*t;
    shakeY=(Math.random()-0.5)*shakeMag*t;
  }else{shakeX=0;shakeY=0;}

  // Update particles
  for(let p of particles){
    p.vx*=p.drag;p.vy*=p.drag;
    p.x+=p.vx*dt;p.y+=p.vy*dt;
    p.life-=dt;
  }
  particles=particles.filter(p=>p.life>0);

  ctx.save();
  ctx.translate(shakeX,shakeY);

  // BG
  let grad=ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0,hsl(220,55,8));
  grad.addColorStop(1,hsl(0,40,8));
  ctx.fillStyle=grad;
  ctx.fillRect(-20,-20,W+40,H+40);

  // Particles
  for(let p of particles){
    let a=clamp(p.life/p.maxLife,0,1);
    ctx.fillStyle=hsla(p.hue,p.sat,p.lit,a*0.8);
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.radius*a,0,Math.PI*2);
    ctx.fill();
  }

  ctx.textAlign='center';

  // Game Over
  ctx.font='bold 36px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle=hsla(0,70,65,0.9);
  ctx.shadowColor=hsla(0,80,40,0.4);ctx.shadowBlur=15;
  ctx.fillText('Game Over',W*0.5,H*0.3);
  ctx.shadowBlur=0;

  // Score
  ctx.font='bold 48px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle=hsla(0,0,95,0.95);
  ctx.fillText(score,W*0.5,H*0.42);

  // Best
  ctx.font='18px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle=hsla(50,70,70,0.7);
  ctx.fillText('Best: '+best,W*0.5,H*0.50);

  // Max combo
  if(maxCombo>0){
    let mTier=0;
    for(let i=COMBO_TIERS.length-1;i>=0;i--){
      if(maxCombo>=COMBO_TIERS[i].threshold){mTier=i;break;}
    }
    if(mTier>0){
      ctx.fillStyle=hsla(40+mTier*40,80,65,0.7);
      ctx.fillText('Max Combo: '+COMBO_TIERS[mTier].name+' ('+maxCombo+')',W*0.5,H*0.56);
    }
  }

  // CTA
  let pulse=0.5+Math.sin(hueShift*0.1)*0.3;
  ctx.font='bold 20px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle=hsla(195,80,75,pulse);
  ctx.fillText('Tap to Retry',W*0.5,H*0.7);

  ctx.restore();
}

// ── Kick off ──
requestAnimationFrame(loop);
})();
</script>
</body>
</html>
