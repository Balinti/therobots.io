<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Shrink Link - Free HTML5 Game</title>
<meta name="description" content="Play Shrink Link - Tap to connect neon dots before objects shrink out of reach.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0a1a">
<meta property="og:type" content="website">
<meta property="og:title" content="Shrink Link - Free HTML5 Game">
<meta property="og:description" content="Play Shrink Link - Tap to connect neon dots before objects shrink out of reach.">
<meta property="og:url" content="https://balinti.github.io/shrink-link/">
<meta property="og:image" content="https://balinti.github.io/shrink-link/og-image.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#05050f;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#fff;touch-action:none;user-select:none;-webkit-user-select:none}
#wrap{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;height:100%;min-height:100dvh}
#top-bar{width:100%;max-width:420px;height:50px;display:flex;align-items:center;justify-content:center;font-size:12px;color:#888;letter-spacing:1px;text-transform:uppercase}
#game-container{position:relative;width:100%;max-width:420px;flex:1;max-height:750px;overflow:hidden;border-radius:8px;background:linear-gradient(180deg,#0a0a1a 0%,#0f0f2a 50%,#0a0a1a 100%)}
canvas{display:block;width:100%;height:100%}
#score-display{position:absolute;top:12px;left:0;right:0;text-align:center;pointer-events:none;z-index:2}
#score-text{font-size:14px;color:rgba(255,255,255,0.5);letter-spacing:2px;text-transform:uppercase}
#score-value{font-size:36px;font-weight:700;color:#fff;text-shadow:0 0 20px rgba(255,255,255,0.3)}
#lives-display{position:absolute;top:14px;right:14px;pointer-events:none;z-index:2;font-size:20px;letter-spacing:4px}
#combo-display{position:absolute;top:70px;left:0;right:0;text-align:center;pointer-events:none;z-index:2;font-size:16px;font-weight:700;color:rgba(255,255,255,0);transition:color 0.15s}
#bottom-bar{width:100%;max-width:420px;height:50px;display:flex;align-items:center;justify-content:center;font-size:11px;color:#555;letter-spacing:0.5px}
</style>
</head>
<body>
<div id="wrap">
  <div id="top-bar">Shrink Link</div>
  <div id="game-container">
    <canvas id="c"></canvas>
    <div id="score-display">
      <div id="score-text">SCORE</div>
      <div id="score-value">0</div>
    </div>
    <div id="lives-display"></div>
    <div id="combo-display"></div>
  </div>
  <div id="bottom-bar">&copy; 2026 Shrink Link &middot; Hyper-Casual Game</div>
</div>
<script>
(()=>{
'use strict';

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('score-display');
const scoreValue = document.getElementById('score-value');
const livesDisplay = document.getElementById('lives-display');
const comboDisplay = document.getElementById('combo-display');
const container = document.getElementById('game-container');

let W, H, dpr, cx, cy;
let ringRadius;

function resize() {
  const rect = container.getBoundingClientRect();
  dpr = window.devicePixelRatio || 1;
  W = rect.width;
  H = rect.height;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  cx = W / 2;
  cy = H / 2;
  ringRadius = Math.min(W, H) * 0.32;
}
window.addEventListener('resize', resize);
resize();

// Game states
const START = 0, PLAYING = 1, GAMEOVER = 2;
let state = START;

// Colors (HSL hues)
const DOT_HUES = [0, 120, 210, 50]; // red, green, blue, yellow
function hslStr(h, s, l, a) { return `hsla(${h},${s}%,${l}%,${a !== undefined ? a : 1})`; }

// Game vars
let score, bestScore, lives, combo, comboColor, chainTimer, gameTime, difficulty;
let cursorAngle, cursorSpeed, dots, particles, trails, shockwaves, floatingTexts;
let shakeAmount, shakeDuration, shakeTime;
let dangerAlpha, pulseFreezeCooldown;
let laserAngle, laserActive, laserTimer, laserAlpha;
let lastTime, elapsed;
let hueOffset = 0;

bestScore = parseInt(localStorage.getItem('shrinklink_best') || '0', 10);

function initGame() {
  score = 0;
  lives = 3;
  combo = 0;
  comboColor = -1;
  chainTimer = 0;
  gameTime = 0;
  difficulty = 0;
  cursorAngle = 0;
  cursorSpeed = 1.8;
  dots = [];
  particles = [];
  trails = [];
  shockwaves = [];
  floatingTexts = [];
  shakeAmount = 0;
  shakeDuration = 0;
  shakeTime = 0;
  dangerAlpha = 0;
  pulseFreezeCooldown = 0;
  laserAngle = 0;
  laserActive = false;
  laserTimer = 0;
  laserAlpha = 0;
  spawnTimer = 0;
  updateUI();
}

let spawnTimer = 0;

function getDifficulty() {
  return Math.min(gameTime / 120 + score / 500, 1);
}

function getNumColors() {
  if (difficulty < 0.2) return 2;
  if (difficulty < 0.5) return 3;
  return 4;
}

function getSpawnInterval() {
  return Math.max(0.6, 1.8 - difficulty * 1.0);
}

function getShrinkSpeed() {
  return 0.012 + difficulty * 0.018;
}

function getSnapAngle() {
  return Math.max(0.25, 0.55 - difficulty * 0.2);
}

function getChainWindow() {
  return Math.max(0.35, 0.6 - difficulty * 0.15);
}

function spawnDot() {
  const nc = getNumColors();
  const colorIdx = Math.floor(Math.random() * nc);
  const angle = Math.random() * Math.PI * 2;
  const r = ringRadius * (0.9 + Math.random() * 0.2);
  dots.push({
    angle: angle,
    radius: r,
    startRadius: r,
    size: 14 + Math.random() * 4,
    colorIdx: colorIdx,
    hue: DOT_HUES[colorIdx],
    alive: true,
    age: 0,
    pulse: 0
  });
}

function angleDiff(a, b) {
  let d = a - b;
  while (d > Math.PI) d -= Math.PI * 2;
  while (d < -Math.PI) d += Math.PI * 2;
  return d;
}

function trySnap() {
  if (dots.length === 0) return;

  const snapAngle = getSnapAngle();
  const inChain = chainTimer > 0 && comboColor >= 0;

  // Find best same-color match, and best any match
  let bestSame = null, bestSameDist = Infinity;
  let bestAny = null, bestAnyDist = Infinity;

  for (let i = 0; i < dots.length; i++) {
    const d = dots[i];
    if (!d.alive) continue;
    const ad = Math.abs(angleDiff(cursorAngle, d.angle));
    if (ad < snapAngle) {
      if (ad < bestAnyDist) { bestAny = d; bestAnyDist = ad; }
      if (inChain && d.colorIdx === comboColor && ad < bestSameDist) { bestSame = d; bestSameDist = ad; }
    }
  }

  let target = null;
  let chainBroken = false;

  if (inChain) {
    if (bestSame) {
      target = bestSame;
    } else if (bestAny) {
      target = bestAny;
      chainBroken = true;
    }
  } else {
    target = bestAny;
  }

  if (!target) return; // no valid dot in range

  // Snap cursor to dot
  cursorAngle = target.angle;

  // Score
  const alignBonus = 1 - (Math.abs(angleDiff(cursorAngle, target.angle)) / snapAngle);
  let pts = 10;

  if (!chainBroken && (inChain ? target.colorIdx === comboColor : true)) {
    combo++;
    comboColor = target.colorIdx;
    pts += combo * 5;
    if (alignBonus > 0.8) pts += 5; // perfect timing bonus
  } else {
    combo = 1;
    comboColor = target.colorIdx;
  }

  chainTimer = getChainWindow();
  score += pts;
  difficulty = getDifficulty();

  // Floating score text
  const tx = cx + Math.cos(target.angle) * target.radius;
  const ty = cy + Math.sin(target.angle) * target.radius;
  floatingTexts.push({ x: tx, y: ty, text: '+' + pts, life: 1, color: hslStr(target.hue, 80, 65) });

  // Snap trail
  const fromX = cx + Math.cos(cursorAngle) * (ringRadius * 0.15);
  const fromY = cy + Math.sin(cursorAngle) * (ringRadius * 0.15);
  trails.push({ x1: fromX, y1: fromY, x2: tx, y2: ty, life: 1, hue: target.hue });

  // Hit burst particles
  for (let i = 0; i < 12; i++) {
    const a = Math.random() * Math.PI * 2;
    const sp = 40 + Math.random() * 80;
    particles.push({
      x: tx, y: ty,
      vx: Math.cos(a) * sp,
      vy: Math.sin(a) * sp,
      life: 0.5 + Math.random() * 0.4,
      maxLife: 0.5 + Math.random() * 0.4,
      hue: target.hue,
      size: 2 + Math.random() * 3
    });
  }

  // Laser combo break check
  if (laserActive && laserAlpha > 0.5) {
    combo = 0;
    comboColor = -1;
    chainTimer = 0;
    floatingTexts.push({ x: cx, y: cy - 30, text: 'COMBO BREAK!', life: 1.2, color: '#f55' });
  }

  // Pulse Freeze every 3 combo
  if (combo > 0 && combo % 3 === 0) {
    triggerPulseFreeze(target.hue);
  }

  // Remove dot
  target.alive = false;

  updateUI();
}

function triggerPulseFreeze(hue) {
  // Push all dots outward
  for (const d of dots) {
    if (d.alive) {
      d.radius = Math.min(d.startRadius * 1.1, d.radius + ringRadius * 0.15);
    }
  }
  // Shockwave
  shockwaves.push({ x: cx, y: cy, radius: 10, maxRadius: ringRadius * 1.2, life: 1, hue: hue });
  // Score burst
  const burst = 25 + combo * 5;
  score += burst;
  floatingTexts.push({ x: cx, y: cy - 50, text: 'PULSE +' + burst, life: 1.5, color: hslStr(hue, 90, 70) });
  updateUI();
}

function loseLife() {
  lives--;
  shakeAmount = 8;
  shakeDuration = 0.4;
  shakeTime = 0;
  dangerAlpha = 0.6;
  updateUI();
  if (lives <= 0) {
    gameOver();
  }
}

function gameOver() {
  state = GAMEOVER;
  shakeAmount = 15;
  shakeDuration = 0.6;
  shakeTime = 0;
  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem('shrinklink_best', bestScore.toString());
  }
}

function updateUI() {
  scoreValue.textContent = score;
  let hearts = '';
  for (let i = 0; i < 3; i++) hearts += i < lives ? '\u2764' : '\u2661';
  livesDisplay.textContent = hearts;
  if (combo > 1) {
    comboDisplay.textContent = 'x' + combo + ' COMBO';
    comboDisplay.style.color = hslStr(DOT_HUES[comboColor] || 0, 80, 65, 0.9);
  } else {
    comboDisplay.style.color = 'rgba(255,255,255,0)';
  }
}

function handleInput() {
  if (state === START) {
    state = PLAYING;
    initGame();
  } else if (state === PLAYING) {
    trySnap();
  } else if (state === GAMEOVER) {
    state = START;
  }
}

canvas.addEventListener('pointerdown', (e) => { e.preventDefault(); handleInput(); });
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); handleInput(); }
});

// --- RENDER ---

function drawBackground() {
  // Gradient bg is done via CSS, just clear
  ctx.clearRect(0, 0, W, H);

  // Subtle grid
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1;
  const gs = 40;
  for (let x = gs; x < W; x += gs) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  for (let y = gs; y < H; y += gs) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }

  // Center ring guide
  ctx.beginPath();
  ctx.arc(cx, cy, ringRadius, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Inner ring
  ctx.beginPath();
  ctx.arc(cx, cy, 12, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  ctx.stroke();
}

function drawCursor() {
  const r = ringRadius * 0.15;
  const x = cx + Math.cos(cursorAngle) * r;
  const y = cy + Math.sin(cursorAngle) * r;

  // Line from center to cursor direction extending to ring
  const ex = cx + Math.cos(cursorAngle) * ringRadius * 1.05;
  const ey = cy + Math.sin(cursorAngle) * ringRadius * 1.05;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(ex, ey);
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Cursor glow
  const grad = ctx.createRadialGradient(x, y, 0, x, y, 18);
  grad.addColorStop(0, 'rgba(255,255,255,0.4)');
  grad.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(x, y, 18, 0, Math.PI * 2);
  ctx.fill();

  // Cursor dot
  ctx.beginPath();
  ctx.arc(x, y, 5, 0, Math.PI * 2);
  ctx.fillStyle = '#fff';
  ctx.fill();

  // Snap angle indicator (faint arc)
  const snapA = getSnapAngle();
  ctx.beginPath();
  ctx.arc(cx, cy, ringRadius * 0.95, cursorAngle - snapA, cursorAngle + snapA);
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 2;
  ctx.stroke();
}

function drawDots() {
  for (const d of dots) {
    if (!d.alive) continue;
    const x = cx + Math.cos(d.angle) * d.radius;
    const y = cy + Math.sin(d.angle) * d.radius;

    const dangerFrac = 1 - (d.radius / d.startRadius);
    const pulse = Math.sin(d.age * 6) * 0.15;
    const sz = d.size * (0.4 + (d.radius / d.startRadius) * 0.6) * (1 + pulse);

    // Glow
    const ga = 0.25 + dangerFrac * 0.3;
    const grad = ctx.createRadialGradient(x, y, 0, x, y, sz * 2);
    grad.addColorStop(0, hslStr(d.hue, 80, 60, ga));
    grad.addColorStop(1, hslStr(d.hue, 80, 60, 0));
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x, y, sz * 2, 0, Math.PI * 2);
    ctx.fill();

    // Dot
    ctx.beginPath();
    ctx.arc(x, y, sz, 0, Math.PI * 2);
    ctx.fillStyle = hslStr(d.hue, 80, 55 + dangerFrac * 15);
    ctx.fill();

    // Inner highlight
    ctx.beginPath();
    ctx.arc(x - sz * 0.2, y - sz * 0.2, sz * 0.4, 0, Math.PI * 2);
    ctx.fillStyle = hslStr(d.hue, 60, 80, 0.4);
    ctx.fill();

    // Danger indicator ring when close to center
    if (dangerFrac > 0.6) {
      ctx.beginPath();
      ctx.arc(x, y, sz + 4, 0, Math.PI * 2);
      ctx.strokeStyle = hslStr(0, 90, 55, (dangerFrac - 0.6) * 2.5 * (0.5 + Math.sin(d.age * 10) * 0.5));
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }
}

function drawTrails(dt) {
  for (let i = trails.length - 1; i >= 0; i--) {
    const t = trails[i];
    t.life -= dt * 3;
    if (t.life <= 0) { trails.splice(i, 1); continue; }
    ctx.beginPath();
    ctx.moveTo(t.x1, t.y1);
    ctx.lineTo(t.x2, t.y2);
    ctx.strokeStyle = hslStr(t.hue, 80, 60, t.life * 0.8);
    ctx.lineWidth = 2 * t.life;
    ctx.stroke();
  }
}

function drawParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.life -= dt;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= 0.96;
    p.vy *= 0.96;
    const a = p.life / p.maxLife;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * a, 0, Math.PI * 2);
    ctx.fillStyle = hslStr(p.hue, 80, 60, a);
    ctx.fill();
  }
}

function drawShockwaves(dt) {
  for (let i = shockwaves.length - 1; i >= 0; i--) {
    const s = shockwaves[i];
    s.life -= dt * 1.5;
    s.radius += (s.maxRadius - s.radius) * dt * 4;
    if (s.life <= 0) { shockwaves.splice(i, 1); continue; }
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
    ctx.strokeStyle = hslStr(s.hue, 70, 60, s.life * 0.5);
    ctx.lineWidth = 3 * s.life;
    ctx.stroke();
  }
}

function drawFloatingTexts(dt) {
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.life -= dt;
    t.y -= 30 * dt;
    if (t.life <= 0) { floatingTexts.splice(i, 1); continue; }
    const a = Math.min(1, t.life * 2);
    ctx.font = 'bold 16px "Segoe UI",system-ui,sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = t.color.replace(/[\d.]+\)$/, a + ')');
    ctx.fillText(t.text, t.x, t.y);
  }
}

function drawLaser() {
  if (!laserActive) return;
  const x1 = cx + Math.cos(laserAngle) * W;
  const y1 = cy + Math.sin(laserAngle) * W;
  const x2 = cx - Math.cos(laserAngle) * W;
  const y2 = cy - Math.sin(laserAngle) * W;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.strokeStyle = hslStr(0, 90, 55, laserAlpha * 0.7);
  ctx.lineWidth = 3;
  ctx.stroke();
  // Thinner bright core
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.strokeStyle = hslStr(0, 90, 80, laserAlpha * 0.5);
  ctx.lineWidth = 1;
  ctx.stroke();
}

function drawDangerVignette() {
  if (dangerAlpha <= 0) return;
  const grad = ctx.createRadialGradient(cx, cy, ringRadius * 0.5, cx, cy, Math.max(W, H) * 0.7);
  grad.addColorStop(0, 'rgba(255,0,0,0)');
  grad.addColorStop(1, `rgba(255,0,0,${dangerAlpha * 0.3})`);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
}

function drawComboRing() {
  if (combo < 2 || comboColor < 0) return;
  const a = Math.min(combo * 0.1, 0.5) * (0.5 + Math.sin(gameTime * 4) * 0.2);
  ctx.beginPath();
  ctx.arc(cx, cy, ringRadius * 0.18, 0, Math.PI * 2);
  ctx.strokeStyle = hslStr(DOT_HUES[comboColor], 80, 60, a);
  ctx.lineWidth = 2 + combo * 0.5;
  ctx.stroke();
}

function drawStartScreen() {
  // Title
  ctx.font = 'bold 42px "Segoe UI",system-ui,sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#fff';
  ctx.fillText('SHRINK LINK', cx, cy - 60);

  // Subtitle
  ctx.font = '16px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('SNAP CHAIN', cx, cy - 20);

  // Tap prompt
  const blink = 0.4 + Math.sin(performance.now() / 400) * 0.3;
  ctx.font = '18px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = `rgba(255,255,255,${blink})`;
  ctx.fillText('Tap to Start', cx, cy + 50);

  // Best score
  if (bestScore > 0) {
    ctx.font = '14px "Segoe UI",system-ui,sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillText('Best: ' + bestScore, cx, cy + 90);
  }

  // Decorative ring
  hueOffset = (hueOffset + 0.5) % 360;
  ctx.beginPath();
  ctx.arc(cx, cy - 60, 70, 0, Math.PI * 2);
  ctx.strokeStyle = hslStr(hueOffset, 60, 50, 0.15);
  ctx.lineWidth = 2;
  ctx.stroke();
}

function drawGameOverScreen() {
  // Overlay
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Game over
  ctx.font = 'bold 36px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = '#fff';
  ctx.fillText('GAME OVER', cx, cy - 70);

  // Score
  ctx.font = '18px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fillText('SCORE', cx, cy - 20);
  ctx.font = 'bold 48px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = '#fff';
  ctx.fillText(score.toString(), cx, cy + 25);

  // Best
  ctx.font = '16px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = hslStr(50, 80, 60, 0.8);
  ctx.fillText('BEST: ' + bestScore, cx, cy + 65);

  // New best indicator
  if (score >= bestScore && score > 0) {
    ctx.font = 'bold 14px "Segoe UI",system-ui,sans-serif';
    ctx.fillStyle = hslStr(50, 90, 65);
    ctx.fillText('NEW BEST!', cx, cy + 90);
  }

  // Retry
  const blink = 0.4 + Math.sin(performance.now() / 400) * 0.3;
  ctx.font = '18px "Segoe UI",system-ui,sans-serif';
  ctx.fillStyle = `rgba(255,255,255,${blink})`;
  ctx.fillText('Tap to Retry', cx, cy + 130);
}

// --- UPDATE ---
function update(dt) {
  if (state !== PLAYING) return;

  gameTime += dt;
  difficulty = getDifficulty();

  // Cursor orbits center
  const orbitSpeed = cursorSpeed + difficulty * 1.2;
  cursorAngle += orbitSpeed * dt;

  // Chain timer
  if (chainTimer > 0) {
    chainTimer -= dt;
    if (chainTimer <= 0) {
      chainTimer = 0;
      // Chain expired â€” combo resets on next snap
    }
  }

  // Spawn dots
  spawnTimer -= dt;
  if (spawnTimer <= 0) {
    spawnDot();
    spawnTimer = getSpawnInterval();
  }

  // Update dots (shrink toward center)
  const shrinkSpd = getShrinkSpeed();
  for (let i = dots.length - 1; i >= 0; i--) {
    const d = dots[i];
    if (!d.alive) { dots.splice(i, 1); continue; }
    d.age += dt;
    d.radius -= d.startRadius * shrinkSpd * dt;

    // Reached center
    if (d.radius <= 15) {
      d.alive = false;
      dots.splice(i, 1);
      // Center pop effect
      for (let j = 0; j < 8; j++) {
        const a = Math.random() * Math.PI * 2;
        particles.push({
          x: cx, y: cy,
          vx: Math.cos(a) * 60, vy: Math.sin(a) * 60,
          life: 0.4, maxLife: 0.4,
          hue: 0, size: 3
        });
      }
      loseLife();
    }
  }

  // Danger alpha (for dots close to center)
  let closestFrac = 1;
  for (const d of dots) {
    if (d.alive) {
      const f = d.radius / d.startRadius;
      if (f < closestFrac) closestFrac = f;
    }
  }
  const targetDanger = closestFrac < 0.3 ? (0.3 - closestFrac) * 3 : 0;
  dangerAlpha += (targetDanger - dangerAlpha) * dt * 4;

  // Pulse freeze cooldown
  if (pulseFreezeCooldown > 0) pulseFreezeCooldown -= dt;

  // Laser hazard (rare, late game)
  if (difficulty > 0.5) {
    if (!laserActive) {
      laserTimer -= dt;
      if (laserTimer <= 0) {
        laserActive = true;
        laserAngle = Math.random() * Math.PI;
        laserTimer = 2.5; // active duration
        laserAlpha = 0;
      }
    } else {
      laserTimer -= dt;
      // Fade in then out
      if (laserTimer > 2) laserAlpha = Math.min(1, laserAlpha + dt * 3);
      else if (laserTimer < 0.5) laserAlpha = Math.max(0, laserAlpha - dt * 3);
      else laserAlpha = 1;
      laserAngle += 0.4 * dt;
      if (laserTimer <= 0) {
        laserActive = false;
        laserTimer = 8 + Math.random() * 8; // cooldown
        laserAlpha = 0;
      }
    }
  }

  // Shake
  if (shakeDuration > 0) {
    shakeTime += dt;
    if (shakeTime >= shakeDuration) {
      shakeDuration = 0;
      shakeAmount = 0;
      shakeTime = 0;
    }
  }
}

// --- MAIN LOOP ---
function loop(ts) {
  requestAnimationFrame(loop);
  if (!lastTime) { lastTime = ts; return; }
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;
  elapsed = dt;

  // HSL cycling
  hueOffset = (hueOffset + 30 * dt) % 360;

  update(dt);

  // Apply shake
  ctx.save();
  if (shakeDuration > 0) {
    const intensity = shakeAmount * (1 - shakeTime / shakeDuration);
    const sx = (Math.random() - 0.5) * intensity * 2;
    const sy = (Math.random() - 0.5) * intensity * 2;
    ctx.translate(sx, sy);
  }

  drawBackground();

  if (state === START) {
    drawStartScreen();
    scoreDisplay.style.display = 'none';
    livesDisplay.style.display = 'none';
    comboDisplay.style.display = 'none';
  } else if (state === PLAYING) {
    scoreDisplay.style.display = 'block';
    livesDisplay.style.display = 'block';
    comboDisplay.style.display = 'block';
    drawComboRing();
    drawDots();
    drawCursor();
    drawLaser();
    drawTrails(dt);
    drawParticles(dt);
    drawShockwaves(dt);
    drawFloatingTexts(dt);
    drawDangerVignette();
  } else if (state === GAMEOVER) {
    scoreDisplay.style.display = 'block';
    livesDisplay.style.display = 'block';
    comboDisplay.style.display = 'none';
    drawDots();
    drawCursor();
    drawTrails(dt);
    drawParticles(dt);
    drawShockwaves(dt);
    drawFloatingTexts(dt);
    drawGameOverScreen();
  }

  ctx.restore();
}

requestAnimationFrame(loop);

})();
</script>
</body>
</html>