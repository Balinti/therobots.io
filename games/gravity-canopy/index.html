<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gravity Canopy - Free HTML5 Game</title>
<meta name="description" content="Play Gravity Canopy - Tap to merge falling number fruits as gravity flips through the jungle canopy.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#101018">
<!-- Open Graph -->
<meta property="og:type" content="website">
<meta property="og:title" content="Gravity Canopy - Free HTML5 Game">
<meta property="og:description" content="Tap to flip gravity and merge fruits in this addictive hyper-casual HTML5 game!">
<meta property="og:url" content="https://balinti.github.io/gravity-canopy/">
<meta property="og:image" content="https://balinti.github.io/gravity-canopy/og-image.png">
<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Gravity Canopy - Free HTML5 Game">
<meta name="twitter:description" content="Tap to flip gravity and merge fruits in this addictive hyper-casual HTML5 game!">
<meta name="twitter:image" content="https://balinti.github.io/gravity-canopy/og-image.png">
<!-- AdSense -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  html,body{width:100%;height:100%;background:#101018;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;overflow-x:hidden;font-family:system-ui,-apple-system,sans-serif}
  #wrap{position:relative;width:100%;max-width:420px;display:flex;flex-direction:column;align-items:center}
  canvas{display:block;width:100%;touch-action:none;cursor:pointer}
  #seo{width:100%;max-width:420px;padding:12px 16px 24px;color:#555;font-size:11px;line-height:1.6}
  #seo h2{font-size:12px;color:#666;margin-bottom:6px;font-weight:600}
  #seo details summary{cursor:pointer;color:#666;font-size:11px;margin-bottom:6px;user-select:none}
  #seo p,#seo ul{margin-bottom:6px}
  #seo ul{padding-left:16px}
  #seo a{color:#888}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
</div>
<div id="seo">
  <details>
    <summary>About Gravity Canopy &amp; FAQ</summary>
    <h2>How to Play</h2>
    <p>Tap or press Space to flip gravity. Flipping costs 1 fuel. Fruits drift from the sides and stack on the floor or ceiling. Match identical fruits to merge them into a higher tier, earning fuel. Don't let stacks overflow!</p>
    <h2>Tips</h2>
    <ul>
      <li>Plan merges before flipping â€” each flip costs fuel.</li>
      <li>Chain merges to earn bonus fuel and score multipliers.</li>
      <li>Danger lines creep inward as your score rises â€” keep stacks short!</li>
      <li>Share your best score to challenge friends.</li>
    </ul>
    <h2>Keywords</h2>
    <p>gravity game, fruit merge game, flip gravity HTML5, hyper casual game, browser game no download, free online game, canvas game, gravity canopy</p>
  </details>
</div>

<script>
(function(){
'use strict';

// â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const COLS = 7;
const MAX_FUEL = 3;
const LS_KEY = 'gcf_best';
const TIER_COLORS = [
  [40,90,60],   // tier1 orange-ish
  [75,85,58],   // tier2 yellow
  [120,80,55],  // tier3 green
  [180,75,55],  // tier4 cyan
  [270,80,60],  // tier5 purple
  [320,85,62],  // tier6 pink
  [0,90,58],    // tier7 red
];
const TIER_NAMES = ['ðŸŠ','ðŸ‹','ðŸ','ðŸ«','ðŸ‡','ðŸŒ¸','ðŸŽ'];
// Fruit sizes by tier (radius fraction of cell)
const TIER_R = [0.28, 0.32, 0.36, 0.40, 0.44, 0.48, 0.52];

// â”€â”€ Canvas setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, DPR, cellW, cellH, topPad, btmPad;

function resize(){
  const wrap = document.getElementById('wrap');
  const ww = Math.min(420, window.innerWidth);
  const wh = Math.min(750, window.innerHeight);
  W = ww; H = wh;
  DPR = window.devicePixelRatio || 1;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  canvas.width = Math.round(W * DPR);
  canvas.height = Math.round(H * DPR);
  ctx.scale(DPR, DPR);
  cellW = W / COLS;
  cellH = (H * 0.72) / 10; // playfield is 72% of height, 10 rows visible
  topPad = H * 0.14;
  btmPad = H * 0.14;
}
window.addEventListener('resize', ()=>{ resize(); if(state!=='playing') drawStatic(); });
resize();

// â”€â”€ Game state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let state = 'start'; // 'start' | 'playing' | 'gameover'
let gravDown = true;    // true = gravity pulls down
let score = 0;
let best = parseInt(localStorage.getItem(LS_KEY)||'0',10);
let fuel = MAX_FUEL;
let t = 0;           // elapsed seconds
let lastTime = 0;
let hue = 0;         // background hue cycling

// Stacks: two arrays of length COLS
// bottomStacks[col] = array of tier numbers (bottom face, grows upward)
// topStacks[col] = array of tier numbers (top face, grows downward)
let bottomStacks, topStacks;

// Active falling fruit
let fallingFruit = null; // {col, tier, x, y, vy, fromTop}
let spawnTimer = 0;
let spawnInterval = 1.15;

// Danger lines (fraction from edges inward, 0..0.5)
let dangerFrac = 0.05;

// Particles
let particles = [];
// Chain labels
let chainLabels = [];
// Screen shake
let shakeAmt = 0, shakeDX = 0, shakeDY = 0;
// Ring waves
let rings = [];

// Challenge from URL
let challengeScore = 0;
const urlParams = new URLSearchParams(window.location.search);
if(urlParams.get('challenge')) challengeScore = parseInt(urlParams.get('challenge'),10)||0;

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function clamp(v,lo,hi){ return v<lo?lo:v>hi?hi:v; }
function rnd(a,b){ return a + Math.random()*(b-a); }

function playfield(){
  // Returns {y0, y1} of playfield (between danger lines)
  const playH = H - topPad - btmPad;
  const dangerPx = dangerFrac * playH;
  return {
    y0: topPad + dangerPx,          // top danger line (stacks from top grow down to here)
    y1: H - btmPad - dangerPx,      // bottom danger line (stacks from bottom grow up to here)
    playH,
    dangerPx
  };
}

function stackHeight(stack){ return stack.length; }

function maxRowsAllowed(){
  // How many rows fit between danger lines
  const {y0,y1} = playfield();
  return Math.floor((y1-y0)/cellH);
}

function getSpawnInterval(){
  const D = 1 + 0.018*t + 0.00035*score;
  return clamp(0.55, 1.15, 1.15 - 0.06*D);
}

function getTierCap(){
  return Math.min(5, Math.floor(1 + score/450));
}

function weightedTier(){
  const cap = getTierCap();
  let weights = [];
  for(let i=0;i<cap;i++) weights.push(Math.exp(-0.9*i));
  const sum = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*sum;
  for(let i=0;i<cap;i++){
    r -= weights[i];
    if(r<=0) return i;
  }
  return cap-1;
}

function fuelGain(chain){
  return clamp(0.35, 0.85, 0.65 - 0.00012*score) + 0.15*(chain-1);
}

function addFuel(amount){
  fuel = Math.min(MAX_FUEL, fuel + amount);
}

// â”€â”€ Particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnParticles(x, y, tier, count){
  const [h,s,l] = TIER_COLORS[tier % TIER_COLORS.length];
  for(let i=0;i<count;i++){
    const angle = rnd(0, Math.PI*2);
    const speed = rnd(40, 140);
    particles.push({
      x, y,
      vx: Math.cos(angle)*speed,
      vy: Math.sin(angle)*speed,
      life: 1,
      decay: rnd(1.2, 2.2),
      r: rnd(3,8),
      h, s, l
    });
  }
}

function spawnRing(x, y, tier){
  const [h,s,l] = TIER_COLORS[tier % TIER_COLORS.length];
  rings.push({x, y, r:0, maxR: cellW*1.8, life:1, h, s, l});
}

function spawnChainLabel(x, y, chain){
  chainLabels.push({x, y, chain, life:1, vy:-60});
}

function applyShake(amt){
  shakeAmt = Math.max(shakeAmt, amt);
}

// â”€â”€ Init / Reset â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initGame(){
  gravDown = true;
  score = 0;
  fuel = MAX_FUEL;
  t = 0;
  hue = 0;
  bottomStacks = Array.from({length:COLS},()=>[]);
  topStacks    = Array.from({length:COLS},()=>[]);
  fallingFruit = null;
  spawnTimer = 0;
  particles = [];
  chainLabels = [];
  rings = [];
  shakeAmt = 0;
  dangerFrac = 0.05;
  lastTime = performance.now();
}

// â”€â”€ Spawn fruit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnFruit(){
  const tier = weightedTier();
  // Bias: if a column has the same tier on top of its stack, prefer that column
  let col;
  const activeSide = gravDown ? bottomStacks : topStacks;
  const candidates = [];
  for(let c=0;c<COLS;c++){
    const st = activeSide[c];
    if(st.length > 0 && st[st.length-1] === tier) candidates.push(c);
  }
  if(candidates.length && Math.random() < 0.45){
    col = candidates[Math.floor(Math.random()*candidates.length)];
  } else {
    col = Math.floor(Math.random()*COLS);
  }

  // Fruit comes from left or right
  const fromLeft = Math.random() < 0.5;
  const x = fromLeft ? -cellW/2 : W + cellW/2;
  const targetX = col * cellW + cellW/2;
  // Travel in a short arc to target column
  fallingFruit = {
    col, tier,
    x, y: gravDown ? topPad + cellH*0.5 : H - btmPad - cellH*0.5,
    targetX,
    vx: fromLeft ? 280 : -280,
    vy: 0,
    fromLeft,
    landed: false
  };
}

// â”€â”€ Merge logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let chainCount = 0;

function tryMerge(stacks, col){
  const st = stacks[col];
  if(st.length < 2) return false;
  const top = st[st.length-1];
  const below = st[st.length-2];
  if(top !== below) return false;
  // Merge!
  st.pop(); st.pop();
  const newTier = Math.min(top+1, TIER_COLORS.length-1);
  st.push(newTier);
  // Position for effects
  const cx = col*cellW + cellW/2;
  const stackIndex = st.length-1;
  let cy;
  if(stacks === bottomStacks){
    cy = (H - btmPad) - (stackIndex+0.5)*cellH;
  } else {
    cy = topPad + (stackIndex+0.5)*cellH;
  }
  spawnParticles(cx, cy, newTier, 12);
  spawnRing(cx, cy, newTier);
  chainCount++;
  spawnChainLabel(cx, cy - 20, chainCount);
  const fg = fuelGain(chainCount);
  addFuel(fg);
  score += 10 * chainCount * (newTier+1);
  applyShake(chainCount > 1 ? 4 : 2);
  return true;
}

function processLanding(col){
  // Called after fruit lands in col
  chainCount = 0;
  let merged = true;
  const stacks = gravDown ? bottomStacks : topStacks;
  while(merged){ merged = tryMerge(stacks, col); }
  // Also cascade check neighbours (simple)
}

// â”€â”€ Overflow check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkOverflow(){
  const maxRows = maxRowsAllowed();
  // Check if any bottom stack + top stack in same column overflows
  for(let c=0;c<COLS;c++){
    if(bottomStacks[c].length + topStacks[c].length > maxRows){
      return true;
    }
  }
  // Also check if any single stack exceeds half the field
  const halfMax = Math.floor(maxRows / 2);
  for(let c=0;c<COLS;c++){
    if(bottomStacks[c].length > halfMax + 1 || topStacks[c].length > halfMax + 1) return true;
  }
  return false;
}

// â”€â”€ Flip gravity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function flipGravity(){
  if(fuel < 1) return;
  fuel -= 1;
  gravDown = !gravDown;
  applyShake(3);
  // If fruit is in flight, flip its vertical position
  if(fallingFruit && !fallingFruit.landed){
    fallingFruit.y = gravDown
      ? topPad + cellH*0.5
      : H - btmPad - cellH*0.5;
  }
}

// â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleInput(){
  if(state === 'start'){ state='playing'; initGame(); return; }
  if(state === 'gameover'){ state='start'; return; }
  if(state === 'playing'){ flipGravity(); }
}

canvas.addEventListener('pointerdown', e=>{ e.preventDefault(); handleInput(); });
window.addEventListener('keydown', e=>{
  if(e.code==='Space'||e.code==='Enter'){ e.preventDefault(); handleInput(); }
});

// â”€â”€ Share â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function doShare(){
  const url = `${location.origin}${location.pathname}?challenge=${score}`;
  const text = `I scored ${score} in Gravity Canopy! Can you beat me? ðŸŠðŸ‹ðŸ`;
  if(navigator.share){
    navigator.share({title:'Gravity Canopy', text, url}).catch(()=>{});
  } else {
    navigator.clipboard && navigator.clipboard.writeText(url).then(()=>{
      showShareToast = true; shareToastTimer = 2;
    }).catch(()=>{});
  }
}

let showShareToast = false, shareToastTimer = 0;
let shareButtonRect = null; // {x,y,w,h} in canvas coords

canvas.addEventListener('click', e=>{
  if(state!=='gameover') return;
  if(!shareButtonRect) return;
  const rect = canvas.getBoundingClientRect();
  const sx = (e.clientX - rect.left) * (W / rect.width);
  const sy = (e.clientY - rect.top)  * (H / rect.height);
  if(sx>=shareButtonRect.x && sx<=shareButtonRect.x+shareButtonRect.w &&
     sy>=shareButtonRect.y && sy<=shareButtonRect.y+shareButtonRect.h){
    doShare();
  }
});

// â”€â”€ Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update(dt){
  if(state!=='playing') return;
  t += dt;
  hue = (hue + 8*dt) % 360;

  // Update danger lines
  dangerFrac = 0.05 + Math.floor(score/500)*0.025;
  dangerFrac = Math.min(dangerFrac, 0.3);

  // Spawn
  spawnTimer -= dt;
  if(!fallingFruit && spawnTimer <= 0){
    spawnInterval = getSpawnInterval();
    spawnTimer = spawnInterval;
    spawnFruit();
  }

  // Move falling fruit
  if(fallingFruit && !fallingFruit.landed){
    const f = fallingFruit;
    // Move horizontally toward target
    const dx = f.targetX - f.x;
    if(Math.abs(dx) > 4){
      f.x += Math.sign(dx) * Math.min(Math.abs(f.vx)*dt, Math.abs(dx));
    } else {
      f.x = f.targetX;
    }
    // Once aligned, drop
    if(Math.abs(f.x - f.targetX) < 2){
      if(gravDown){
        // Fall down: target y = top of bottom stack
        const st = bottomStacks[f.col];
        const targetY = (H - btmPad) - (st.length + 0.5)*cellH;
        f.vy += 900*dt;
        f.y += f.vy*dt;
        if(f.y >= targetY){
          f.y = targetY;
          st.push(f.tier);
          spawnParticles(f.x, f.y, f.tier, 6);
          processLanding(f.col);
          fallingFruit = null;
          if(checkOverflow()) endGame();
        }
      } else {
        // Fall up: target y = bottom of top stack
        const st = topStacks[f.col];
        const targetY = topPad + (st.length + 0.5)*cellH;
        f.vy -= 900*dt;
        f.y += f.vy*dt;
        if(f.y <= targetY){
          f.y = targetY;
          st.push(f.tier);
          spawnParticles(f.x, f.y, f.tier, 6);
          processLanding(f.col);
          fallingFruit = null;
          if(checkOverflow()) endGame();
        }
      }
    }
  }

  // Particles
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx*dt; p.y += p.vy*dt;
    p.vy += 200*dt;
    p.life -= p.decay*dt;
    if(p.life<=0) particles.splice(i,1);
  }

  // Rings
  for(let i=rings.length-1;i>=0;i--){
    const r=rings[i];
    r.r += 180*dt;
    r.life -= 2*dt;
    if(r.life<=0) rings.splice(i,1);
  }

  // Chain labels
  for(let i=chainLabels.length-1;i>=0;i--){
    const cl=chainLabels[i];
    cl.y += cl.vy*dt;
    cl.life -= 1.5*dt;
    if(cl.life<=0) chainLabels.splice(i,1);
  }

  // Shake decay
  if(shakeAmt > 0){
    shakeAmt *= Math.pow(0.01, dt);
    if(shakeAmt<0.1) shakeAmt=0;
    shakeDX = (Math.random()-0.5)*shakeAmt*2;
    shakeDY = (Math.random()-0.5)*shakeAmt*2;
  } else { shakeDX=0; shakeDY=0; }

  // Toast
  if(showShareToast){
    shareToastTimer -= dt;
    if(shareToastTimer<=0){ showShareToast=false; }
  }
}

// â”€â”€ End game â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let newBest = false;
function endGame(){
  state = 'gameover';
  newBest = score > best;
  if(newBest){ best = score; localStorage.setItem(LS_KEY, best); }
  applyShake(18);
  spawnParticles(W/2, H/2, 0, 30);
  fallingFruit = null;
}

// â”€â”€ Draw helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawRoundRect(x,y,w,h,r,fill,stroke){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y);
  ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r);
  ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h);
  ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
  if(fill){ ctx.fillStyle=fill; ctx.fill(); }
  if(stroke){ ctx.strokeStyle=stroke; ctx.stroke(); }
}

function drawFruit(x, y, tier, alpha){
  const r = cellW * TIER_R[Math.min(tier, TIER_R.length-1)];
  const [h,s,l] = TIER_COLORS[tier % TIER_COLORS.length];
  ctx.save();
  ctx.globalAlpha = alpha||1;
  // Glow
  const grd = ctx.createRadialGradient(x,y,r*0.1,x,y,r*1.4);
  grd.addColorStop(0,`hsla(${h},${s}%,${l+15}%,0.4)`);
  grd.addColorStop(1,`hsla(${h},${s}%,${l}%,0)`);
  ctx.fillStyle = grd;
  ctx.beginPath(); ctx.arc(x,y,r*1.4,0,Math.PI*2); ctx.fill();
  // Body
  const bodyGrd = ctx.createRadialGradient(x-r*0.25,y-r*0.25,r*0.05,x,y,r);
  bodyGrd.addColorStop(0,`hsl(${h},${s}%,${l+20}%)`);
  bodyGrd.addColorStop(0.7,`hsl(${h},${s}%,${l}%)`);
  bodyGrd.addColorStop(1,`hsl(${h},${s}%,${l-15}%)`);
  ctx.fillStyle = bodyGrd;
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  // Shine
  ctx.fillStyle = `rgba(255,255,255,0.35)`;
  ctx.beginPath(); ctx.ellipse(x-r*0.28,y-r*0.28,r*0.32,r*0.2,-0.5,0,Math.PI*2); ctx.fill();
  // Label
  ctx.globalAlpha = alpha||1;
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.round(r*0.9)}px system-ui`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(TIER_NAMES[tier % TIER_NAMES.length], x, y+1);
  ctx.restore();
}

// â”€â”€ Draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function draw(){
  ctx.save();
  if(shakeAmt>0) ctx.translate(shakeDX, shakeDY);

  // Background gradient
  const bg = ctx.createLinearGradient(0,0,0,H);
  bg.addColorStop(0, `hsl(${hue},25%,8%)`);
  bg.addColorStop(1, `hsl(${(hue+60)%360},30%,12%)`);
  ctx.fillStyle = bg;
  ctx.fillRect(0,0,W,H);

  // Jungle vine decorations (subtle)
  ctx.strokeStyle = `hsla(${(hue+120)%360},40%,25%,0.18)`;
  ctx.lineWidth = 2;
  for(let i=0;i<COLS+1;i++){
    const x = i*cellW;
    ctx.beginPath();
    ctx.moveTo(x, topPad);
    ctx.lineTo(x, H - btmPad);
    ctx.stroke();
  }

  const {y0, y1} = playfield();

  // Danger zone shading
  ctx.fillStyle = `rgba(255,50,50,0.06)`;
  ctx.fillRect(0, topPad, W, y0 - topPad);
  ctx.fillRect(0, y1, W, H - btmPad - y1);

  // Danger lines
  ctx.strokeStyle = `rgba(255,80,80,0.5)`;
  ctx.lineWidth = 1.5;
  ctx.setLineDash([6,4]);
  ctx.beginPath(); ctx.moveTo(0,y0); ctx.lineTo(W,y0); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,y1); ctx.lineTo(W,y1); ctx.stroke();
  ctx.setLineDash([]);

  // Draw stacks
  for(let c=0;c<COLS;c++){
    const cx = c*cellW + cellW/2;
    // Bottom stacks (grow upward)
    for(let i=0;i<bottomStacks[c].length;i++){
      const tier = bottomStacks[c][i];
      const sy = (H - btmPad) - (i+0.5)*cellH;
      drawFruit(cx, sy, tier, 1);
    }
    // Top stacks (grow downward)
    for(let i=0;i<topStacks[c].length;i++){
      const tier = topStacks[c][i];
      const sy = topPad + (i+0.5)*cellH;
      drawFruit(cx, sy, tier, 1);
    }
  }

  // Falling fruit
  if(fallingFruit && !fallingFruit.landed){
    const f = fallingFruit;
    drawFruit(f.x, f.y, f.tier, 0.95);
    // Ghost column indicator
    const targetX = f.col * cellW + cellW/2;
    ctx.strokeStyle = `rgba(255,255,255,0.1)`;
    ctx.lineWidth = cellW - 4;
    ctx.beginPath(); ctx.moveTo(targetX, y0); ctx.lineTo(targetX, y1); ctx.stroke();
    ctx.lineWidth = 1;
  }

  // Particles
  for(const p of particles){
    ctx.save();
    ctx.globalAlpha = Math.max(0,p.life);
    ctx.fillStyle = `hsl(${p.h},${p.s}%,${p.l}%)`;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // Rings
  for(const r of rings){
    ctx.save();
    ctx.globalAlpha = Math.max(0,r.life*0.6);
    ctx.strokeStyle = `hsl(${r.h},${r.s}%,${r.l}%)`;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  // Chain labels
  for(const cl of chainLabels){
    ctx.save();
    ctx.globalAlpha = Math.max(0,cl.life);
    ctx.fillStyle = `hsl(${(hue+40)%360},90%,75%)`;
    ctx.font = `bold ${18+cl.chain*3}px system-ui`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`CHAIN x${cl.chain}`, cl.x, cl.y);
    ctx.restore();
  }

  // â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Top bar
  drawRoundRect(8, 8, W-16, topPad-16, 10, 'rgba(0,0,0,0.45)', null);

  // Score
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.round(H*0.045)}px system-ui`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(score, W/2, topPad/2);

  // Best
  ctx.fillStyle = `hsl(${(hue+40)%360},80%,65%)`;
  ctx.font = `${Math.round(H*0.026)}px system-ui`;
  ctx.fillText(`BEST ${best}`, W/2, topPad/2 + H*0.033);

  // Challenge
  if(challengeScore > 0 && state === 'start'){
    ctx.fillStyle = `hsl(${(hue+180)%360},80%,70%)`;
    ctx.font = `bold ${Math.round(H*0.03)}px system-ui`;
    ctx.fillText(`Beat ${challengeScore}`, W/2, topPad/2 + H*0.062);
  }

  // Fuel gauge (bottom bar)
  drawRoundRect(8, H-btmPad+8, W-16, btmPad-16, 10, 'rgba(0,0,0,0.45)', null);

  // Fuel label
  ctx.fillStyle = `rgba(255,255,255,0.6)`;
  ctx.font = `${Math.round(H*0.022)}px system-ui`;
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  ctx.fillText('FUEL', 24, H - btmPad/2 - 8);

  // Gravity direction indicator
  ctx.fillStyle = `hsl(${(hue+200)%360},70%,65%)`;
  ctx.font = `bold ${Math.round(H*0.03)}px system-ui`;
  ctx.textAlign = 'right';
  ctx.fillText(gravDown ? 'â–¼ DOWN' : 'â–² UP', W-24, H - btmPad/2 - 8);

  // Fuel pips
  const pipW = (W - 48) / MAX_FUEL - 8;
  const pipH = 14;
  const pipY = H - btmPad/2 + 6;
  for(let i=0;i<MAX_FUEL;i++){
    const px = 24 + i*(pipW+8);
    const filled = fuel >= i+1;
    const partialFill = fuel > i ? fuel - i : 0; // for fractional fuel
    drawRoundRect(px, pipY-pipH/2, pipW, pipH, 4,
      'rgba(255,255,255,0.1)', null);
    if(partialFill > 0){
      const fw = Math.min(1, partialFill) * pipW;
      ctx.save();
      ctx.beginPath();
      ctx.rect(px, pipY-pipH/2, fw, pipH);
      ctx.clip();
      drawRoundRect(px, pipY-pipH/2, pipW, pipH, 4,
        `hsl(${(hue+80)%360},80%,55%)`, null);
      ctx.restore();
    }
  }

  // Tap hint during play
  if(state==='playing' && t < 3){
    const alpha = Math.min(1, (3-t)/1.5);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle='rgba(255,255,255,0.7)';
    ctx.font=`${Math.round(H*0.028)}px system-ui`;
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.fillText('TAP TO FLIP GRAVITY', W/2, H/2 + H*0.08);
    ctx.restore();
  }

  // â”€â”€ START screen overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if(state === 'start'){
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle=`hsl(${hue},70%,60%)`;
    ctx.font=`bold ${Math.round(H*0.072)}px system-ui`;
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.fillText('GRAVITY', W/2, H/2 - H*0.12);
    ctx.fillStyle='#fff';
    ctx.fillText('CANOPY', W/2, H/2 - H*0.055);

    ctx.fillStyle=`rgba(255,255,255,0.7)`;
    ctx.font=`${Math.round(H*0.03)}px system-ui`;
    ctx.fillText('Tap/Space to flip gravity', W/2, H/2 + H*0.01);
    ctx.fillText('Merge fruits to earn fuel', W/2, H/2 + H*0.05);

    if(challengeScore > 0){
      ctx.fillStyle=`hsl(${(hue+60)%360},80%,65%)`;
      ctx.font=`bold ${Math.round(H*0.035)}px system-ui`;
      ctx.fillText(`CHALLENGE: Beat ${challengeScore}`, W/2, H/2 + H*0.1);
    }

    // Animated tap indicator
    const pulse = 0.85 + 0.15*Math.sin(Date.now()/400);
    drawRoundRect(W/2-80, H/2+H*0.15, 160, 44, 22,
      `hsla(${hue},70%,55%,${pulse})`, null);
    ctx.fillStyle='#fff';
    ctx.font=`bold ${Math.round(H*0.032)}px system-ui`;
    ctx.fillText('TAP TO START', W/2, H/2 + H*0.15 + 22);

    // Fruit preview row
    const previewY = H/2 - H*0.21;
    for(let i=0;i<Math.min(5,TIER_NAMES.length);i++){
      drawFruit(W/2 + (i-2)*cellW*0.9, previewY, i, 1);
    }
  }

  // â”€â”€ GAMEOVER overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if(state === 'gameover'){
    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle=`hsl(${hue},80%,62%)`;
    ctx.font=`bold ${Math.round(H*0.065)}px system-ui`;
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.fillText('GAME OVER', W/2, H/2 - H*0.14);

    ctx.fillStyle='#fff';
    ctx.font=`bold ${Math.round(H*0.055)}px system-ui`;
    ctx.fillText(score, W/2, H/2 - H*0.06);

    ctx.fillStyle=`rgba(255,255,255,0.6)`;
    ctx.font=`${Math.round(H*0.028)}px system-ui`;
    if(newBest){
      ctx.fillStyle=`hsl(${(hue+60)%360},90%,65%)`;
      ctx.fillText('NEW BEST!', W/2, H/2 - H*0.01);
    } else {
      ctx.fillText(`Best: ${best}`, W/2, H/2 - H*0.01);
    }

    // Share button (only on new best)
    if(newBest){
      const sbX = W/2-70, sbY = H/2+H*0.04, sbW=140, sbH=40;
      drawRoundRect(sbX, sbY, sbW, sbH, 20,
        `hsl(${(hue+100)%360},70%,50%)`, null);
      ctx.fillStyle='#fff';
      ctx.font=`bold ${Math.round(H*0.028)}px system-ui`;
      ctx.fillText('SHARE', W/2, sbY+sbH/2);
      shareButtonRect = {x:sbX,y:sbY,w:sbW,h:sbH};
    } else {
      shareButtonRect = null;
    }

    // Restart button
    const rbX = W/2-70, rbY = H/2+H*0.11, rbW=140, rbH=40;
    const pulse2 = 0.85+0.15*Math.sin(Date.now()/400);
    drawRoundRect(rbX, rbY, rbW, rbH, 20,
      `hsla(${hue},65%,50%,${pulse2})`, null);
    ctx.fillStyle='#fff';
    ctx.font=`bold ${Math.round(H*0.028)}px system-ui`;
    ctx.fillText('PLAY AGAIN', W/2, rbY+rbH/2);

    // Share toast
    if(showShareToast){
      ctx.fillStyle='rgba(0,0,0,0.8)';
      ctx.fillRect(W/2-80, H-btmPad-50, 160, 32);
      ctx.fillStyle='#fff';
      ctx.font=`${Math.round(H*0.025)}px system-ui`;
      ctx.fillText('Link copied!', W/2, H-btmPad-34);
    }
  }

  ctx.restore();
}

// â”€â”€ Static draw (before game starts) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawStatic(){
  hue = (hue + 0.5) % 360;
  const bg = ctx.createLinearGradient(0,0,0,H);
  bg.addColorStop(0,`hsl(${hue},25%,8%)`);
  bg.addColorStop(1,`hsl(${(hue+60)%360},30%,12%)`);
  ctx.fillStyle=bg;
  ctx.fillRect(0,0,W,H);
  draw();
}

// â”€â”€ Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let animId;
function loop(ts){
  animId = requestAnimationFrame(loop);
  const dt = Math.min(0.05, (ts - lastTime) / 1000);
  lastTime = ts;
  hue = (hue + 8 * dt) % 360;

  if(state === 'playing'){
    update(dt);
  }
  draw();
}

lastTime = performance.now();
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
