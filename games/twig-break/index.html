<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Twig Break - Free HTML5 Game</title>
  <meta name="description" content="Play Twig Break - Swipe to hit branches that grow and shrink unpredictably in a dense forest.">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#1a0a2e">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Twig Break - Free HTML5 Game">
  <meta property="og:description" content="Play Twig Break - Swipe to hit branches that grow and shrink unpredictably in a dense forest.">
  <meta property="og:url" content="https://balinti.github.io/twig-break/">
  <meta property="og:image" content="https://balinti.github.io/twig-break/preview.png">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Twig Break - Free HTML5 Game">
  <meta name="twitter:description" content="Play Twig Break - Swipe to hit branches that grow and shrink unpredictably in a dense forest.">
  <meta name="twitter:image" content="https://balinti.github.io/twig-break/preview.png">

  <!-- AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%;
      background: #0d0618;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: system-ui, sans-serif;
      overflow: hidden;
      touch-action: none;
    }
    #wrapper {
      position: relative;
      width: 100%;
      max-width: 420px;
      height: 100vh;
      max-height: 750px;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }
    #ui {
      position: absolute;
      top: 12px;
      left: 0; right: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 16px;
      pointer-events: none;
      z-index: 2;
    }
    #score-display {
      font-size: 22px;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 0 12px rgba(255,200,100,0.8);
      letter-spacing: 1px;
    }
    #mute-btn {
      pointer-events: all;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 8px;
      color: #fff;
      font-size: 18px;
      padding: 4px 10px;
      cursor: pointer;
      user-select: none;
    }
    #seo-section {
      width: 100%;
      max-width: 420px;
      background: rgba(0,0,0,0.4);
      color: rgba(255,255,255,0.45);
      font-size: 11px;
      line-height: 1.5;
      padding: 6px 12px;
      text-align: center;
    }
    #seo-section h2 { font-size: 12px; margin-bottom: 2px; color: rgba(255,255,255,0.6); }
  </style>
</head>
<body>
<div id="wrapper">
  <div id="ui">
    <div id="score-display">0</div>
    <button id="mute-btn" aria-label="Toggle sound">ðŸ”Š</button>
  </div>
  <canvas id="c"></canvas>
</div>
<div id="seo-section">
  <h2>How to Play Twig Break</h2>
  Tap or press Space/Enter to snap branches at their peak pulse. Chain combos for huge scores!
  Miss three times and it's game over. Ball gets faster as you progress!
</div>

<script>
(function(){
'use strict';

// â”€â”€â”€ Canvas setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const wrapper = document.getElementById('wrapper');
const canvas  = document.getElementById('c');
const ctx     = canvas.getContext('2d');
const scoreEl = document.getElementById('score-display');
const muteBtn = document.getElementById('mute-btn');

let W = 0, H = 0;
const DPR = Math.min(window.devicePixelRatio || 1, 2);

function resize() {
  const r = wrapper.getBoundingClientRect();
  W = r.width; H = r.height;
  canvas.width  = Math.round(W * DPR);
  canvas.height = Math.round(H * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
resize();
window.addEventListener('resize', resize);

// â”€â”€â”€ Audio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let audioCtx = null;
let muted = false;
let audioReady = false;

function initAudio() {
  if (audioReady) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  audioReady = true;
}

function playSnap(freq = 220, gain = 0.3) {
  if (muted || !audioReady || !audioCtx) return;
  try {
    const osc = audioCtx.createOscillator();
    const g   = audioCtx.createGain();
    osc.connect(g); g.connect(audioCtx.destination);
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(freq * 0.2, audioCtx.currentTime + 0.15);
    g.gain.setValueAtTime(gain, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
    osc.start(); osc.stop(audioCtx.currentTime + 0.2);
  } catch(e){}
}

function playMiss() {
  if (muted || !audioReady || !audioCtx) return;
  try {
    const osc = audioCtx.createOscillator();
    const g   = audioCtx.createGain();
    osc.connect(g); g.connect(audioCtx.destination);
    osc.type = 'square';
    osc.frequency.setValueAtTime(80, audioCtx.currentTime);
    g.gain.setValueAtTime(0.2, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
    osc.start(); osc.stop(audioCtx.currentTime + 0.3);
  } catch(e){}
}

muteBtn.addEventListener('click', e => {
  e.stopPropagation();
  muted = !muted;
  muteBtn.textContent = muted ? 'ðŸ”‡' : 'ðŸ”Š';
});

// â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BEST_KEY    = 'twigbreak_best_v1';
const ARENA_PAD   = 20;
const GROUND_Y_R  = 0.88; // fraction of H
const CEIL_Y_R    = 0.10;
const TRAIL_LEN   = 22;
const MAX_STRIKES = 3;

// â”€â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let state      = 'start'; // start | playing | gameover
let score      = 0;
let bestScore  = parseInt(localStorage.getItem(BEST_KEY) || '0');
let combo      = 0;
let comboTimer = 0;
let strikes    = 0;
let difficulty = 0; // 0..1 ramps over time
let gameTime   = 0;
let lastTime   = 0;

let shakeAmp = 0, shakeDur = 0;
let flashAlpha = 0;
let bgHue = 260;

// Ball
let ball = { x:0, y:0, vx:0, vy:0, r:10, hue:40, trail:[] };

// Branches
let branches = [];

// Particles
let particles = [];

// â”€â”€â”€ Branch pulse math â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// phase goes 0..2PI; peak at PI/2; visible at any phase, "peak" window is tight
function branchPulse(b, t) {
  return 0.5 + 0.5 * Math.sin(b.phase + t * b.speed);
}

// â”€â”€â”€ Init / Reset â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resetGame() {
  score      = 0;
  combo      = 0;
  comboTimer = 0;
  strikes    = 0;
  difficulty = 0;
  gameTime   = 0;
  shakeAmp   = 0;
  shakeDur   = 0;
  flashAlpha = 0;
  bgHue      = 260;
  particles  = [];

  const groundY = H * GROUND_Y_R;
  const ceilY   = H * CEIL_Y_R;
  // Ball starts center-ish
  ball = {
    x:  W * 0.5,
    y:  ceilY + (groundY - ceilY) * 0.3,
    vx: (W * 0.003) * (Math.random() > 0.5 ? 1 : -1),
    vy: H * 0.004,
    r:  Math.min(10, W * 0.024),
    hue: 40,
    trail: []
  };

  spawnBranches();
}

function spawnBranches() {
  branches = [];
  const count = 5 + Math.floor(difficulty * 7);
  const groundY = H * GROUND_Y_R;
  const ceilY   = H * CEIL_Y_R;
  const arenaH  = groundY - ceilY;
  const arenaW  = W - ARENA_PAD * 2;

  for (let i = 0; i < count; i++) {
    const stiff = difficulty > 0.4 && Math.random() < 0.25;
    const twoTempo = difficulty > 0.6 && Math.random() < 0.2;
    branches.push({
      // position on wall or floating
      x:    ARENA_PAD + Math.random() * arenaW,
      y:    ceilY + 0.15 * arenaH + Math.random() * arenaH * 0.7,
      phase: Math.random() * Math.PI * 2,
      speed: (1.2 + difficulty * 1.4 + Math.random() * 0.8) * (twoTempo ? 2 : 1),
      len:  30 + Math.random() * 40,
      angle: Math.random() * Math.PI,
      hue:  90 + Math.random() * 60,
      hits:  stiff ? 2 : 1,
      maxHits: stiff ? 2 : 1,
      cracked: false,
      dead: false,
      id: Math.random()
    });
  }
}

// â”€â”€â”€ Difficulty â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function peakEpsilon() {
  // how wide the "peak" window is (0..1 of pulse value)
  return Math.max(0.07, 0.22 - difficulty * 0.15);
}

function isPeak(b, t) {
  const p = branchPulse(b, t);
  return p >= (1 - peakEpsilon());
}

// â”€â”€â”€ Player action â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function playerAction() {
  if (state === 'start') {
    state = 'playing';
    lastTime = performance.now();
    return;
  }
  if (state === 'gameover') {
    state = 'playing';
    resetGame();
    lastTime = performance.now();
    return;
  }
  // playing
  let snapped = 0;
  branches.forEach(b => {
    if (b.dead) return;
    if (isPeak(b, gameTime)) {
      b.hits--;
      if (b.hits <= 0) {
        b.dead = true;
        spawnParticles(b);
        snapped++;
      } else {
        b.cracked = true;
        playSnap(300, 0.2);
      }
    }
  });

  if (snapped > 0) {
    const points = snapped * 10 * (1 + combo * 0.5);
    score += Math.floor(points);
    combo++;
    comboTimer = 3.5;
    bgHue = (bgHue + 15) % 360;
    playSnap(180 + combo * 30, 0.35);

    // recoil nudge toward nearest unsnapped branch
    nudgeBall();

    if (snapped >= 2) triggerShake(6, 0.35);
    else              triggerShake(3, 0.2);

    if (combo >= 3) flashAlpha = 0.18;

    // check win-ish: respawn branches if all gone
    const alive = branches.filter(b => !b.dead);
    if (alive.length === 0) {
      difficulty = Math.min(1, difficulty + 0.12);
      spawnBranches();
      triggerShake(8, 0.5);
      flashAlpha = 0.3;
    }
  } else {
    // miss
    strikes++;
    combo = 0;
    comboTimer = 0;
    playMiss();
    triggerShake(5, 0.3);
    if (strikes >= MAX_STRIKES) {
      endGame();
    }
  }
}

function nudgeBall() {
  const alive = branches.filter(b => !b.dead);
  if (!alive.length) return;
  let nearest = null, minD = Infinity;
  alive.forEach(b => {
    const d = Math.hypot(b.x - ball.x, b.y - ball.y);
    if (d < minD) { minD = d; nearest = b; }
  });
  if (nearest) {
    const dx = nearest.x - ball.x;
    const dy = nearest.y - ball.y;
    const len = Math.hypot(dx, dy) || 1;
    const nudge = Math.min(W * 0.003, 2);
    ball.vx += (dx / len) * nudge;
    ball.vy += (dy / len) * nudge;
    // cap speed
    const spd = Math.hypot(ball.vx, ball.vy);
    const maxSpd = W * 0.012 + difficulty * W * 0.006;
    if (spd > maxSpd) {
      ball.vx = (ball.vx / spd) * maxSpd;
      ball.vy = (ball.vy / spd) * maxSpd;
    }
  }
}

function endGame() {
  state = 'gameover';
  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem(BEST_KEY, bestScore);
  }
  triggerShake(12, 0.7);
  flashAlpha = 0.5;
}

// â”€â”€â”€ Particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnParticles(b) {
  const count = 10 + Math.floor(Math.random() * 8);
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd   = 1.5 + Math.random() * 4;
    const isChip = i < count * 0.6;
    particles.push({
      x: b.x, y: b.y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd - 2,
      life: 1,
      decay: 0.018 + Math.random() * 0.02,
      hue: b.hue + (Math.random() - 0.5) * 30,
      size: isChip ? (3 + Math.random() * 5) : (4 + Math.random() * 6),
      rotation: Math.random() * Math.PI * 2,
      rotSpd: (Math.random() - 0.5) * 0.2,
      isChip
    });
  }
}

// â”€â”€â”€ Shake â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function triggerShake(amp, dur) {
  shakeAmp = Math.max(shakeAmp, amp);
  shakeDur = Math.max(shakeDur, dur);
}

// â”€â”€â”€ Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update(dt) {
  if (state !== 'playing') return;

  gameTime += dt;
  difficulty = Math.min(1, gameTime / 120); // max diff at 2 min

  // combo timer
  if (comboTimer > 0) {
    comboTimer -= dt;
    if (comboTimer <= 0) { combo = 0; comboTimer = 0; }
  }

  // ball speed ramp
  const baseSpd = W * 0.006 + difficulty * W * 0.005;
  const spd = Math.hypot(ball.vx, ball.vy);
  if (spd < baseSpd) {
    const s = baseSpd / (spd || 0.001);
    ball.vx *= s; ball.vy *= s;
  }

  // trail
  ball.trail.push({ x: ball.x, y: ball.y });
  if (ball.trail.length > TRAIL_LEN) ball.trail.shift();

  // move
  ball.x += ball.vx;
  ball.y += ball.vy;

  const groundY = H * GROUND_Y_R;
  const ceilY   = H * CEIL_Y_R;
  const leftX   = ARENA_PAD;
  const rightX  = W - ARENA_PAD;

  // wall bounces
  if (ball.x - ball.r < leftX)  { ball.x = leftX + ball.r;  ball.vx = Math.abs(ball.vx); }
  if (ball.x + ball.r > rightX) { ball.x = rightX - ball.r; ball.vx = -Math.abs(ball.vx); }
  if (ball.y - ball.r < ceilY)  { ball.y = ceilY + ball.r;  ball.vy = Math.abs(ball.vy); }

  // ground = fail
  if (ball.y + ball.r >= groundY) {
    strikes++;
    combo = 0;
    comboTimer = 0;
    playMiss();
    triggerShake(6, 0.35);
    // respawn ball above ground
    ball.y = ceilY + (groundY - ceilY) * 0.2;
    ball.vy = Math.abs(ball.vy);
    if (strikes >= MAX_STRIKES) endGame();
  }

  // ball hue
  ball.hue = (ball.hue + 1.5) % 360;

  // shake decay
  if (shakeDur > 0) {
    shakeDur -= dt;
    if (shakeDur <= 0) { shakeDur = 0; shakeAmp = 0; }
  }

  // flash decay
  flashAlpha = Math.max(0, flashAlpha - dt * 1.2);

  // bgHue slow shift
  bgHue = (bgHue + dt * 3) % 360;

  // particles
  particles.forEach(p => {
    p.x  += p.vx;
    p.y  += p.vy;
    p.vy += 0.18; // gravity
    p.vx *= 0.97; // drag
    p.life -= p.decay;
    p.rotation += p.rotSpd;
  });
  particles = particles.filter(p => p.life > 0);
}

// â”€â”€â”€ Draw helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawRoundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// â”€â”€â”€ Render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function render() {
  ctx.save();

  // screen shake
  let sx = 0, sy = 0;
  if (shakeAmp > 0 && shakeDur > 0) {
    sx = (Math.random() - 0.5) * shakeAmp * 2;
    sy = (Math.random() - 0.5) * shakeAmp * 2;
  }
  ctx.translate(sx, sy);

  // Background gradient (shifts with combo/time)
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, `hsl(${bgHue}, 55%, 7%)`);
  grad.addColorStop(1, `hsl(${(bgHue + 40) % 360}, 40%, 13%)`);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  const groundY = H * GROUND_Y_R;
  const ceilY   = H * CEIL_Y_R;

  // Arena outline
  ctx.strokeStyle = `rgba(255,255,255,0.08)`;
  ctx.lineWidth = 1;
  ctx.strokeRect(ARENA_PAD, ceilY, W - ARENA_PAD * 2, groundY - ceilY);

  // Ground line (danger)
  const dangerGrad = ctx.createLinearGradient(0, 0, W, 0);
  dangerGrad.addColorStop(0, 'transparent');
  dangerGrad.addColorStop(0.3, '#e74c3c');
  dangerGrad.addColorStop(0.7, '#e74c3c');
  dangerGrad.addColorStop(1, 'transparent');
  ctx.strokeStyle = dangerGrad;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(ARENA_PAD, groundY);
  ctx.lineTo(W - ARENA_PAD, groundY);
  ctx.stroke();

  // Ground label
  ctx.fillStyle = 'rgba(231,76,60,0.5)';
  ctx.font = `bold ${Math.round(W * 0.025)}px system-ui`;
  ctx.textAlign = 'center';
  ctx.fillText('DANGER ZONE', W * 0.5, groundY + 14);

  if (state !== 'start') {
    // Ball trail
    ball.trail.forEach((p, i) => {
      const a = (i / ball.trail.length) * 0.5;
      const r = ball.r * (i / ball.trail.length) * 0.7;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
      ctx.fillStyle = `hsla(${ball.hue}, 90%, 65%, ${a})`;
      ctx.fill();
    });

    // Ball glow
    const ballGlow = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ball.r * 2.5);
    ballGlow.addColorStop(0, `hsla(${ball.hue}, 100%, 80%, 0.4)`);
    ballGlow.addColorStop(1, `hsla(${ball.hue}, 100%, 60%, 0)`);
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r * 2.5, 0, Math.PI * 2);
    ctx.fillStyle = ballGlow;
    ctx.fill();

    // Ball
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    const ballFill = ctx.createRadialGradient(
      ball.x - ball.r*0.3, ball.y - ball.r*0.3, 0,
      ball.x, ball.y, ball.r
    );
    ballFill.addColorStop(0, `hsl(${ball.hue}, 100%, 90%)`);
    ballFill.addColorStop(1, `hsl(${ball.hue}, 85%, 55%)`);
    ctx.fillStyle = ballFill;
    ctx.fill();

    // Branches
    branches.forEach(b => {
      if (b.dead) return;
      const pulse = branchPulse(b, gameTime);
      const atPeak = isPeak(b, gameTime);
      const halfLen = b.len * (0.5 + pulse * 0.5);
      const cosA = Math.cos(b.angle);
      const sinA = Math.sin(b.angle);

      // Glow at peak
      if (atPeak) {
        ctx.shadowColor = `hsl(${b.hue}, 100%, 60%)`;
        ctx.shadowBlur  = 18;
      } else {
        ctx.shadowBlur = 0;
      }

      // Branch body
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(b.angle);

      const thick = 5 + pulse * 6;
      if (b.cracked) {
        // cracked appearance: two offset lines
        ctx.strokeStyle = `hsl(${b.hue - 15}, 60%, 35%)`;
        ctx.lineWidth = thick * 0.5;
        ctx.beginPath();
        ctx.moveTo(-halfLen * 0.95 + 2, -2);
        ctx.lineTo( halfLen * 0.95 + 2, 2);
        ctx.stroke();
      }

      ctx.lineWidth = thick;
      ctx.lineCap = 'round';
      const saturation = atPeak ? 90 : 55;
      const lightness  = atPeak ? 65 : 38;
      ctx.strokeStyle = `hsl(${b.hue}, ${saturation}%, ${lightness}%)`;
      ctx.beginPath();
      ctx.moveTo(-halfLen, 0);
      ctx.lineTo( halfLen, 0);
      ctx.stroke();

      // Buds at tips
      ctx.shadowBlur = 0;
      ctx.fillStyle = atPeak
        ? `hsl(${b.hue + 20}, 100%, 75%)`
        : `hsl(${b.hue}, 70%, 50%)`;
      const budR = 4 + pulse * 4;
      ctx.beginPath(); ctx.arc(-halfLen, 0, budR, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc( halfLen, 0, budR, 0, Math.PI * 2); ctx.fill();

      // Hits remaining indicator for stiff branches
      if (b.maxHits > 1) {
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.font = `bold ${Math.round(W * 0.03)}px system-ui`;
        ctx.textAlign = 'center';
        ctx.fillText(b.hits, 0, -halfLen * 0.1 - 10);
      }

      ctx.restore();
      ctx.shadowBlur = 0;
    });

    // Particles
    particles.forEach(p => {
      ctx.save();
      ctx.globalAlpha = p.life;
      if (p.isChip) {
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rotation);
        ctx.fillStyle = `hsl(${p.hue}, 70%, 55%)`;
        ctx.fillRect(-p.size * 0.5, -p.size * 0.25, p.size, p.size * 0.5);
      } else {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * 0.5, 0, Math.PI * 2);
        ctx.fillStyle = `hsl(${p.hue + 20}, 50%, 80%)`;
        ctx.fill();
      }
      ctx.restore();
    });

    // Strikes display (hearts/X)
    const strikeSz = Math.round(W * 0.05);
    for (let i = 0; i < MAX_STRIKES; i++) {
      ctx.font = `${strikeSz}px system-ui`;
      ctx.textAlign = 'left';
      ctx.globalAlpha = i < strikes ? 0.25 : 1;
      ctx.fillText('â¤ï¸', ARENA_PAD + i * (strikeSz + 4), ceilY - 6);
    }
    ctx.globalAlpha = 1;

    // Combo display
    if (combo > 1) {
      const comboAlpha = Math.min(1, comboTimer / 1.5);
      ctx.globalAlpha = comboAlpha;
      const comboSz = Math.round(W * 0.07 + combo * 1.2);
      ctx.font = `bold ${Math.min(comboSz, 52)}px system-ui`;
      ctx.textAlign = 'center';
      ctx.fillStyle = `hsl(${40 + combo * 8}, 100%, 70%)`;
      ctx.fillText(`x${combo} COMBO!`, W * 0.5, ceilY + (groundY - ceilY) * 0.15);
      ctx.globalAlpha = 1;
    }
  }

  // Flash vignette
  if (flashAlpha > 0) {
    ctx.fillStyle = `rgba(255,220,100,${flashAlpha})`;
    ctx.fillRect(0, 0, W, H);
  }

  // â”€â”€ Overlays â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (state === 'start') {
    drawOverlay('TWIG BREAK', 'Tap branches at peak\nfor maximum score!', 'TAP TO START');
  } else if (state === 'gameover') {
    drawOverlay('GAME OVER', `Score: ${score}\nBest: ${bestScore}`, 'TAP TO RETRY');
  }

  ctx.restore();

  // Update score UI element
  if (state === 'playing') {
    scoreEl.textContent = score;
  } else {
    scoreEl.textContent = '';
  }
}

function drawOverlay(title, body, cta) {
  // dim
  ctx.fillStyle = 'rgba(0,0,0,0.65)';
  ctx.fillRect(0, 0, W, H);

  const cx = W * 0.5;
  const cy = H * 0.5;
  const cardW = W * 0.8;
  const cardH = H * 0.38;
  const cardX = cx - cardW * 0.5;
  const cardY = cy - cardH * 0.5;

  // card
  ctx.fillStyle = 'rgba(20,10,40,0.92)';
  drawRoundRect(cardX, cardY, cardW, cardH, 20);
  ctx.fill();

  ctx.strokeStyle = `hsl(${bgHue}, 70%, 55%)`;
  ctx.lineWidth = 2;
  drawRoundRect(cardX, cardY, cardW, cardH, 20);
  ctx.stroke();

  // title
  ctx.textAlign = 'center';
  ctx.fillStyle = `hsl(${bgHue + 30}, 100%, 80%)`;
  ctx.font = `bold ${Math.round(W * 0.11)}px system-ui`;
  ctx.fillText(title, cx, cardY + cardH * 0.28);

  // body lines
  ctx.fillStyle = 'rgba(255,255,255,0.75)';
  ctx.font = `${Math.round(W * 0.042)}px system-ui`;
  const lines = body.split('\n');
  lines.forEach((line, i) => {
    ctx.fillText(line, cx, cardY + cardH * 0.52 + i * (W * 0.052));
  });

  // CTA pulse
  const ctaPulse = 0.75 + 0.25 * Math.sin(performance.now() * 0.003);
  ctx.globalAlpha = ctaPulse;
  ctx.fillStyle = `hsl(${bgHue + 60}, 100%, 75%)`;
  ctx.font = `bold ${Math.round(W * 0.05)}px system-ui`;
  ctx.fillText(cta, cx, cardY + cardH * 0.88);
  ctx.globalAlpha = 1;
}

// â”€â”€â”€ Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop(ts) {
  requestAnimationFrame(loop);
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;
  update(dt);
  render();
}

// â”€â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleAction(e) {
  initAudio();
  if (e && e.preventDefault) e.preventDefault();
  playerAction();
}

canvas.addEventListener('pointerdown', handleAction);
wrapper.addEventListener('pointerdown', handleAction);

document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'Enter') {
    if (state === 'playing') e.preventDefault();
    handleAction(e);
  }
});

// â”€â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
resetGame();
lastTime = performance.now();
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
