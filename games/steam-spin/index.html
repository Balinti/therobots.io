<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Steam Spin - Free HTML5 Game</title>
  <meta name="description" content="Play Steam Spin - Swipe to dodge spinning asteroids while the entire steampunk world rotates around you.">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#1a0f05">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Steam Spin - Free HTML5 Game">
  <meta property="og:description" content="Play Steam Spin - Swipe to dodge spinning asteroids while the entire steampunk world rotates around you.">
  <meta property="og:url" content="https://balinti.github.io/steam-spin/">
  <meta property="og:image" content="https://balinti.github.io/steam-spin/og-image.png">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Steam Spin - Free HTML5 Game">
  <meta name="twitter:description" content="Play Steam Spin - Swipe to dodge spinning asteroids while the entire steampunk world rotates around you.">
  <meta name="twitter:image" content="https://balinti.github.io/steam-spin/og-image.png">

  <link rel="canonical" href="https://balinti.github.io/steam-spin/">

  <!-- AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: #0d0804;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100dvh;
      font-family: 'Courier New', monospace;
      color: #c8a96e;
      overflow: hidden;
      touch-action: manipulation;
    }

    #game-wrap {
      position: relative;
      width: min(420px, 100vw);
      height: min(750px, 100dvh);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: manipulation;
    }

    /* SEO / how-to-play text - non-interactive, behind canvas */
    #seo-block {
      position: absolute;
      bottom: -9999px;
      left: 0;
      width: 100%;
      font-size: 11px;
      color: transparent;
      pointer-events: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="game-wrap">
    <canvas id="c"></canvas>
    <div id="seo-block" aria-hidden="true">
      Steam Spin: Valve Flip - A free hyper-casual HTML5 canvas game. Tap or press Space to flip the rotating hazard ring.
      Align the gap with incoming asteroids to let them pass safely to the center. Hit the golden Valve Gate for a score multiplier.
      Avoid letting asteroids hit the solid parts of the ring. How long can you survive? Play free, no download needed.
    </div>
  </div>

<script>
'use strict';

/* ─── Canvas Setup ─────────────────────────────────────── */
const canvas = document.getElementById('c');
const ctx    = canvas.getContext('2d');
const wrap   = document.getElementById('game-wrap');

let W, H, CX, CY, SCALE;
const MAX_DPR = 2;

function resize() {
  const rect = wrap.getBoundingClientRect();
  W = rect.width;
  H = rect.height;
  const dpr = Math.min(devicePixelRatio || 1, MAX_DPR);
  canvas.width  = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  CX = W / 2;
  CY = H / 2;
  SCALE = Math.min(W, H);
}
resize();
window.addEventListener('resize', () => { resize(); });

/* ─── Constants ────────────────────────────────────────── */
const TWO_PI = Math.PI * 2;
const RING_R_FRAC   = 0.35;   // ring center radius as fraction of SCALE
const RING_THICK    = 28;     // ring band half-thickness (px at 420)
const BASE_GAP      = 1.15;   // gap angular size (radians) at start
const MIN_GAP       = 0.62;   // gap floor
const BASE_OMEGA    = 1.6;    // ring rotation speed rad/s
const MAX_OMEGA     = 5.2;
const BASE_INTERVAL = 1600;   // ms between asteroid spawns
const MIN_INTERVAL  = 460;
const BASE_AS_SPEED = 0.22;   // fraction of SCALE per second
const MAX_AS_SPEED  = 0.58;
const NEAR_MISS_ANG = 0.14;   // radians window for near-miss bonus

/* ─── State ────────────────────────────────────────────── */
let state    = 'start'; // 'start' | 'playing' | 'gameover'
let score    = 0;
let best     = +localStorage.getItem('steamSpinBest') || 0;
let maxMult  = 1;
let mult     = 1;
let elapsed  = 0;       // seconds since game start

let ringAngle  = 0;
let ringOmega  = BASE_OMEGA;  // current speed (signed: direction)
let gapSize    = BASE_GAP;
let spawnTimer = 0;
let spawnInterval = BASE_INTERVAL;

let asteroids = [];
let particles = [];
let shake     = { x: 0, y: 0, t: 0 };
let hue       = 30; // for HSL cycling

let gateAngle    = 0;   // gate position on ring (offset from gap center)
let gateActive   = false;
let gateHit      = false; // did current asteroid hit gate?

/* ─── Difficulty ───────────────────────────────────────── */
function getDifficulty(t) {
  // t in seconds
  const prog = Math.min(t / 90, 1);
  return {
    omega:    BASE_OMEGA + (MAX_OMEGA - BASE_OMEGA) * Math.pow(prog, 0.7),
    gap:      Math.max(MIN_GAP, BASE_GAP - prog * (BASE_GAP - MIN_GAP)),
    interval: Math.max(MIN_INTERVAL, BASE_INTERVAL - prog * (BASE_INTERVAL - MIN_INTERVAL)),
    asSpeed:  BASE_AS_SPEED + (MAX_AS_SPEED - BASE_AS_SPEED) * prog,
    gateProb: Math.min(0.55, 0.15 + prog * 0.4),
    doubleProb: prog > 0.3 ? Math.min(0.35, (prog - 0.3) * 0.5) : 0,
    armoredProb: t > 45 ? Math.min(0.4, (t - 45) / 80) : 0,
  };
}

/* ─── Asteroid ─────────────────────────────────────────── */
class Asteroid {
  constructor(angle, speed, armored) {
    this.spawnAngle = angle;             // angle from center it travels along
    this.dist = SCALE * 0.72;            // start distance from center
    this.speed = speed;                  // px/s
    this.r = armored ? 13 : 9;          // radius
    this.armored = armored;
    this.dead = false;
    this.passed = false;
    this.color = armored ? '#a08060' : '#8ab4d0';
    this.rotSelf = Math.random() * TWO_PI; // self rotation for drawing
    this.rotSpeed = (Math.random() - 0.5) * 4;
  }
  get x() { return CX + Math.cos(this.spawnAngle) * this.dist; }
  get y() { return CY + Math.sin(this.spawnAngle) * this.dist; }

  update(dt) {
    this.dist -= this.speed * dt;
    this.rotSelf += this.rotSpeed * dt;
    if (this.dist < 0) this.dead = true;
  }
}

/* ─── Particle ─────────────────────────────────────────── */
class Particle {
  constructor(x, y, vx, vy, color, life, size) {
    this.x = x; this.y = y;
    this.vx = vx; this.vy = vy;
    this.color = color;
    this.life = life;  // seconds total
    this.age  = 0;
    this.size = size || 3;
  }
  update(dt) {
    this.x  += this.vx * dt;
    this.y  += this.vy * dt;
    this.vx *= 0.94;
    this.vy *= 0.94;
    this.age += dt;
  }
  get alive() { return this.age < this.life; }
  get alpha() { return 1 - this.age / this.life; }
}

/* ─── Spawn Particles ──────────────────────────────────── */
function burst(x, y, color, n, speed, life, size) {
  for (let i = 0; i < n; i++) {
    const a = Math.random() * TWO_PI;
    const s = speed * (0.4 + Math.random() * 0.9);
    particles.push(new Particle(x, y, Math.cos(a)*s, Math.sin(a)*s, color, life, size));
  }
}

function ringBurst(angle, color, n) {
  const rr = SCALE * RING_R_FRAC;
  const x = CX + Math.cos(angle) * rr;
  const y = CY + Math.sin(angle) * rr;
  burst(x, y, color, n, 120, 0.5, 3);
}

/* ─── Screen Shake ─────────────────────────────────────── */
function doShake(mag, dur) {
  shake.mag = mag;
  shake.t   = dur;
}

/* ─── Input ────────────────────────────────────────────── */
function onInput() {
  if (state === 'start')    { startGame(); return; }
  if (state === 'gameover') { startGame(); return; }
  // flip ring direction
  ringOmega = -ringOmega;
  // spawn flip sparks at gap position
  ringBurst(ringAngle, `hsl(${hue},90%,70%)`, 8);
  doShake(2, 0.12);
}

canvas.addEventListener('pointerdown', e => { e.preventDefault(); onInput(); }, { passive: false });
window.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); onInput(); }
});

/* ─── Game Start / Reset ───────────────────────────────── */
function startGame() {
  state       = 'playing';
  score       = 0;
  mult        = 1;
  maxMult     = 1;
  elapsed     = 0;
  ringAngle   = -Math.PI / 2;  // gap points up
  const d     = getDifficulty(0);
  ringOmega   = d.omega;
  gapSize     = d.gap;
  spawnTimer  = 0;
  spawnInterval = d.interval;
  asteroids   = [];
  particles   = [];
  gateActive  = false;
  gateHit     = false;
  hue         = 30;
}

/* ─── Angle helpers ────────────────────────────────────── */
function normalizeAngle(a) {
  while (a >  Math.PI) a -= TWO_PI;
  while (a < -Math.PI) a += TWO_PI;
  return a;
}

/* ─── Spawn Asteroid ───────────────────────────────────── */
function spawnAsteroid(d, offset) {
  // spawn at a random angle (but not through the gap)
  let angle;
  let tries = 0;
  do {
    angle = Math.random() * TWO_PI;
    const rel = Math.abs(normalizeAngle(angle - ringAngle));
    tries++;
    if (tries > 20) break;
  } while (rel < gapSize * 1.2);

  const armored = Math.random() < d.armoredProb;

  // Should there be a gate?
  gateActive = Math.random() < d.gateProb;
  gateHit    = false;
  if (gateActive) {
    // Place gate near gap center (slightly offset)
    gateAngle = ringAngle + (Math.random() - 0.5) * gapSize * 0.6;
  }

  asteroids.push(new Asteroid(angle + (offset || 0), d.asSpeed * SCALE, armored));
}

/* ─── Update ───────────────────────────────────────────── */
let lastTime = null;

function update(ts) {
  const dt = lastTime == null ? 0 : Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;

  if (state !== 'playing') return;

  elapsed += dt;
  hue = (hue + dt * 8) % 360;

  const d = getDifficulty(elapsed);
  gapSize = d.gap;
  // smoothly adjust omega magnitude, keep sign
  const dir = Math.sign(ringOmega);
  ringOmega = dir * d.omega;
  spawnInterval = d.interval;

  // rotate ring
  ringAngle += ringOmega * dt;

  // spawn
  spawnTimer -= dt * 1000;
  if (spawnTimer <= 0) {
    spawnTimer = spawnInterval;
    spawnAsteroid(d);
    if (Math.random() < d.doubleProb) {
      spawnAsteroid(d, 0.25); // slightly offset second asteroid
    }
  }

  // screen shake decay
  if (shake.t > 0) {
    shake.t -= dt;
    shake.x = (Math.random() - 0.5) * shake.mag * 2;
    shake.y = (Math.random() - 0.5) * shake.mag * 2;
  } else {
    shake.x = 0; shake.y = 0;
  }

  const rr   = SCALE * RING_R_FRAC;
  const thick = RING_THICK * (SCALE / 420);

  // update asteroids
  for (const a of asteroids) {
    a.update(dt);

    // check ring collision
    if (!a.passed && !a.dead) {
      const dx = a.x - CX;
      const dy = a.y - CY;
      const dist = Math.sqrt(dx*dx + dy*dy);

      // Is asteroid inside ring band?
      if (dist < rr + thick && dist > rr - thick) {
        // Angle of asteroid relative to ring gap
        const asteroidAngle = Math.atan2(dy, dx);
        const relAngle = Math.abs(normalizeAngle(asteroidAngle - ringAngle));

        if (relAngle < gapSize / 2) {
          // Passed through gap!
          a.passed = true;
          score += mult;
          if (score > best) { best = score; localStorage.setItem('steamSpinBest', best); }

          // near-miss bonus
          const edgeDist = gapSize / 2 - relAngle;
          if (edgeDist < NEAR_MISS_ANG) {
            // close to edge => near-miss spark + bonus
            const ex = CX + Math.cos(asteroidAngle) * rr;
            const ey = CY + Math.sin(asteroidAngle) * rr;
            burst(ex, ey, '#ffdd44', 6, 80, 0.35, 2);
            doShake(1.5, 0.08);
          }

          // gate check: asteroid must also be near gateAngle
          if (gateActive) {
            const relGate = Math.abs(normalizeAngle(asteroidAngle - gateAngle));
            if (relGate < 0.22) {
              // GATE HIT!
              mult = Math.min(8, mult + 1);
              if (mult > maxMult) maxMult = mult;
              const gx = CX + Math.cos(gateAngle) * rr;
              const gy = CY + Math.sin(gateAngle) * rr;
              burst(gx, gy, '#ffd700', 20, 160, 0.7, 4);
              doShake(3, 0.15);
              gateActive = false;
              gateHit    = true;
            } else {
              // missed gate => reset multiplier
              mult = 1;
            }
          }

          // particle on pass
          const px = CX + Math.cos(asteroidAngle) * rr;
          const py = CY + Math.sin(asteroidAngle) * rr;
          burst(px, py, `hsl(${hue},80%,65%)`, 5, 60, 0.3, 2);

        } else {
          // hit solid ring => game over
          gameOver(a);
          return;
        }
      }

      // hit center (passed ring)
      if (a.passed && dist < 18) {
        a.dead = true;
      }
    }
  }

  // remove dead
  asteroids = asteroids.filter(a => !a.dead);

  // update particles
  particles.forEach(p => p.update(dt));
  particles = particles.filter(p => p.alive);
}

/* ─── Game Over ────────────────────────────────────────── */
function gameOver(asteroid) {
  state = 'gameover';
  if (score > best) { best = score; localStorage.setItem('steamSpinBest', best); }
  // death burst at center
  burst(CX, CY, '#ff4422', 30, 200, 0.9, 5);
  burst(asteroid.x, asteroid.y, '#ffaa22', 20, 150, 0.7, 4);
  doShake(12, 0.6);
  asteroids = [];
}

/* ─── Draw Helpers ─────────────────────────────────────── */
function drawBg() {
  // gradient background
  const grad = ctx.createRadialGradient(CX, CY, 0, CX, CY, SCALE * 0.6);
  grad.addColorStop(0,   '#1e1108');
  grad.addColorStop(0.6, '#120b04');
  grad.addColorStop(1,   '#0a0604');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // background gear arcs (steampunk deco)
  drawGearArcs();
}

function drawGearArcs() {
  ctx.save();
  ctx.strokeStyle = 'rgba(120,80,30,0.12)';
  ctx.lineWidth   = 1;
  // concentric circles with tick marks
  const radii = [0.12, 0.20, 0.28, 0.50, 0.62, 0.72].map(f => f * SCALE);
  for (const r of radii) {
    ctx.beginPath();
    ctx.arc(CX, CY, r, 0, TWO_PI);
    ctx.stroke();
    // gear teeth
    const teeth = Math.round(r * 0.18);
    for (let i = 0; i < teeth; i++) {
      const a = (i / teeth) * TWO_PI;
      ctx.beginPath();
      ctx.moveTo(CX + Math.cos(a) * (r - 4), CY + Math.sin(a) * (r - 4));
      ctx.lineTo(CX + Math.cos(a) * (r + 4), CY + Math.sin(a) * (r + 4));
      ctx.stroke();
    }
  }
  // cross grid lines (faint)
  ctx.strokeStyle = 'rgba(100,60,20,0.07)';
  for (let i = 0; i < 12; i++) {
    const a = (i / 12) * TWO_PI;
    ctx.beginPath();
    ctx.moveTo(CX, CY);
    ctx.lineTo(CX + Math.cos(a) * SCALE * 0.75, CY + Math.sin(a) * SCALE * 0.75);
    ctx.stroke();
  }
  ctx.restore();
}

/* draw the hazard ring */
function drawRing() {
  const rr    = SCALE * RING_R_FRAC;
  const thick = RING_THICK * (SCALE / 420);
  const halfG = gapSize / 2;

  ctx.save();

  // outer glow
  ctx.shadowBlur  = 18;
  ctx.shadowColor = `hsl(${hue},70%,45%)`;

  // draw ring in two arcs (leaving gap)
  const gapStart = ringAngle - halfG;
  const gapEnd   = ringAngle + halfG;

  for (let pass = 0; pass < 2; pass++) {
    ctx.beginPath();
    ctx.arc(CX, CY, rr, gapEnd, gapStart + TWO_PI); // solid arc
    ctx.strokeStyle = pass === 0
      ? `hsl(${hue},60%,28%)`
      : `hsl(${hue},80%,55%)`;
    ctx.lineWidth = pass === 0 ? thick * 2 : thick * 1.6;
    ctx.lineCap = 'butt';
    ctx.stroke();
  }

  // gap edge highlights
  for (const edgeA of [gapStart, gapEnd]) {
    const ex = CX + Math.cos(edgeA) * rr;
    const ey = CY + Math.sin(edgeA) * rr;
    ctx.beginPath();
    ctx.arc(ex, ey, thick * 0.55, 0, TWO_PI);
    ctx.fillStyle = `hsl(${hue},90%,75%)`;
    ctx.fill();
  }

  ctx.shadowBlur = 0;

  // Valve Gate (golden arc segment)
  if (gateActive && state === 'playing') {
    const gateHalfW = 0.18;
    ctx.beginPath();
    ctx.arc(CX, CY, rr, gateAngle - gateHalfW, gateAngle + gateHalfW);
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth   = thick * 0.7;
    ctx.shadowBlur  = 22;
    ctx.shadowColor = '#ffa500';
    ctx.stroke();
    ctx.shadowBlur  = 0;

    // gate icon: small gear symbol
    const gx = CX + Math.cos(gateAngle) * rr;
    const gy = CY + Math.sin(gateAngle) * rr;
    ctx.save();
    ctx.translate(gx, gy);
    ctx.rotate(gateAngle + elapsed * 2);
    ctx.strokeStyle = '#ffe066';
    ctx.lineWidth   = 1.5;
    for (let i = 0; i < 8; i++) {
      const a = (i / 8) * TWO_PI;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a) * 5, Math.sin(a) * 5);
      ctx.lineTo(Math.cos(a) * 8, Math.sin(a) * 8);
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.arc(0, 0, 4, 0, TWO_PI);
    ctx.stroke();
    ctx.restore();
  }

  ctx.restore();
}

/* draw center hub */
function drawCenter() {
  const r  = SCALE * 0.055;
  const r2 = r * 0.55;

  ctx.save();
  // outer ring
  ctx.beginPath();
  ctx.arc(CX, CY, r, 0, TWO_PI);
  ctx.strokeStyle = `hsl(${hue},70%,50%)`;
  ctx.lineWidth   = 3;
  ctx.shadowBlur  = 14;
  ctx.shadowColor = `hsl(${hue},80%,50%)`;
  ctx.stroke();

  // inner hub
  ctx.beginPath();
  ctx.arc(CX, CY, r2, 0, TWO_PI);
  ctx.fillStyle = `hsl(${hue},50%,18%)`;
  ctx.fill();
  ctx.strokeStyle = `hsl(${hue},70%,45%)`;
  ctx.lineWidth   = 2;
  ctx.stroke();

  // rotating spokes
  ctx.rotate && 0; // no-op
  ctx.save();
  ctx.translate(CX, CY);
  ctx.rotate(elapsed * 1.2);
  ctx.strokeStyle = `hsl(${hue},60%,40%)`;
  ctx.lineWidth   = 1.5;
  for (let i = 0; i < 6; i++) {
    const a = (i / 6) * TWO_PI;
    ctx.beginPath();
    ctx.moveTo(Math.cos(a) * r2 * 0.3, Math.sin(a) * r2 * 0.3);
    ctx.lineTo(Math.cos(a) * r2 * 0.9, Math.sin(a) * r2 * 0.9);
    ctx.stroke();
  }
  ctx.restore();

  ctx.shadowBlur = 0;
  ctx.restore();
}

/* draw an asteroid */
function drawAsteroid(a) {
  ctx.save();
  ctx.translate(a.x, a.y);
  ctx.rotate(a.rotSelf);

  const r = a.r * (SCALE / 420);
  const sides = a.armored ? 6 : 5;

  // glow
  ctx.shadowBlur  = a.armored ? 12 : 8;
  ctx.shadowColor = a.armored ? '#c09050' : '#80c0e0';

  ctx.beginPath();
  for (let i = 0; i <= sides; i++) {
    const angle = (i / sides) * TWO_PI;
    const jitter = a.armored ? 0 : (i % 2 === 0 ? 0.7 : 1.0);
    const rr = r * (a.armored ? 1 : jitter);
    if (i === 0) ctx.moveTo(Math.cos(angle) * rr, Math.sin(angle) * rr);
    else ctx.lineTo(Math.cos(angle) * rr, Math.sin(angle) * rr);
  }
  ctx.closePath();

  ctx.fillStyle   = a.armored ? '#7a5535' : '#2a4a60';
  ctx.strokeStyle = a.armored ? '#e0a060' : '#88ccee';
  ctx.lineWidth   = a.armored ? 2.5 : 1.8;
  ctx.fill();
  ctx.stroke();

  if (a.armored) {
    // bolt marks
    ctx.strokeStyle = '#c8a060';
    ctx.lineWidth   = 1;
    for (let i = 0; i < 3; i++) {
      const angle = (i / 3) * TWO_PI + a.rotSelf * 0.5;
      ctx.beginPath();
      ctx.moveTo(Math.cos(angle) * r * 0.3, Math.sin(angle) * r * 0.3);
      ctx.lineTo(Math.cos(angle) * r * 0.7, Math.sin(angle) * r * 0.7);
      ctx.stroke();
    }
  }

  ctx.shadowBlur = 0;
  ctx.restore();
}

/* ─── HUD ──────────────────────────────────────────────── */
function drawHUD() {
  ctx.save();
  ctx.textBaseline = 'top';

  // Score
  ctx.font      = `bold ${Math.round(SCALE * 0.065)}px 'Courier New', monospace`;
  ctx.fillStyle = `hsl(${hue},80%,75%)`;
  ctx.textAlign = 'center';
  ctx.fillText(score, CX, H * 0.06);

  // Multiplier badge
  if (mult > 1) {
    ctx.font      = `bold ${Math.round(SCALE * 0.038)}px 'Courier New', monospace`;
    ctx.fillStyle = '#ffd700';
    ctx.textAlign = 'center';
    ctx.shadowBlur  = 10;
    ctx.shadowColor = '#ffa000';
    ctx.fillText(`×${mult}`, CX, H * 0.06 + Math.round(SCALE * 0.07));
    ctx.shadowBlur = 0;
  }

  // Best (top right)
  ctx.font      = `${Math.round(SCALE * 0.032)}px 'Courier New', monospace`;
  ctx.fillStyle = 'rgba(200,169,110,0.6)';
  ctx.textAlign = 'right';
  ctx.fillText(`BEST ${best}`, W - 12, 12);

  ctx.restore();
}

/* ─── Overlay Screens ──────────────────────────────────── */
function drawOverlay(lines, sublines) {
  // dim bg
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign    = 'center';
  ctx.textBaseline = 'middle';

  const fs1 = Math.round(SCALE * 0.1);
  const fs2 = Math.round(SCALE * 0.042);

  ctx.font      = `bold ${fs1}px 'Courier New', monospace`;
  ctx.fillStyle = `hsl(${hue},90%,72%)`;
  ctx.shadowBlur  = 20;
  ctx.shadowColor = `hsl(${hue},80%,50%)`;
  ctx.fillText(lines[0], CX, CY - H * 0.10);
  ctx.shadowBlur  = 0;

  ctx.font      = `${fs2}px 'Courier New', monospace`;
  ctx.fillStyle = '#c8a96e';
  for (let i = 1; i < lines.length; i++) {
    ctx.fillText(lines[i], CX, CY - H * 0.10 + fs1 * 0.9 + (i - 1) * (fs2 * 1.5));
  }

  ctx.font      = `bold ${fs2 * 0.95}px 'Courier New', monospace`;
  ctx.fillStyle = 'rgba(200,169,110,0.7)';
  for (let i = 0; i < sublines.length; i++) {
    ctx.fillText(sublines[i], CX, CY + H * 0.15 + i * (fs2 * 1.6));
  }
}

function drawStartScreen() {
  // animated ring behind
  ctx.save();
  const rr = SCALE * RING_R_FRAC;
  const pulse = 1 + Math.sin(Date.now() / 400) * 0.04;
  ctx.strokeStyle = `hsl(${hue},70%,40%)`;
  ctx.lineWidth   = RING_THICK * (SCALE / 420) * 1.5;
  ctx.shadowBlur  = 22;
  ctx.shadowColor = `hsl(${hue},80%,50%)`;
  ctx.beginPath();
  ctx.arc(CX, CY, rr * pulse, 0, TWO_PI);
  ctx.stroke();
  ctx.shadowBlur  = 0;
  ctx.restore();

  drawOverlay(
    ['STEAM', 'SPIN'],
    ['TAP TO START', '', 'Flip the ring ● Dodge asteroids', 'Hit the ⚙ Gate to multiply score']
  );
}

function drawGameOverScreen() {
  drawOverlay(
    ['GAME', 'OVER'],
    [
      `SCORE    ${score}`,
      `BEST     ${best}`,
      `MAX ×    ${maxMult}`,
      '',
      'TAP TO RETRY'
    ]
  );
}

/* ─── Main Draw ────────────────────────────────────────── */
function draw() {
  ctx.save();
  ctx.translate(shake.x, shake.y);

  drawBg();

  if (state === 'playing' || state === 'gameover') {
    drawRing();
    drawCenter();

    // draw asteroids
    for (const a of asteroids) drawAsteroid(a);
  }

  // particles always drawn
  ctx.save();
  for (const p of particles) {
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle   = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, TWO_PI);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.restore();

  if (state === 'playing') {
    drawHUD();
  } else if (state === 'start') {
    drawStartScreen();
  } else if (state === 'gameover') {
    drawHUD();
    drawGameOverScreen();
  }

  ctx.restore();
}

/* ─── Loop ─────────────────────────────────────────────── */
function loop(ts) {
  hue = (hue + 0.01) % 360; // gentle idle drift even on start screen
  update(ts);
  draw();
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
