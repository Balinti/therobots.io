<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hue Walk - Free HTML5 Game</title>
  <meta name="description" content="Play Hue Walk - Swipe left or right to maintain balance as the beam and colors continuously shift.">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#1a0a2e">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Hue Walk - Free HTML5 Game">
  <meta property="og:description" content="Play Hue Walk - Swipe left or right to maintain balance as the beam and colors continuously shift.">
  <meta property="og:url" content="https://balinti.github.io/hue-walk/">
  <meta property="og:image" content="https://balinti.github.io/hue-walk/og-image.png">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Hue Walk - Free HTML5 Game">
  <meta name="twitter:description" content="Play Hue Walk - Swipe left or right to maintain balance as the beam and colors continuously shift.">

  <!-- AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%;
      background: #0d0618;
      font-family: 'Segoe UI', system-ui, sans-serif;
      color: #e0d0f0;
      overflow-x: hidden;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    #site-header {
      width: 100%;
      max-width: 420px;
      text-align: center;
      padding: 8px 12px 4px;
      font-size: 13px;
      color: #9a80c0;
      letter-spacing: 0.05em;
    }
    #game-container {
      position: relative;
      width: 100%;
      max-width: 420px;
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #canvas-wrap {
      position: relative;
      width: 100%;
      max-width: 420px;
      max-height: 750px;
      aspect-ratio: 420 / 750;
      overflow: hidden;
      border-radius: 12px;
      box-shadow: 0 0 40px #5020a055;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }
    #ad-top {
      width: 100%;
      max-width: 420px;
      min-height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 4px;
    }
    #ad-bottom {
      width: 100%;
      max-width: 420px;
      min-height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 4px;
    }
    #seo-section {
      width: 100%;
      max-width: 420px;
      padding: 16px 16px 24px;
      font-size: 13px;
      line-height: 1.6;
      color: #8070a8;
    }
    #seo-section h2 { font-size: 15px; color: #b09adb; margin-bottom: 6px; margin-top: 14px; }
    #seo-section ul { padding-left: 18px; }
    #seo-section ul li { margin-bottom: 3px; }
  </style>
</head>
<body>

<header id="site-header">HUE WALK &mdash; Tightrope Color Game</header>

<div id="ad-top">
  <!-- Ad slot top -->
</div>

<div id="game-container">
  <div id="canvas-wrap">
    <canvas id="c"></canvas>
  </div>
</div>

<div id="ad-bottom">
  <!-- Ad slot bottom -->
</div>

<section id="seo-section" aria-label="Game Guide">
  <h2>How to Play</h2>
  <ul>
    <li>Tap or press <strong>Space / Enter</strong> to step with your left or right foot.</li>
    <li><span style="color:#6699ff">Blue tiles</span> require a <strong>Left</strong> foot step.</li>
    <li><span style="color:#ff66aa">Pink tiles</span> require a <strong>Right</strong> foot step.</li>
    <li>Three wrong steps and you fall off the beam!</li>
  </ul>
  <h2>Tips</h2>
  <ul>
    <li>Build combos with correct steps to decay wobble faster.</li>
    <li>Watch for <strong>Bump</strong> tiles &mdash; a high combo (3+) protects you.</li>
    <li>Narrow sections are trickier; focus on your rhythm.</li>
    <li>Storm phases are faster but score big &mdash; stay calm!</li>
  </ul>
  <h2>About</h2>
  <p>Hue Walk is a free browser game. Walk a color-coded tightrope, match your steps to tile colors, and survive as speed and complexity increase. No download needed &mdash; just play!</p>
</section>

<script>
(function(){
"use strict";

// ─── RNG ────────────────────────────────────────────────────────────────────
const urlParams = new URLSearchParams(location.search);
let seed = parseInt(urlParams.get('seed')) || Date.now();
function rng() {
  seed ^= seed << 13; seed ^= seed >> 17; seed ^= seed << 5;
  return (seed >>> 0) / 4294967296;
}

// ─── CANVAS SETUP ────────────────────────────────────────────────────────────
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const DPR = Math.min(window.devicePixelRatio || 1, 2);
const W_CSS = 420, H_CSS = 750;
canvas.width  = W_CSS * DPR;
canvas.height = H_CSS * DPR;
ctx.scale(DPR, DPR);
const W = W_CSS, H = H_CSS;

// ─── CONSTANTS ───────────────────────────────────────────────────────────────
const LEFT_COLOR  = '#5577ff';  // Blue  = left foot
const RIGHT_COLOR = '#ff5599';  // Pink  = right foot
const LEFT_H  = 225;
const RIGHT_H = 340;
const BEAM_Y  = H * 0.62;
const BEAM_W  = 60;
const RUNNER_X = W * 0.3;

const TILE_H   = 36;
const TILE_GAP = 18;
const TILE_W_NORMAL = 52;
const TILE_W_NARROW = 32;
const TILE_STEP = TILE_H + TILE_GAP;
const MAX_WOBBLE = 100;
const MAX_MISTAKES = 3;

// ─── STATE ───────────────────────────────────────────────────────────────────
let state = 'start'; // start | playing | gameover
let score, combo, mistakes, wobble, distance, elapsed;
let baseSpeed, currentSpeed, hueShift, bgHue;
let shakeX, shakeY, shakeDur, shakeMag;
let currentFoot; // 0=left,1=right (last foot placed)
let tiles, particles;
let highScore = +localStorage.getItem('huewalk_hs') || 0;
let phase; // 0..5

function resetGame() {
  seed = parseInt(urlParams.get('seed')) || Date.now();
  score = 0; combo = 0; mistakes = 0; wobble = 0;
  distance = 0; elapsed = 0;
  baseSpeed = 120; currentSpeed = baseSpeed;
  hueShift = 0; bgHue = 260;
  shakeX = 0; shakeY = 0; shakeDur = 0; shakeMag = 0;
  currentFoot = 0; // next step is left (0) or right (1)
  phase = 0;
  tiles = []; particles = [];
  // Spawn initial tiles ahead of runner
  for (let i = 0; i < 14; i++) spawnTile(BEAM_Y - 80 - i * TILE_STEP);
}

// ─── TILE TYPES ──────────────────────────────────────────────────────────────
// type: 'normal' | 'bump' | 'narrow' | 'gate'
function makeTile(y) {
  const p = phase;
  let type = 'normal';
  const r = rng();
  if (p >= 1 && r < (p >= 3 ? 0.22 : 0.12)) type = 'bump';
  else if (p >= 2 && r < (p >= 2 ? 0.18 : 0)) type = 'narrow';
  if (p >= 3 && rng() < 0.18) type = 'gate';

  // which foot color
  const foot = Math.round(rng()) ; // 0=left=blue, 1=right=pink
  const w = type === 'narrow' ? TILE_W_NARROW : TILE_W_NORMAL;

  // gate: favored side (0=left, 1=right) - opposite choice gets penalty
  const gateFavor = type === 'gate' ? (rng() < 0.5 ? 0 : 1) : -1;

  return { y, foot, type, w, gateFavor, resolved: false, pulse: 0 };
}

function spawnTile(y) {
  tiles.push(makeTile(y));
}

// ─── PARTICLES ───────────────────────────────────────────────────────────────
function spawnParticles(x, y, color, count, speed, size) {
  for (let i = 0; i < count; i++) {
    const angle = rng() * Math.PI * 2;
    const spd = (0.5 + rng()) * speed;
    particles.push({
      x, y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd,
      life: 1, decay: 0.018 + rng() * 0.025,
      size: size * (0.5 + rng()),
      color, gravity: 0.12 + rng() * 0.1
    });
  }
}

function spawnComboMilestone(x, y) {
  const colors = ['#ffee55','#55ffbb','#ff88ee','#88aaff'];
  colors.forEach(c => spawnParticles(x, y, c, 6, 4, 5));
}

function spawnFallBurst() {
  for (let i = 0; i < 40; i++) {
    const angle = rng() * Math.PI * 2;
    const spd = 1 + rng() * 6;
    particles.push({
      x: RUNNER_X, y: BEAM_Y,
      vx: Math.cos(angle)*spd, vy: Math.sin(angle)*spd - 2,
      life: 1, decay: 0.012 + rng()*0.015,
      size: 3 + rng()*5,
      color: `hsl(${Math.floor(rng()*360)},90%,65%)`,
      gravity: 0.18
    });
  }
}

// ─── SCREEN SHAKE ────────────────────────────────────────────────────────────
function triggerShake(mag, dur) {
  if (mag > shakeMag) { shakeMag = mag; shakeDur = dur; }
}

// ─── INPUT ───────────────────────────────────────────────────────────────────
function onInput() {
  if (state === 'start') { state = 'playing'; resetGame(); return; }
  if (state === 'gameover') { state = 'start'; return; }
  if (state === 'playing') doStep();
}

canvas.addEventListener('pointerdown', e => { e.preventDefault(); onInput(); });
window.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); onInput(); }
});

// ─── GAME LOGIC ──────────────────────────────────────────────────────────────
function doStep() {
  // Toggle foot
  currentFoot = 1 - currentFoot;
  // Find the tile closest to BEAM_Y that hasn't been resolved yet
  // The tile that's "at" the runner - use the nearest tile above or on BEAM_Y
  let best = null, bestDist = Infinity;
  tiles.forEach(t => {
    if (t.resolved) return;
    const d = Math.abs(t.y - BEAM_Y);
    if (d < bestDist) { bestDist = d; best = t; }
  });
  if (!best || bestDist > TILE_STEP * 1.8) return; // no tile to resolve

  resolveTile(best);
}

function resolveTile(tile) {
  if (tile.resolved) return;
  tile.resolved = true;

  const correct = (tile.foot === currentFoot);

  if (tile.type === 'bump') {
    if (!correct) {
      wobble += 20;
      combo = 0;
      triggerShake(2, 8);
      spawnParticles(RUNNER_X, BEAM_Y, '#ff4444', 8, 3, 4);
    } else if (combo < 3) {
      wobble += 10;
      triggerShake(1.5, 6);
    } else {
      // combo >=3 protects from bump
      spawnParticles(RUNNER_X, BEAM_Y, '#ffcc44', 5, 2.5, 3);
    }
    return;
  }

  if (tile.type === 'gate') {
    if (correct) {
      combo++;
      score += 10 + combo;
      spawnParticles(RUNNER_X, tile.y, tile.foot===0 ? LEFT_COLOR : RIGHT_COLOR, 10, 3, 3.5);
      if (combo % 5 === 0) spawnComboMilestone(RUNNER_X, tile.y);
    } else {
      // check gate favor penalty
      const penalty = tile.gateFavor === currentFoot ? 10 : 20;
      wobble += penalty;
      mistakes++;
      combo = 0;
      triggerShake(penalty > 15 ? 3 : 1.5, 10);
      spawnParticles(RUNNER_X, tile.y, '#ff4444', 8, 3, 4);
      if (mistakes >= MAX_MISTAKES || wobble >= MAX_WOBBLE) triggerGameOver();
    }
    return;
  }

  if (correct) {
    combo++;
    score += 5 + combo;
    spawnParticles(RUNNER_X, tile.y, tile.foot===0 ? LEFT_COLOR : RIGHT_COLOR, 8, 2.5, 3);
    if (combo % 5 === 0) spawnComboMilestone(RUNNER_X, tile.y);
    // wobble decay on correct
    const decay = phase >= 4 ? 3 : phase >= 2 ? 5 : 8;
    wobble = Math.max(0, wobble - decay);
    triggerShake(0.4, 3);
  } else {
    wobble += 15 + phase * 3;
    mistakes++;
    combo = 0;
    triggerShake(wobble > 60 ? 3 : 1.8, 10);
    spawnParticles(RUNNER_X, tile.y, '#ff3366', 8, 3, 4);
    if (mistakes >= MAX_MISTAKES || wobble >= MAX_WOBBLE) triggerGameOver();
  }
}

function triggerGameOver() {
  state = 'gameover';
  if (score > highScore) { highScore = score; localStorage.setItem('huewalk_hs', score); }
  triggerShake(10, 30);
  spawnFallBurst();
}

// ─── DIFFICULTY PHASE ────────────────────────────────────────────────────────
function updatePhase() {
  if (elapsed < 10)       phase = 0;
  else if (elapsed < 25)  phase = 1;
  else if (elapsed < 45)  phase = 2;
  else if (elapsed < 70)  phase = 3;
  else if (elapsed < 100) phase = 4;
  else                    phase = 5;

  // Storm phase: brief bursts of high speed around elapsed milestones
  const stormPeriod = 15;
  const stormBurst  = 4;
  const stormOffset = elapsed % stormPeriod;
  const inStorm = (elapsed > 70 && stormOffset < stormBurst);

  const phaseSpeedBonus = [0, 20, 40, 60, 80, 110][phase];
  const stormBonus = inStorm ? 60 : 0;
  baseSpeed = 120 + phaseSpeedBonus;
  currentSpeed = baseSpeed + stormBonus;
}

// ─── UPDATE ──────────────────────────────────────────────────────────────────
let lastTime = 0;

function update(dt) {
  if (state !== 'playing') return;

  elapsed += dt;
  distance += currentSpeed * dt;
  score = Math.floor(distance * 0.05) + (combo > 0 ? combo * 2 : 0);

  updatePhase();

  bgHue += dt * 8;

  // Wobble time decay
  const wDecayRate = phase >= 4 ? 1 : phase >= 2 ? 2 : 3;
  wobble = Math.max(0, wobble - wDecayRate * dt);

  // Move tiles
  const dy = currentSpeed * dt;
  tiles.forEach(t => { t.y += dy; t.pulse = Math.max(0, t.pulse - dt * 3); });

  // Pulse bump tiles near runner
  tiles.forEach(t => {
    if (t.type === 'bump' && !t.resolved) {
      const d = t.y - BEAM_Y;
      if (d > 0 && d < TILE_STEP * 2) t.pulse = Math.min(1, t.pulse + dt * 4);
    }
  });

  // Resolve tiles that scroll past runner without input (auto-fail)
  tiles.forEach(t => {
    if (!t.resolved && t.y > BEAM_Y + TILE_H * 0.8) {
      t.resolved = true;
      // Missed tile = wrong
      wobble += 12 + phase * 2;
      mistakes++;
      combo = 0;
      triggerShake(2, 10);
      spawnParticles(RUNNER_X, t.y, '#ff3366', 6, 2.5, 3);
      if (mistakes >= MAX_MISTAKES || wobble >= MAX_WOBBLE) triggerGameOver();
    }
  });

  // Remove off-screen tiles (below canvas)
  tiles = tiles.filter(t => t.y < H + 20);

  // Spawn new tiles
  const topTile = tiles.reduce((min, t) => t.y < min ? t.y : min, Infinity);
  while (topTile === Infinity || topTile > -TILE_STEP * 2) {
    const newY = (tiles.length === 0) ? BEAM_Y - 80 : Math.min(...tiles.map(t=>t.y)) - TILE_STEP;
    if (newY < -TILE_STEP * 3) break;
    spawnTile(newY);
    break; // one per frame is fine, loop handles rest via while condition recheck
  }

  // Actually let's just ensure enough tiles exist ahead
  let minY = tiles.reduce((m,t) => Math.min(m,t.y), Infinity);
  while (minY > -H * 0.5) {
    minY -= TILE_STEP;
    spawnTile(minY);
  }

  // Update particles
  particles.forEach(p => {
    p.x += p.vx; p.y += p.vy; p.vy += p.gravity;
    p.vx *= 0.97; p.life -= p.decay;
  });
  particles = particles.filter(p => p.life > 0);

  // Screen shake
  if (shakeDur > 0) {
    shakeDur--;
    shakeX = (rng()-0.5)*2*shakeMag;
    shakeY = (rng()-0.5)*2*shakeMag;
    if (shakeDur <= 0) { shakeX=0; shakeY=0; shakeMag=0; }
  }
}

// ─── DRAW ────────────────────────────────────────────────────────────────────
function drawBg() {
  const grd = ctx.createLinearGradient(0,0,0,H);
  grd.addColorStop(0, `hsl(${bgHue%360},40%,8%)`);
  grd.addColorStop(1, `hsl(${(bgHue+40)%360},50%,5%)`);
  ctx.fillStyle = grd;
  ctx.fillRect(0,0,W,H);
}

function drawBeam() {
  const wobbleX = (wobble / MAX_WOBBLE) * 20 * Math.sin(Date.now()*0.006);
  // Beam shadow
  ctx.save();
  ctx.shadowColor = `hsl(${bgHue%360},60%,40%)`;
  ctx.shadowBlur = 18;
  const grad = ctx.createLinearGradient(W/2-BEAM_W/2,0,W/2+BEAM_W/2,0);
  grad.addColorStop(0,  '#1a1040');
  grad.addColorStop(0.3,'#2a1a60');
  grad.addColorStop(0.7,'#2a1a60');
  grad.addColorStop(1,  '#1a1040');
  ctx.fillStyle = grad;
  ctx.fillRect(W/2 - BEAM_W/2 + wobbleX, 0, BEAM_W, H);
  ctx.restore();
}

function drawTile(t) {
  const col = t.foot === 0 ? LEFT_COLOR : RIGHT_COLOR;
  const cx = W/2;
  const tw = t.w;
  const tx = cx - tw/2;
  const ty = t.y - TILE_H/2;

  ctx.save();

  // Pulse glow for bumps
  if (t.type === 'bump' && t.pulse > 0) {
    ctx.shadowColor = '#ffcc44';
    ctx.shadowBlur = 10 + t.pulse * 20;
  } else {
    ctx.shadowColor = col;
    ctx.shadowBlur = 8;
  }

  // Tile body
  const tileGrad = ctx.createLinearGradient(tx, ty, tx, ty+TILE_H);
  tileGrad.addColorStop(0, col);
  tileGrad.addColorStop(1, col + '88');
  ctx.fillStyle = tileGrad;
  ctx.beginPath();
  ctx.roundRect(tx, ty, tw, TILE_H, 6);
  ctx.fill();

  // Gate marking
  if (t.type === 'gate') {
    ctx.strokeStyle = t.gateFavor === 0 ? LEFT_COLOR : RIGHT_COLOR;
    ctx.lineWidth = 2.5;
    ctx.setLineDash([4,3]);
    ctx.strokeRect(tx+2, ty+2, tw-4, TILE_H-4);
    ctx.setLineDash([]);
    // arrow
    ctx.fillStyle = '#fff8';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(t.gateFavor===0 ? '◀' : '▶', cx, t.y + 4);
  }

  // Bump marking
  if (t.type === 'bump') {
    ctx.fillStyle = '#ffcc44cc';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('!', cx, t.y + 4);
  }

  // Narrow indicator
  if (t.type === 'narrow') {
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 1;
    ctx.strokeRect(tx, ty, tw, TILE_H);
  }

  // Resolved marker
  if (t.resolved) {
    ctx.fillStyle = '#ffffff22';
    ctx.fillRect(tx, ty, tw, TILE_H);
  }

  ctx.restore();
}

function drawRunner() {
  const wobbleX = (wobble / MAX_WOBBLE) * 14 * Math.sin(Date.now()*0.007);
  const rx = RUNNER_X + wobbleX;
  const ry = BEAM_Y - 28;
  ctx.save();

  // Body glow
  ctx.shadowColor = `hsl(${bgHue%360},80%,70%)`;
  ctx.shadowBlur = 12;

  // Body
  ctx.fillStyle = '#e8d8ff';
  ctx.beginPath();
  ctx.ellipse(rx, ry, 10, 16, 0, 0, Math.PI*2);
  ctx.fill();

  // Head
  ctx.fillStyle = '#f0e0ff';
  ctx.beginPath();
  ctx.arc(rx, ry - 20, 10, 0, Math.PI*2);
  ctx.fill();

  // Feet indicators
  const leftActive  = currentFoot === 0;
  const rightActive = currentFoot === 1;
  ctx.fillStyle = leftActive  ? LEFT_COLOR  : LEFT_COLOR+'55';
  ctx.beginPath(); ctx.arc(rx - 8, BEAM_Y, 6, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = rightActive ? RIGHT_COLOR : RIGHT_COLOR+'55';
  ctx.beginPath(); ctx.arc(rx + 8, BEAM_Y, 6, 0, Math.PI*2); ctx.fill();

  ctx.restore();
}

function drawParticles() {
  particles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  });
}

function drawHUD() {
  // Score
  ctx.save();
  ctx.fillStyle = '#ffffffcc';
  ctx.font = 'bold 26px sans-serif';
  ctx.textAlign = 'right';
  ctx.fillText(score, W - 16, 40);

  ctx.fillStyle = '#9a80c0aa';
  ctx.font = '13px sans-serif';
  ctx.fillText('BEST ' + highScore, W - 16, 60);

  // Combo
  if (combo > 0) {
    ctx.fillStyle = combo >= 10 ? '#ffee55' : combo >= 5 ? '#88ffcc' : '#e8d8ff';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('x' + combo, 16, 40);
  }

  // Mistakes (hearts)
  for (let i = 0; i < MAX_MISTAKES; i++) {
    ctx.fillStyle = i < mistakes ? '#ff336666' : '#ff3366';
    ctx.font = '18px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('♥', 16 + i*24, 68);
  }

  // Wobble bar
  const bx = 16, by = 80, bw = 120, bh = 8;
  ctx.fillStyle = '#ffffff22';
  ctx.beginPath(); ctx.roundRect(bx, by, bw, bh, 4); ctx.fill();
  const wPct = Math.min(1, wobble / MAX_WOBBLE);
  const wColor = wPct > 0.7 ? '#ff4444' : wPct > 0.4 ? '#ffaa44' : '#44ff99';
  ctx.fillStyle = wColor;
  ctx.beginPath(); ctx.roundRect(bx, by, bw * wPct, bh, 4); ctx.fill();

  // Foot legend
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillStyle = LEFT_COLOR;
  ctx.fillText('◀ LEFT', 16, H - 28);
  ctx.fillStyle = RIGHT_COLOR;
  ctx.fillText('RIGHT ▶', W - 72, H - 28);

  // Phase label
  if (phase >= 5) {
    ctx.fillStyle = '#ffee55bb';
    ctx.font = 'bold 13px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('⚡ STORM PHASE ⚡', W/2, 95);
  }

  ctx.restore();
}

function drawStartScreen() {
  // Background
  const grd = ctx.createLinearGradient(0,0,0,H);
  grd.addColorStop(0,'#0d0618'); grd.addColorStop(1,'#1a0a30');
  ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);

  // Title
  ctx.save();
  ctx.textAlign = 'center';
  ctx.font = 'bold 52px sans-serif';
  const tg = ctx.createLinearGradient(W/2-100,0,W/2+100,0);
  tg.addColorStop(0, LEFT_COLOR);
  tg.addColorStop(1, RIGHT_COLOR);
  ctx.fillStyle = tg;
  ctx.shadowColor = '#aa66ff'; ctx.shadowBlur = 24;
  ctx.fillText('HUE WALK', W/2, H*0.3);
  ctx.shadowBlur = 0;

  ctx.fillStyle = '#c0b0e0';
  ctx.font = '18px sans-serif';
  ctx.fillText('Tightrope Color Walk', W/2, H*0.3+38);

  // Instructions
  ctx.fillStyle = '#9a80c0';
  ctx.font = '14px sans-serif';
  const lines = [
    'Tap to step — match tile colors!',
    '',
    `Blue tile → Left foot`,
    `Pink tile → Right foot`,
    '',
    '3 mistakes = fall',
  ];
  lines.forEach((l,i) => ctx.fillText(l, W/2, H*0.5 + i*24));

  // Color legend
  ctx.fillStyle = LEFT_COLOR;
  ctx.fillText('◀ LEFT = BLUE', W/2 - 10, H*0.7);
  ctx.fillStyle = RIGHT_COLOR;
  ctx.fillText('RIGHT = PINK ▶', W/2 + 10, H*0.7 + 26);

  // Best score
  if (highScore > 0) {
    ctx.fillStyle = '#ffee55aa';
    ctx.font = 'bold 14px sans-serif';
    ctx.fillText('BEST: ' + highScore, W/2, H*0.8);
  }

  // Tap to start
  const pulse = 0.7 + 0.3 * Math.sin(Date.now()*0.003);
  ctx.globalAlpha = pulse;
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 20px sans-serif';
  ctx.fillText('TAP TO START', W/2, H*0.88);
  ctx.globalAlpha = 1;

  ctx.restore();
}

function drawGameOverScreen() {
  ctx.save();
  ctx.fillStyle = '#00000088';
  ctx.fillRect(0,0,W,H);

  ctx.textAlign = 'center';
  ctx.font = 'bold 42px sans-serif';
  ctx.fillStyle = '#ff4466';
  ctx.shadowColor = '#ff2244'; ctx.shadowBlur = 20;
  ctx.fillText('FELL OFF!', W/2, H*0.35);
  ctx.shadowBlur = 0;

  ctx.font = 'bold 28px sans-serif';
  ctx.fillStyle = '#e8d8ff';
  ctx.fillText('Score: ' + score, W/2, H*0.46);

  if (score >= highScore) {
    ctx.fillStyle = '#ffee55';
    ctx.font = 'bold 18px sans-serif';
    ctx.fillText('NEW BEST!', W/2, H*0.54);
  } else {
    ctx.fillStyle = '#9a80c0';
    ctx.font = '16px sans-serif';
    ctx.fillText('Best: ' + highScore, W/2, H*0.54);
  }

  ctx.fillStyle = '#aaaaaa';
  ctx.font = '14px sans-serif';
  ctx.fillText('Combo reached: x' + combo, W/2, H*0.62);

  const pulse = 0.7 + 0.3 * Math.sin(Date.now()*0.003);
  ctx.globalAlpha = pulse;
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 20px sans-serif';
  ctx.fillText('TAP TO CONTINUE', W/2, H*0.75);
  ctx.globalAlpha = 1;

  ctx.restore();
}

// ─── MAIN LOOP ───────────────────────────────────────────────────────────────
function loop(ts) {
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;

  update(dt);

  ctx.save();
  ctx.translate(shakeX, shakeY);

  if (state === 'start') {
    drawStartScreen();
  } else if (state === 'playing' || state === 'gameover') {
    drawBg();
    drawBeam();
    tiles.forEach(drawTile);
    drawRunner();
    drawParticles();
    drawHUD();
    if (state === 'gameover') drawGameOverScreen();
  }

  ctx.restore();
  requestAnimationFrame(loop);
}

requestAnimationFrame(ts => { lastTime = ts; requestAnimationFrame(loop); });

})();
</script>
</body>
</html>
