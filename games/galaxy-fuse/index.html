<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Galaxy Fuse - Free HTML5 Game</title>
<meta name="description" content="Play Galaxy Fuse - Swipe to merge numbers into stars, then split them to create two smaller stars flying apart.">
<meta name="theme-color" content="#0a0a1a">
<meta name="robots" content="index, follow">
<link rel="canonical" href="https://balinti.github.io/galaxy-fuse/">
<meta property="og:type" content="website">
<meta property="og:title" content="Galaxy Fuse - Free HTML5 Game">
<meta property="og:description" content="Play Galaxy Fuse - Swipe to merge numbers into stars, then split them to create two smaller stars flying apart.">
<meta property="og:url" content="https://balinti.github.io/galaxy-fuse/">
<meta property="og:image" content="https://balinti.github.io/galaxy-fuse/og-1200x630.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Galaxy Fuse - Free HTML5 Game">
<meta name="twitter:description" content="Play Galaxy Fuse - Swipe to merge numbers into stars, then split them to create two smaller stars flying apart.">
<meta name="twitter:image" content="https://balinti.github.io/galaxy-fuse/og-1200x630.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow-x:hidden;background:#05050f;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#c8c8e0}
#game-wrap{position:relative;max-width:420px;margin:0 auto;display:flex;flex-direction:column;align-items:center;min-height:100vh;min-height:100dvh}
canvas{display:block;width:100%;max-width:420px;touch-action:none;border-radius:10px;margin-top:4px}
#overlay{display:none;position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}
#overlay.active{display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:auto}
#overlay .btn{background:linear-gradient(135deg,#6e3eff,#3ec6ff);border:none;color:#fff;padding:12px 28px;border-radius:24px;font-size:15px;font-weight:600;cursor:pointer;margin:6px;transition:transform .15s,box-shadow .15s;box-shadow:0 4px 18px rgba(62,198,255,.3)}
#overlay .btn:active{transform:scale(.95)}
#overlay .btn.secondary{background:rgba(255,255,255,.12);box-shadow:none}
#overlay .share-row{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap;justify-content:center}
#challenge-bar{display:none;text-align:center;font-size:13px;padding:6px 12px;background:rgba(110,62,255,.2);border-radius:8px;margin:6px 0;max-width:380px}
#challenge-bar.active{display:block}
details{max-width:420px;width:100%;padding:12px 16px;margin-top:8px;background:rgba(255,255,255,.04);border-radius:10px;font-size:13px;line-height:1.6}
details summary{cursor:pointer;font-weight:600;font-size:14px;color:#8888cc;list-style:none}
details summary::-webkit-details-marker{display:none}
details summary::before{content:'▸ ';transition:transform .2s}
details[open] summary::before{content:'▾ '}
details p{margin:6px 0;color:#9999bb}
details kbd{background:rgba(255,255,255,.1);padding:2px 6px;border-radius:4px;font-size:12px}
@media(max-height:600px){details{display:none}}
</style>
</head>
<body>
<div id="game-wrap">
<canvas id="c"></canvas>
<div id="challenge-bar"></div>
<div id="overlay">
<div class="share-row" id="share-row"></div>
</div>
<details>
<summary>About Galaxy Fuse</summary>
<p><strong>Controls:</strong> <kbd>Tap</kbd> or <kbd>Space</kbd>/<kbd>Enter</kbd> to drop a star. Tap a large star (level 3+) to split it.</p>
<p><strong>Goal:</strong> Merge matching stars to grow them. Don't let stars pile past the danger line!</p>
<p><strong>Tips:</strong> Chain merges quickly for combo multipliers. Splitting costs points but clears space. The black hole pulls stars down — use it strategically. Solar wind gusts start after 60 seconds.</p>
<p><strong>Keywords:</strong> Galaxy Fuse, merge game, drop game, space puzzle, hyper-casual, HTML5 game, free browser game, black hole, star merge, combo chain.</p>
</details>
</div>

<script>
'use strict';
(() => {

// ---- CONSTANTS ----
const MAX_W = 420, MAX_H = 750, PAD = 14;
const MAX_STARS = 70;
const MERGE_CD = 0.08, DROP_CD = 0.18;
const SPLIT_MAX = 3, SPLIT_RECHARGE = 18;
const DANGER_HOLD_LIMIT = 2.0;
const STAR_COLORS = [
  [320, 80, 60], // L1 pink
  [270, 75, 58], // L2 purple
  [210, 85, 55], // L3 blue
  [170, 80, 50], // L4 teal
  [130, 75, 50], // L5 green
  [55, 85, 52],  // L6 yellow
  [30, 90, 55],  // L7 orange
  [0, 85, 58],   // L8 red
  [290, 90, 65], // L9 magenta
  [200, 95, 65], // L10 cyan
];

// ---- CANVAS SETUP ----
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
const overlay = document.getElementById('overlay');
const shareRow = document.getElementById('share-row');
const challengeBar = document.getElementById('challenge-bar');

let DPR = Math.min(window.devicePixelRatio || 1, 2);
let W, H, tubeX, tubeY, tubeW, tubeH, dangerY, bhX, bhY;

function resize() {
  DPR = Math.min(window.devicePixelRatio || 1, 2);
  const wrap = document.getElementById('game-wrap');
  const vw = Math.min(wrap.clientWidth, MAX_W);
  const vh = Math.min(window.innerHeight * 0.88, MAX_H);
  W = vw; H = vh;
  cvs.width = W * DPR;
  cvs.height = H * DPR;
  cvs.style.width = W + 'px';
  cvs.style.height = H + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  tubeX = PAD; tubeY = PAD + 40;
  tubeW = W - PAD * 2; tubeH = H - tubeY - PAD;
  dangerY = tubeY + 86;
  bhX = tubeX + tubeW / 2;
  bhY = tubeY + tubeH + 10;
}
resize();
window.addEventListener('resize', resize);

// ---- CHALLENGE PARAMS ----
const urlP = new URLSearchParams(window.location.search);
const challengeScore = urlP.get('challengeScore') ? parseInt(urlP.get('challengeScore')) : null;
const challengeName = urlP.get('challengeName') || null;
if (challengeScore !== null) {
  challengeBar.classList.add('active');
  challengeBar.textContent = `${challengeName || 'Someone'} challenges you to beat ${challengeScore} points!`;
}

// ---- GAME STATE ----
let state = 'start'; // start, playing, gameover
let stars = [], particles = [];
let score = 0, bestScore = 0;
let gameTime = 0, swingAngle = 0;
let comboCount = 0, lastMergeTime = 0;
let splitCharges = SPLIT_MAX, splitTimer = 0;
let dangerHold = 0;
let dropCooldown = 0;
let shakeTime = 0, shakeIntensity = 0;
let nextStarLevel = 1;
let solarWindTimer = 0, solarWindDir = 0, solarWindActive = false, solarWindTelegraph = 0;
let pendingDrop = false;

try { bestScore = parseInt(localStorage.getItem('gf_best')) || 0; } catch(e) {}

// ---- STAR CLASS ----
function Star(x, y, level, vx, vy) {
  this.x = x; this.y = y; this.level = level;
  this.vx = vx || 0; this.vy = vy || 0;
  this.r = 10 + level * 4;
  this.mergeCd = 0;
  this.alive = true;
  this.flash = 0;
}

function starRadius(level) { return 10 + level * 4; }

function starColor(level) {
  const c = STAR_COLORS[(level - 1) % STAR_COLORS.length];
  return `hsl(${c[0]},${c[1]}%,${c[2]}%)`;
}

function starGlow(level) {
  const c = STAR_COLORS[(level - 1) % STAR_COLORS.length];
  return `hsla(${c[0]},${c[1]}%,${c[2]}%,0.3)`;
}

// ---- PARTICLES ----
function Particle(x, y, hue, speed, life) {
  this.x = x; this.y = y;
  const a = Math.random() * Math.PI * 2;
  const s = speed * (0.5 + Math.random());
  this.vx = Math.cos(a) * s;
  this.vy = Math.sin(a) * s;
  this.life = life || (0.4 + Math.random() * 0.5);
  this.maxLife = this.life;
  this.hue = hue;
  this.size = 2 + Math.random() * 3;
}

function spawnMergeParticles(x, y, level) {
  const hue = STAR_COLORS[(level - 1) % STAR_COLORS.length][0];
  for (let i = 0; i < 12 + level * 3; i++) {
    particles.push(new Particle(x, y, hue, 80 + level * 15, 0.5 + Math.random() * 0.4));
  }
}

function spawnSplitParticles(x, y, level) {
  const hue = STAR_COLORS[(level - 1) % STAR_COLORS.length][0];
  for (let i = 0; i < 8; i++) {
    particles.push(new Particle(x, y, hue, 50, 0.3));
  }
}

// ---- PHYSICS HELPERS ----
function gravity(t) { return 520 + 3.2 * t; }
function swingSpeed(t) { return 1.2 + 0.015 * t; }
function swingAmp() { return tubeW * 0.42; }
function pullScale(t) { return 1 + 0.012 * t; }
function comboWindow(t) { return 0.9 - Math.min(0.35, t * 0.002); }

function dropX() {
  return tubeX + tubeW / 2 + Math.sin(swingAngle) * swingAmp();
}

// ---- RESET ----
function resetGame() {
  stars = []; particles = [];
  score = 0; gameTime = 0; swingAngle = 0;
  comboCount = 0; lastMergeTime = 0;
  splitCharges = SPLIT_MAX; splitTimer = 0;
  dangerHold = 0; dropCooldown = 0;
  shakeTime = 0; shakeIntensity = 0;
  nextStarLevel = 1;
  solarWindTimer = 0; solarWindDir = 0; solarWindActive = false; solarWindTelegraph = 0;
  pendingDrop = false;
}

// ---- DROP STAR ----
function dropStar() {
  if (dropCooldown > 0 || stars.length >= MAX_STARS) return;
  const x = dropX();
  const level = nextStarLevel;
  const s = new Star(x, tubeY + 16, level, 0, 0);
  stars.push(s);
  dropCooldown = DROP_CD;
  nextStarLevel = Math.random() < 0.7 ? 1 : (Math.random() < 0.7 ? 2 : 3);
}

// ---- SPLIT STAR ----
function trySplit(tx, ty) {
  if (splitCharges <= 0) return false;
  for (let i = stars.length - 1; i >= 0; i--) {
    const s = stars[i];
    if (s.level < 3) continue;
    const dx = tx - s.x, dy = ty - s.y;
    const hitR = s.r * 1.15;
    if (dx * dx + dy * dy <= hitR * hitR) {
      splitCharges--;
      const newLevel = s.level - 1;
      const L = s.level;
      const baseUp = 220 + 12 * L;
      const side = 160 + 10 * L;
      const inherit = 0.35;
      const s1 = new Star(s.x, s.y, newLevel, -side + s.vx * inherit, -baseUp + s.vy * inherit);
      const s2 = new Star(s.x, s.y, newLevel, side + s.vx * inherit, -baseUp + s.vy * inherit);
      s1.mergeCd = 0.2; s2.mergeCd = 0.2;
      stars.splice(i, 1);
      stars.push(s1, s2);
      score = Math.max(0, score - 25 * L);
      comboCount = 0;
      spawnSplitParticles(s.x, s.y, L);
      shakeTime = 0.1; shakeIntensity = 3;
      return true;
    }
  }
  return false;
}

// ---- INPUT ----
function handleTap(cx, cy) {
  if (state === 'start') { state = 'playing'; resetGame(); overlay.classList.remove('active'); return; }
  if (state === 'gameover') { state = 'playing'; resetGame(); overlay.classList.remove('active'); return; }
  if (state === 'playing') {
    // Convert page coords to canvas coords
    const rect = cvs.getBoundingClientRect();
    const x = (cx - rect.left) * (W / rect.width);
    const y = (cy - rect.top) * (H / rect.height);
    if (!trySplit(x, y)) {
      dropStar();
    }
  }
}

cvs.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  handleTap(e.clientX, e.clientY);
});

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter') {
    e.preventDefault();
    if (state === 'start' || state === 'gameover') {
      state = 'playing'; resetGame(); overlay.classList.remove('active');
    } else if (state === 'playing') {
      dropStar();
    }
  }
});

// ---- UPDATE ----
function update(dt) {
  if (state !== 'playing') return;
  gameTime += dt;

  // Swing
  swingAngle += swingSpeed(gameTime) * dt;

  // Drop cooldown
  if (dropCooldown > 0) dropCooldown -= dt;

  // Split recharge
  splitTimer += dt;
  if (splitTimer >= SPLIT_RECHARGE && splitCharges < SPLIT_MAX) {
    splitCharges++;
    splitTimer = 0;
  }

  // Survival bonus
  score += 2 * dt;

  // Solar wind
  if (gameTime > 60) {
    solarWindTimer += dt;
    if (!solarWindActive && solarWindTimer > 8 + Math.random() * 6) {
      solarWindTelegraph = 1.2;
      solarWindDir = Math.random() < 0.5 ? -1 : 1;
      solarWindTimer = 0;
    }
    if (solarWindTelegraph > 0) {
      solarWindTelegraph -= dt;
      if (solarWindTelegraph <= 0) {
        solarWindActive = true;
        solarWindTimer = 0;
      }
    }
    if (solarWindActive) {
      solarWindTimer += dt;
      for (const s of stars) {
        s.vx += solarWindDir * 120 * dt;
      }
      if (solarWindTimer > 1.5) {
        solarWindActive = false;
        solarWindTimer = 0;
      }
    }
  }

  // Physics for each star
  const g = gravity(gameTime);
  const ps = pullScale(gameTime);

  for (const s of stars) {
    if (!s.alive) continue;
    // Gravity
    s.vy += g * dt;

    // Black hole pull
    const dx = bhX - s.x;
    const dy = bhY - s.y;
    const dist = Math.max(60, Math.sqrt(dx * dx + dy * dy));
    const pull = 8000 * ps / (dist * dist);
    s.vx += (dx / dist) * pull * dt;
    s.vy += (dy / dist) * pull * dt;

    // Move
    s.x += s.vx * dt;
    s.y += s.vy * dt;

    // Wall bounce
    const leftWall = tubeX + s.r;
    const rightWall = tubeX + tubeW - s.r;
    const bottomWall = tubeY + tubeH - s.r;

    if (s.x < leftWall) { s.x = leftWall; s.vx = Math.abs(s.vx) * 0.5; }
    if (s.x > rightWall) { s.x = rightWall; s.vx = -Math.abs(s.vx) * 0.5; }
    if (s.y > bottomWall) { s.y = bottomWall; s.vy = -Math.abs(s.vy) * 0.35; s.vx *= 0.9; }

    // Merge cooldown
    if (s.mergeCd > 0) s.mergeCd -= dt;
    if (s.flash > 0) s.flash -= dt;
  }

  // ---- COLLISIONS / MERGE ----
  for (let i = 0; i < stars.length; i++) {
    const a = stars[i];
    if (!a.alive) continue;
    for (let j = i + 1; j < stars.length; j++) {
      const b = stars[j];
      if (!b.alive) continue;
      const dx = b.x - a.x, dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const minD = a.r + b.r;
      if (dist < minD) {
        // Separate
        if (dist < 1) continue;
        const overlap = (minD - dist) / 2;
        const nx = dx / dist, ny = dy / dist;
        a.x -= nx * overlap;
        a.y -= ny * overlap;
        b.x += nx * overlap;
        b.y += ny * overlap;

        // Merge check
        if (a.level === b.level && a.mergeCd <= 0 && b.mergeCd <= 0) {
          const mx = (a.x + b.x) / 2;
          const my = (a.y + b.y) / 2;
          const newLevel = a.level + 1;
          const merged = new Star(mx, my, newLevel, (a.vx + b.vx) * 0.5, (a.vy + b.vy) * 0.5);
          merged.mergeCd = MERGE_CD;
          merged.flash = 0.3;
          a.alive = false;
          b.alive = false;
          stars.push(merged);

          // Combo
          const cw = comboWindow(gameTime);
          if (gameTime - lastMergeTime < cw) {
            comboCount++;
          } else {
            comboCount = 1;
          }
          lastMergeTime = gameTime;
          const mult = 1 + comboCount * 0.5;
          score += newLevel * 10 * mult;

          spawnMergeParticles(mx, my, newLevel);
          if (newLevel >= 5) { shakeTime = 0.15; shakeIntensity = 4; }
        } else {
          // Elastic push
          const relV = (a.vx - b.vx) * nx + (a.vy - b.vy) * ny;
          if (relV > 0) {
            a.vx -= nx * relV * 0.5;
            a.vy -= ny * relV * 0.5;
            b.vx += nx * relV * 0.5;
            b.vy += ny * relV * 0.5;
          }
        }
      }
    }
  }

  // Remove dead
  stars = stars.filter(s => s.alive);

  // ---- DANGER LINE ----
  let anyAbove = false;
  for (const s of stars) {
    if (s.y - s.r <= dangerY) {
      anyAbove = true;
      break;
    }
  }
  if (anyAbove) {
    dangerHold += dt;
  } else {
    dangerHold = Math.max(0, dangerHold - dt * 2.5);
  }
  if (dangerHold >= DANGER_HOLD_LIMIT) {
    gameOver();
  }

  // Particles
  for (const p of particles) {
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 100 * dt;
    p.life -= dt;
  }
  particles = particles.filter(p => p.life > 0);

  // Shake
  if (shakeTime > 0) shakeTime -= dt;
}

// ---- GAME OVER ----
function gameOver() {
  state = 'gameover';
  score = Math.floor(score);
  if (score > bestScore) {
    bestScore = score;
    try { localStorage.setItem('gf_best', bestScore); } catch(e) {}
  }
  shakeTime = 0.4; shakeIntensity = 8;

  // Show overlay with share buttons
  showGameOverOverlay();
}

function showGameOverOverlay() {
  overlay.classList.add('active');
  shareRow.innerHTML = '';

  const shareBtn = document.createElement('button');
  shareBtn.className = 'btn';
  shareBtn.textContent = 'Share Score';
  shareBtn.onclick = shareScore;
  shareRow.appendChild(shareBtn);

  const challengeBtn = document.createElement('button');
  challengeBtn.className = 'btn secondary';
  challengeBtn.textContent = 'Challenge a Friend';
  challengeBtn.onclick = challengeFriend;
  shareRow.appendChild(challengeBtn);
}

function shareScore() {
  const text = `I scored ${score} in Galaxy Fuse! Can you beat me?\nhttps://balinti.github.io/galaxy-fuse/`;
  if (navigator.share) {
    navigator.share({ title: 'Galaxy Fuse', text }).catch(() => {});
  } else {
    navigator.clipboard.writeText(text).then(() => {
      alert('Score copied to clipboard!');
    }).catch(() => {});
  }
}

function challengeFriend() {
  const name = 'Player';
  const url = `https://balinti.github.io/galaxy-fuse/?challengeScore=${score}&challengeName=${encodeURIComponent(name)}`;
  const text = `I challenge you to beat my ${score} points in Galaxy Fuse!\n${url}`;
  if (navigator.share) {
    navigator.share({ title: 'Galaxy Fuse Challenge', text }).catch(() => {});
  } else {
    navigator.clipboard.writeText(text).then(() => {
      alert('Challenge link copied!');
    }).catch(() => {});
  }
}

// ---- DRAW ----
function draw() {
  ctx.save();

  // Shake
  if (shakeTime > 0) {
    const sx = (Math.random() - 0.5) * shakeIntensity * 2;
    const sy = (Math.random() - 0.5) * shakeIntensity * 2;
    ctx.translate(sx, sy);
  }

  // Background
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#0a0a1e');
  grad.addColorStop(0.5, '#0d0826');
  grad.addColorStop(1, '#050510');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Tube bg
  ctx.fillStyle = 'rgba(10,10,30,0.7)';
  ctx.beginPath();
  ctx.roundRect(tubeX, tubeY, tubeW, tubeH, 8);
  ctx.fill();

  // Tube border
  ctx.strokeStyle = 'rgba(100,80,200,0.2)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.roundRect(tubeX, tubeY, tubeW, tubeH, 8);
  ctx.stroke();

  // Danger line
  const dangerAlpha = dangerHold > 0 ? 0.4 + 0.4 * Math.sin(gameTime * 8) : 0.15;
  ctx.strokeStyle = `rgba(255,60,60,${dangerAlpha})`;
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 4]);
  ctx.beginPath();
  ctx.moveTo(tubeX + 4, dangerY);
  ctx.lineTo(tubeX + tubeW - 4, dangerY);
  ctx.stroke();
  ctx.setLineDash([]);

  // Danger fill when in danger
  if (dangerHold > 0.3) {
    const a = Math.min(0.15, dangerHold * 0.06);
    ctx.fillStyle = `rgba(255,40,40,${a})`;
    ctx.fillRect(tubeX, tubeY, tubeW, dangerY - tubeY);
  }

  // Black hole glow
  const bhPulse = 0.6 + 0.2 * Math.sin(gameTime * 2);
  const bhGrad = ctx.createRadialGradient(bhX, bhY, 0, bhX, bhY, 60);
  bhGrad.addColorStop(0, `rgba(80,0,160,${bhPulse * 0.5})`);
  bhGrad.addColorStop(0.4, `rgba(40,0,100,${bhPulse * 0.25})`);
  bhGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = bhGrad;
  ctx.fillRect(bhX - 60, bhY - 60, 120, 120);

  // Solar wind telegraph
  if (solarWindTelegraph > 0) {
    const a = 0.15 * (solarWindTelegraph / 1.2);
    ctx.fillStyle = solarWindDir > 0 ? `rgba(255,200,50,${a})` : `rgba(50,200,255,${a})`;
    const wx = solarWindDir > 0 ? tubeX + tubeW - 30 : tubeX;
    ctx.fillRect(wx, tubeY, 30, tubeH);
  }

  // Solar wind active
  if (solarWindActive) {
    ctx.fillStyle = solarWindDir > 0 ? 'rgba(255,200,50,0.06)' : 'rgba(50,200,255,0.06)';
    ctx.fillRect(tubeX, tubeY, tubeW, tubeH);
    // Wind lines
    ctx.strokeStyle = solarWindDir > 0 ? 'rgba(255,200,50,0.15)' : 'rgba(50,200,255,0.15)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 6; i++) {
      const ly = tubeY + (tubeH * (i + 0.5) / 6) + Math.sin(gameTime * 3 + i) * 10;
      ctx.beginPath();
      ctx.moveTo(solarWindDir > 0 ? tubeX : tubeX + tubeW, ly);
      ctx.lineTo(solarWindDir > 0 ? tubeX + tubeW : tubeX, ly);
      ctx.stroke();
    }
  }

  // Drop indicator (pendulum)
  if (state === 'playing') {
    const dx = dropX();
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.arc(dx, tubeY + 10, 4, 0, Math.PI * 2);
    ctx.fill();

    // Dotted drop line
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 6]);
    ctx.beginPath();
    ctx.moveTo(dx, tubeY + 16);
    ctx.lineTo(dx, tubeY + 60);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Stars
  for (const s of stars) {
    const c = STAR_COLORS[(s.level - 1) % STAR_COLORS.length];
    // Outer glow
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r * 1.6, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${c[0]},${c[1]}%,${c[2]}%,0.12)`;
    ctx.fill();

    // Mid glow
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r * 1.2, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${c[0]},${c[1]}%,${c[2]}%,0.2)`;
    ctx.fill();

    // Core
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    const coreGrad = ctx.createRadialGradient(s.x - s.r * 0.3, s.y - s.r * 0.3, 0, s.x, s.y, s.r);
    coreGrad.addColorStop(0, `hsl(${c[0]},${c[1]}%,${Math.min(90, c[2] + 25)}%)`);
    coreGrad.addColorStop(1, `hsl(${c[0]},${c[1]}%,${c[2]}%)`);
    ctx.fillStyle = coreGrad;
    ctx.fill();

    // Flash on merge
    if (s.flash > 0) {
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r * (1 + s.flash * 2), 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255,255,255,${s.flash * 0.6})`;
      ctx.fill();
    }

    // Level number
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.max(10, s.r * 0.9)}px 'Segoe UI',sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(s.level, s.x, s.y + 1);
  }

  // Particles
  for (const p of particles) {
    const a = p.life / p.maxLife;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * a, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${p.hue},80%,65%,${a * 0.8})`;
    ctx.fill();
  }

  // ---- UI ----
  // Score
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 20px "Segoe UI",sans-serif';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText(Math.floor(score), PAD + 4, PAD + 6);

  // Best
  ctx.fillStyle = 'rgba(200,200,240,0.5)';
  ctx.font = '12px "Segoe UI",sans-serif';
  ctx.fillText(`BEST ${bestScore}`, PAD + 4, PAD + 28);

  // Combo
  if (comboCount > 1) {
    ctx.fillStyle = `hsla(${50 + comboCount * 20},90%,65%,${0.6 + 0.3 * Math.sin(gameTime * 6)})`;
    ctx.font = 'bold 14px "Segoe UI",sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`x${(1 + comboCount * 0.5).toFixed(1)} COMBO`, W / 2, PAD + 6);
  }

  // Split charges
  ctx.textAlign = 'right';
  ctx.fillStyle = 'rgba(200,200,240,0.6)';
  ctx.font = '12px "Segoe UI",sans-serif';
  ctx.fillText('SPLITS', W - PAD - 4, PAD + 6);
  for (let i = 0; i < SPLIT_MAX; i++) {
    const cx = W - PAD - 8 - i * 16;
    const cy = PAD + 28;
    ctx.beginPath();
    ctx.arc(cx, cy, 5, 0, Math.PI * 2);
    ctx.fillStyle = i < splitCharges ? 'rgba(100,200,255,0.8)' : 'rgba(100,100,140,0.3)';
    ctx.fill();
  }

  // Danger bar
  if (dangerHold > 0) {
    const bw = 60;
    const bx = W / 2 - bw / 2;
    const by = dangerY - 14;
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(bx, by, bw, 6);
    ctx.fillStyle = `rgba(255,${Math.floor(60 * (1 - dangerHold / DANGER_HOLD_LIMIT))},40,0.8)`;
    ctx.fillRect(bx, by, bw * Math.min(1, dangerHold / DANGER_HOLD_LIMIT), 6);
  }

  // ---- SCREEN STATES ----
  if (state === 'start') {
    drawScreenOverlay('Galaxy Fuse', null, 'Tap to Start');
  }
  if (state === 'gameover') {
    drawScreenOverlay('Game Over', `Score: ${Math.floor(score)}  |  Best: ${bestScore}`, 'Tap to Retry');
  }

  ctx.restore();
}

function drawScreenOverlay(title, subtitle, action) {
  // Dim
  ctx.fillStyle = 'rgba(5,5,15,0.7)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';

  // Title
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 32px "Segoe UI",sans-serif';
  ctx.fillText(title, W / 2, H * 0.32);

  // Subtitle
  if (subtitle) {
    ctx.fillStyle = 'rgba(200,200,240,0.8)';
    ctx.font = '16px "Segoe UI",sans-serif';
    ctx.fillText(subtitle, W / 2, H * 0.40);
  }

  // Challenge info
  if (challengeScore !== null) {
    const beat = score >= challengeScore;
    ctx.fillStyle = beat ? 'rgba(80,255,120,0.9)' : 'rgba(255,180,80,0.9)';
    ctx.font = '14px "Segoe UI",sans-serif';
    const msg = state === 'gameover'
      ? (beat ? `You beat ${challengeName || 'them'}!` : `${challengeName || 'They'} scored ${challengeScore}. Try again!`)
      : `Beat ${challengeName || 'them'}: ${challengeScore} pts`;
    ctx.fillText(msg, W / 2, H * 0.46);
  }

  // Action
  const pulse = 0.6 + 0.4 * Math.sin(performance.now() / 400);
  ctx.fillStyle = `rgba(200,200,255,${pulse})`;
  ctx.font = '18px "Segoe UI",sans-serif';
  ctx.fillText(action, W / 2, H * 0.56);

  // Stars decoration
  const t = performance.now() / 1000;
  for (let i = 0; i < 20; i++) {
    const sx = (W * 0.1) + (i * 37 + Math.sin(t + i * 0.7) * 15) % (W * 0.8);
    const sy = (H * 0.1) + (i * 53 + Math.cos(t * 0.5 + i) * 10) % (H * 0.8);
    const ss = 1 + Math.sin(t * 2 + i) * 0.5;
    ctx.beginPath();
    ctx.arc(sx, sy, ss, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(200,200,255,${0.15 + Math.sin(t + i) * 0.1})`;
    ctx.fill();
  }
}

// ---- MAIN LOOP ----
let lastTime = 0;
function loop(ts) {
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// Show start
overlay.classList.remove('active');
requestAnimationFrame((ts) => { lastTime = ts; loop(ts); });

})();
</script>
</body>
</html>
