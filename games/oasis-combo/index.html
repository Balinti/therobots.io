<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Oasis Combo - Free HTML5 Game</title>
  <meta name="description" content="Play Oasis Combo - Swipe to merge numbers on oasis stones, creating combos that multiply your score.">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#1a2a4a">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Oasis Combo - Free HTML5 Game">
  <meta property="og:description" content="Play Oasis Combo - Swipe to merge numbers on oasis stones, creating combos that multiply your score.">
  <meta property="og:url" content="https://balinti.github.io/oasis-combo/">
  <meta property="og:image" content="https://balinti.github.io/oasis-combo/preview.png">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Oasis Combo - Free HTML5 Game">
  <meta name="twitter:description" content="Swipe to merge numbers on oasis stones, creating combos that multiply your score.">
  <meta name="twitter:image" content="https://balinti.github.io/oasis-combo/preview.png">

  <!-- AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%;
      background: #0b1520;
      font-family: 'Segoe UI', Arial, sans-serif;
      color: #cce;
      overflow-x: hidden;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    #game-wrap {
      position: relative;
      width: 100%;
      max-width: 420px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #canvas-container {
      position: relative;
      width: 100%;
      max-width: 420px;
      touch-action: none;
      user-select: none;
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
    }
    /* SEO text below canvas */
    #seo-content {
      max-width: 420px;
      width: 100%;
      padding: 12px 16px 24px;
      color: #7899bb;
      font-size: 13px;
      line-height: 1.5;
    }
    #seo-content h1 {
      font-size: 18px;
      color: #aaccff;
      margin-bottom: 6px;
    }
    #seo-content h2 {
      font-size: 14px;
      color: #88aadd;
      margin: 10px 0 4px;
    }
    #seo-content a {
      color: #5599ff;
      text-decoration: none;
    }
    #seo-content a:hover { text-decoration: underline; }
    #seo-content ul { padding-left: 18px; }
    #seo-content li { margin-bottom: 3px; }
  </style>
</head>
<body>
<div id="game-wrap">
  <div id="canvas-container">
    <canvas id="gameCanvas"></canvas>
  </div>
  <div id="seo-content">
    <h1>Oasis Combo</h1>
    <p>A free browser-based merge puzzle game. Drop oasis stones into columns, merge matching tiers, and chain combos to multiply your score!</p>
    <h2>How to Play</h2>
    <ul>
      <li>Click or tap a column to drop the current stone</li>
      <li>Matching stones on top merge into a higher tier</li>
      <li>Merges release water that wets adjacent stones of the same tier</li>
      <li>Merge a wet stone before it dries to extend your Combo Streak</li>
      <li>Game ends when any column fills to the top</li>
      <li>Use ← → arrow keys to select a column, Space/Enter to drop</li>
    </ul>
    <p style="margin-top:8px;">
      <a href="https://balinti.github.io/oasis-combo/">Play Oasis Combo</a> &nbsp;|&nbsp;
      <a href="https://github.com/Balinti">More Games</a>
    </p>
  </div>
</div>

<script>
(function(){
"use strict";

// ─── Canvas setup ────────────────────────────────────────────────────────────
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const BASE_W = 420;
const BASE_H = 680;
let DPR = Math.min(window.devicePixelRatio || 1, 2);

function resizeCanvas() {
  DPR = Math.min(window.devicePixelRatio || 1, 2);
  const w = Math.min(window.innerWidth, BASE_W);
  canvas.width = w * DPR;
  canvas.height = BASE_H * DPR;
  canvas.style.width = w + 'px';
  canvas.style.height = BASE_H + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// ─── Constants ───────────────────────────────────────────────────────────────
const COLS = 5;
const ROWS = 9;
const PADDING_TOP = 90;   // score UI
const PADDING_BOT = 20;
const PADDING_SIDE = 14;
const GRID_W = BASE_W - PADDING_SIDE * 2;
const CELL_W = GRID_W / COLS;
const CELL_H = (BASE_H - PADDING_TOP - PADDING_BOT) / ROWS;
const STONE_R = Math.min(CELL_W, CELL_H) * 0.42;
const TOP_LINE_Y = PADDING_TOP + CELL_H * 0.5;

// Tier colours (HSL hue per tier 1-8+)
const TIER_HUES = [195, 160, 50, 30, 0, 280, 320, 60];
function tierColor(tier, alpha = 1, wet = false, blocked = false) {
  const idx = Math.min(tier - 1, TIER_HUES.length - 1);
  let hue = TIER_HUES[idx];
  let sat = blocked ? 10 : (wet ? 80 : 65);
  let lit = blocked ? 35 : (wet ? 60 : 52);
  return `hsla(${hue},${sat}%,${lit}%,${alpha})`;
}
function tierGlow(tier, wet = false) {
  const idx = Math.min(tier - 1, TIER_HUES.length - 1);
  let hue = wet ? 190 : TIER_HUES[idx];
  return `hsla(${hue},90%,72%,0.7)`;
}

// ─── Game state ──────────────────────────────────────────────────────────────
let state = 'start'; // 'start' | 'playing' | 'gameover'
let score = 0;
let bestScore = parseInt(localStorage.getItem('oasisCombo_best') || '0');
let combo = 0;
let comboTimer = 0;
let elapsed = 0;           // seconds since game start

// Grid: grid[col] = array of stone objects from bottom (index 0) to top
// stone: { tier, wet, wetTimer, blocked, squash, squashT, scale, scaleT }
let grid = [];
let fallingStone = null; // { col, tier, y, vy, landed }
let nextTier = 1;
let selectedCol = 2;

// Visual effects arrays
let particles = [];
let floaters = [];   // floating score text
let splashRings = [];
let shakeX = 0, shakeY = 0, shakeDur = 0;
let heatAlpha = 0;
let bgGoldT = 0;     // 0..1 background gold tint based on combo
let comboPopText = '';
let comboPopTimer = 0;
let comboPopScale = 1;

// Difficulty params
let dropInterval = 0;     // ms between auto-spawns (0 = manual only)
let wetDuration = 1000;   // ms
const DRY_TIMEOUT = 6000; // ms before dry stone blocks

// ─── Helpers ─────────────────────────────────────────────────────────────────
function colX(col) { return PADDING_SIDE + CELL_W * col + CELL_W / 2; }
function rowY(row) { return PADDING_TOP + CELL_H * (ROWS - 1 - row) + CELL_H / 2; }
function topOfColumn(col) { return rowY(grid[col].length - 1); }

function clamp(v, a, b) { return v < a ? a : v > b ? b : v; }
function lerp(a, b, t) { return a + (b - a) * t; }
function rand(a, b) { return a + Math.random() * (b - a); }
function randInt(a, b) { return Math.floor(rand(a, b + 1)); }

function spawnTier() {
  // Difficulty: after 30s introduce tier 3+
  let max = 1;
  if (elapsed > 10) max = 2;
  if (elapsed > 30) max = 3;
  if (elapsed > 60) max = 4;
  if (elapsed > 120) max = Math.min(5, 4 + Math.floor((elapsed - 120) / 60));
  return randInt(1, max);
}

function isDry() {
  // After 10s, ~20% dry stones; increases
  if (elapsed < 10) return false;
  const chance = Math.min(0.4, 0.1 + (elapsed - 10) * 0.004);
  return Math.random() < chance;
}

function updateDifficulty() {
  wetDuration = elapsed < 30 ? 1000 : elapsed < 60 ? lerp(1000, 700, (elapsed - 30) / 30) : 700;
}

function isNearTop() {
  for (let c = 0; c < COLS; c++) {
    if (grid[c].length >= ROWS - 1) return true;
  }
  return false;
}

// ─── Reset / Init ─────────────────────────────────────────────────────────────
function initGame() {
  grid = Array.from({ length: COLS }, () => []);
  fallingStone = null;
  particles = [];
  floaters = [];
  splashRings = [];
  score = 0;
  combo = 0;
  comboTimer = 0;
  elapsed = 0;
  shakeX = shakeY = shakeDur = 0;
  heatAlpha = 0;
  bgGoldT = 0;
  comboPopText = '';
  comboPopTimer = 0;
  wetDuration = 1000;
  selectedCol = 2;
  nextTier = spawnTier();
  spawnFalling();
  state = 'playing';
}

// ─── Falling stone ────────────────────────────────────────────────────────────
function spawnFalling() {
  const tier = nextTier;
  const dry = isDry();
  fallingStone = {
    col: selectedCol,
    tier,
    dry,
    blocked: false,
    y: PADDING_TOP - STONE_R,
    vy: 0,
    landed: false,
    squashScale: 1,
    squashX: 1,
    wetTimer: 0,
    wet: false,
  };
  nextTier = spawnTier();
}

function dropIntoColumn(col) {
  if (!fallingStone || fallingStone.landed) return;
  if (grid[col].length >= ROWS) return; // full
  fallingStone.col = col;
  selectedCol = col;
  fallingStone.vy = 18; // pixels/frame, will be updated by dt-based physics
  fallingStone.landing = true;
}

// ─── Merge logic ──────────────────────────────────────────────────────────────
function doMerge(col, rowIdx, chain) {
  const stone = grid[col][rowIdx];
  const below = rowIdx > 0 ? grid[col][rowIdx - 1] : null;
  if (!below || below.tier !== stone.tier || below.blocked) return false;

  // Merge: remove these two, push higher tier
  const newTier = stone.tier + 1;
  const newWet = stone.wet || below.wet;
  grid[col].splice(rowIdx - 1, 2, {
    tier: newTier,
    wet: false,
    wetTimer: 0,
    blocked: false,
    dryTimer: isDry() ? DRY_TIMEOUT : 0,
    squashScale: 1.4,
    squashX: 0.7,
    squashT: 0,
    scale: 1.3,
    scaleT: 0,
  });

  // Score
  const pts = newTier * 10 * Math.max(1, combo);
  score += pts;
  addFloater(colX(col), rowY(rowIdx - 1), `+${pts}`, tierColor(newTier, 1));

  // Water burst: wet adjacent same-tier stones
  wetBurst(col, newTier);

  // Particles
  spawnMergeParticles(colX(col), rowY(rowIdx - 1), newTier);

  // Combo
  if (newWet && combo > 0) {
    combo++;
    comboTimer = 2000;
    showComboPop(`x${combo}!`);
    spawnSplashRing(colX(col), rowY(rowIdx - 1));
  } else if (combo === 0) {
    combo = 1;
    comboTimer = 2000;
  }

  // Small shake on merge
  triggerShake(2, 80);

  // Cascade: check new merged stone against its neighbour above
  const newRowIdx = rowIdx - 1;
  if (newRowIdx + 1 < grid[col].length) {
    setTimeout(() => doMerge(col, newRowIdx + 1, chain + 1), 60);
  }
  return true;
}

function wetBurst(fromCol, tier) {
  for (let dc = -1; dc <= 1; dc++) {
    const c = fromCol + dc;
    if (c < 0 || c >= COLS) continue;
    for (let r = 0; r < grid[c].length; r++) {
      const s = grid[c][r];
      if (s.tier === tier && !s.blocked) {
        s.wet = true;
        s.wetTimer = wetDuration;
      }
    }
  }
}

// ─── Particles ────────────────────────────────────────────────────────────────
function spawnMergeParticles(x, y, tier) {
  const hue = TIER_HUES[Math.min(tier - 1, TIER_HUES.length - 1)];
  for (let i = 0; i < 18; i++) {
    const angle = rand(0, Math.PI * 2);
    const speed = rand(2, 7);
    const isSand = Math.random() < 0.5;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 2,
      r: isSand ? rand(2, 5) : rand(3, 7),
      life: 1,
      decay: rand(0.02, 0.045),
      color: isSand ? `hsl(45,70%,65%)` : `hsl(${hue},80%,65%)`,
      type: isSand ? 'sand' : 'water',
    });
  }
}

function spawnLandParticles(x, y, tier) {
  for (let i = 0; i < 8; i++) {
    const angle = rand(-Math.PI * 0.9, -Math.PI * 0.1);
    const speed = rand(1, 4);
    particles.push({
      x, y: y + STONE_R * 0.8,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      r: rand(1.5, 4),
      life: 1,
      decay: rand(0.03, 0.06),
      color: 'hsl(45,60%,60%)',
      type: 'sand',
    });
  }
}

function addFloater(x, y, text, color) {
  floaters.push({ x, y, text, color, life: 1, vy: -1.2 });
}

function spawnSplashRing(x, y) {
  splashRings.push({ x, y, r: 0, maxR: STONE_R * 2.2, life: 1 });
}

function showComboPop(text) {
  comboPopText = text;
  comboPopTimer = 900;
  comboPopScale = 1.6;
}

function triggerShake(mag, dur) {
  if (mag > shakeDur * 0.1) { // only override if bigger
    shakeX = rand(-mag, mag);
    shakeY = rand(-mag, mag);
    shakeDur = Math.max(shakeDur, dur);
  }
}

// ─── Update ───────────────────────────────────────────────────────────────────
let lastTime = 0;

function update(ts) {
  const dt = Math.min((ts - lastTime) / 1000, 0.05); // seconds, capped
  lastTime = ts;
  if (state !== 'playing') return;

  elapsed += dt;
  updateDifficulty();

  // Shake decay
  if (shakeDur > 0) {
    shakeDur -= dt * 1000;
    if (shakeDur <= 0) { shakeX = shakeY = 0; shakeDur = 0; }
    else { shakeX = rand(-shakeDur * 0.025, shakeDur * 0.025); shakeY = rand(-shakeDur * 0.025, shakeDur * 0.025); }
  }

  // Heat overlay
  const near = isNearTop();
  heatAlpha = near ? Math.min(heatAlpha + dt * 1.5, 0.18) : Math.max(heatAlpha - dt * 1.0, 0);

  // Near-top panic shake
  if (near && Math.random() < dt * 3) triggerShake(3, 100);

  // Combo timer
  if (comboTimer > 0) {
    comboTimer -= dt * 1000;
    if (comboTimer <= 0) { combo = 0; comboTimer = 0; }
  }
  if (comboPopTimer > 0) {
    comboPopTimer -= dt * 1000;
    comboPopScale = lerp(comboPopScale, 1.0, dt * 6);
  }

  // BG gold
  bgGoldT = clamp(lerp(bgGoldT, combo > 2 ? Math.min(1, (combo - 2) / 8) : 0, dt * 2), 0, 1);

  // Update grid stones
  for (let c = 0; c < COLS; c++) {
    for (let r = 0; r < grid[c].length; r++) {
      const s = grid[c][r];
      // Wet timer
      if (s.wet && s.wetTimer > 0) {
        s.wetTimer -= dt * 1000;
        if (s.wetTimer <= 0) { s.wet = false; s.wetTimer = 0; }
      }
      // Dry timer -> blocked
      if (!s.blocked && s.dryTimer > 0) {
        s.dryTimer -= dt * 1000;
        if (s.dryTimer <= 0) { s.blocked = true; }
      }
      // Squash recovery
      if (s.squashT < 1) {
        s.squashT = Math.min(1, s.squashT + dt * 8);
        const t = 1 - Math.pow(1 - s.squashT, 3);
        s.squashScale = lerp(s.squashScale || 1, 1, t);
        s.squashX = lerp(s.squashX || 1, 1, t);
      }
      if (s.scaleT < 1) {
        s.scaleT = Math.min(1, s.scaleT + dt * 5);
        const t = 1 - Math.pow(1 - s.scaleT, 3);
        s.scale = lerp(s.scale || 1, 1, t);
      }
    }
  }

  // Update falling stone
  if (fallingStone && !fallingStone.landed) {
    const GRAVITY = 900; // px/s²
    fallingStone.vy += GRAVITY * dt;
    fallingStone.y += fallingStone.vy * dt;

    // Target landing Y
    const col = fallingStone.col;
    const stackHeight = grid[col].length;
    const targetY = stackHeight < ROWS
      ? rowY(stackHeight)
      : PADDING_TOP + CELL_H * 0.5;

    if (fallingStone.y >= targetY) {
      fallingStone.y = targetY;
      fallingStone.landed = true;
      landStone();
    }
  }

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.18; // gravity
    p.life -= p.decay;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Floaters
  for (let i = floaters.length - 1; i >= 0; i--) {
    const f = floaters[i];
    f.y += f.vy;
    f.life -= 0.012;
    if (f.life <= 0) floaters.splice(i, 1);
  }

  // Splash rings
  for (let i = splashRings.length - 1; i >= 0; i--) {
    const sr = splashRings[i];
    sr.r += (sr.maxR - sr.r) * 0.15;
    sr.life -= 0.04;
    if (sr.life <= 0) splashRings.splice(i, 1);
  }
}

function landStone() {
  const col = fallingStone.col;
  if (grid[col].length >= ROWS) {
    // Column overflow → game over
    triggerShake(10, 400);
    gameOver();
    return;
  }

  // Squash/stretch on land
  const newStone = {
    tier: fallingStone.tier,
    wet: fallingStone.wet || false,
    wetTimer: fallingStone.wetTimer || 0,
    blocked: fallingStone.blocked || false,
    dryTimer: fallingStone.dry ? DRY_TIMEOUT : 0,
    squashScale: 0.5,
    squashX: 1.5,
    squashT: 0,
    scale: 1,
    scaleT: 1,
  };

  grid[col].push(newStone);
  spawnLandParticles(colX(col), fallingStone.y, fallingStone.tier);

  // Check merge with stone below (the one just placed is at top)
  const topIdx = grid[col].length - 1;
  const mergeHappened = topIdx > 0 && doMerge(col, topIdx, 0);

  // Check game-over condition (after potential merge, column might shrink)
  if (grid[col].length >= ROWS) {
    triggerShake(10, 400);
    gameOver();
    return;
  }

  fallingStone = null;
  setTimeout(spawnFalling, 150);
}

function gameOver() {
  state = 'gameover';
  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem('oasisCombo_best', bestScore);
  }
  triggerShake(12, 500);
  fallingStone = null;
}

// ─── Draw ─────────────────────────────────────────────────────────────────────
function draw() {
  ctx.save();

  // Background gradient
  const goldMix = bgGoldT * 0.35;
  const gr = ctx.createLinearGradient(0, 0, 0, BASE_H);
  gr.addColorStop(0, `hsl(${lerp(220, 40, goldMix)},${lerp(25, 50, goldMix)}%,${lerp(9, 14, goldMix)}%)`);
  gr.addColorStop(1, `hsl(${lerp(210, 30, goldMix)},${lerp(20, 45, goldMix)}%,${lerp(6, 10, goldMix)}%)`);
  ctx.fillStyle = gr;
  ctx.fillRect(0, 0, BASE_W, BASE_H);

  // Heat overlay
  if (heatAlpha > 0) {
    ctx.fillStyle = `rgba(255,80,30,${heatAlpha})`;
    ctx.fillRect(0, 0, BASE_W, BASE_H);
  }

  // Apply shake
  ctx.translate(shakeX, shakeY);

  drawGrid();
  drawSplashRings();
  drawParticles();
  drawFloaters();
  drawFallingStone();
  drawUI();

  if (state === 'start') drawStartScreen();
  if (state === 'gameover') drawGameOver();

  if (comboPopTimer > 0 && state === 'playing') drawComboPop();

  ctx.restore();
}

function drawGrid() {
  // Column guides
  for (let c = 0; c < COLS; c++) {
    ctx.strokeStyle = 'rgba(100,160,220,0.07)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(PADDING_SIDE + c * CELL_W, PADDING_TOP);
    ctx.lineTo(PADDING_SIDE + c * CELL_W, BASE_H - PADDING_BOT);
    ctx.stroke();
  }
  // Top danger line
  ctx.strokeStyle = 'rgba(255,80,60,0.35)';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([6, 4]);
  ctx.beginPath();
  ctx.moveTo(PADDING_SIDE, TOP_LINE_Y);
  ctx.lineTo(BASE_W - PADDING_SIDE, TOP_LINE_Y);
  ctx.stroke();
  ctx.setLineDash([]);

  // Stacked stones
  for (let c = 0; c < COLS; c++) {
    for (let r = 0; r < grid[c].length; r++) {
      drawStone(colX(c), rowY(r), grid[c][r]);
    }
  }
}

function drawStone(x, y, stone) {
  const sy = stone.squashScale || 1;
  const sx = stone.squashX || 1;
  const sc = stone.scale || 1;
  const R = STONE_R * sc;

  ctx.save();
  ctx.translate(x, y);
  ctx.scale(sx, sy);

  // Glow for wet stones
  if (stone.wet && !stone.blocked) {
    ctx.shadowColor = `hsl(190,90%,60%)`;
    ctx.shadowBlur = 14;
  } else if (!stone.blocked) {
    ctx.shadowColor = tierGlow(stone.tier);
    ctx.shadowBlur = 8;
  }

  // Main circle
  const grad = ctx.createRadialGradient(-R * 0.25, -R * 0.3, R * 0.1, 0, 0, R);
  if (stone.blocked) {
    grad.addColorStop(0, '#444');
    grad.addColorStop(1, '#222');
  } else if (stone.wet) {
    grad.addColorStop(0, `hsl(190,80%,72%)`);
    grad.addColorStop(1, `hsl(200,70%,42%)`);
  } else {
    const idx = Math.min(stone.tier - 1, TIER_HUES.length - 1);
    const hue = TIER_HUES[idx];
    grad.addColorStop(0, `hsl(${hue},80%,68%)`);
    grad.addColorStop(1, `hsl(${hue},60%,38%)`);
  }
  ctx.beginPath();
  ctx.arc(0, 0, R, 0, Math.PI * 2);
  ctx.fillStyle = grad;
  ctx.fill();

  // Crack lines for blocked/dry
  if (stone.blocked) {
    ctx.strokeStyle = 'rgba(255,255,200,0.25)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-R * 0.3, -R * 0.5); ctx.lineTo(R * 0.1, R * 0.3);
    ctx.moveTo(R * 0.2, -R * 0.4); ctx.lineTo(-R * 0.2, R * 0.5);
    ctx.stroke();
  }

  // Wet timer ring
  if (stone.wet && stone.wetTimer > 0) {
    const frac = stone.wetTimer / wetDuration;
    ctx.strokeStyle = `hsla(190,90%,70%,0.7)`;
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.arc(0, 0, R + 3, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * frac);
    ctx.stroke();
  }

  // Tier number
  const fs = R * (stone.tier >= 10 ? 0.52 : 0.62);
  ctx.fillStyle = stone.blocked ? '#777' : 'rgba(255,255,255,0.92)';
  ctx.font = `bold ${fs}px 'Segoe UI', Arial, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowBlur = 0;
  ctx.fillText(stone.tier, 0, 1);

  ctx.restore();
}

function drawFallingStone() {
  if (!fallingStone || fallingStone.landed) return;
  const x = colX(fallingStone.col);
  const y = fallingStone.y;

  // Ghost guide line
  const col = fallingStone.col;
  const stackH = grid[col].length;
  const landY = stackH < ROWS ? rowY(stackH) : rowY(ROWS - 1);
  ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  ctx.setLineDash([4, 6]);
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x, y + STONE_R);
  ctx.lineTo(x, landY - STONE_R);
  ctx.stroke();
  ctx.setLineDash([]);

  // Stone
  drawStone(x, y, {
    tier: fallingStone.tier,
    wet: false,
    blocked: fallingStone.blocked || false,
    dryTimer: fallingStone.dry ? 1 : 0,
    squashScale: 1,
    squashX: 1,
    scale: 1,
  });
}

function drawSplashRings() {
  for (const sr of splashRings) {
    ctx.strokeStyle = `rgba(100,210,255,${sr.life * 0.6})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(sr.x, sr.y, sr.r, 0, Math.PI * 2);
    ctx.stroke();
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = p.life;
    if (p.type === 'water') {
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.ellipse(p.x, p.y, p.r * 0.6, p.r, 0, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - p.r / 2, p.y - p.r / 2, p.r, p.r);
    }
  }
  ctx.globalAlpha = 1;
}

function drawFloaters() {
  for (const f of floaters) {
    ctx.globalAlpha = f.life;
    ctx.fillStyle = f.color;
    ctx.font = `bold 15px 'Segoe UI', Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = f.color;
    ctx.shadowBlur = 6;
    ctx.fillText(f.text, f.x, f.y);
    ctx.shadowBlur = 0;
  }
  ctx.globalAlpha = 1;
}

function drawUI() {
  if (state !== 'playing') return;

  // Score bar background
  ctx.fillStyle = 'rgba(10,20,40,0.75)';
  roundRect(ctx, PADDING_SIDE, 10, BASE_W - PADDING_SIDE * 2, 68, 12);
  ctx.fill();

  // Score
  ctx.fillStyle = '#c8e0ff';
  ctx.font = 'bold 13px "Segoe UI", Arial';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText('SCORE', PADDING_SIDE + 14, 18);
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 26px "Segoe UI", Arial';
  ctx.fillText(score.toLocaleString(), PADDING_SIDE + 14, 33);

  // Best
  ctx.fillStyle = '#c8e0ff';
  ctx.font = 'bold 13px "Segoe UI", Arial';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'top';
  ctx.fillText('BEST', BASE_W - PADDING_SIDE - 14, 18);
  ctx.fillStyle = '#aac8ff';
  ctx.font = 'bold 22px "Segoe UI", Arial';
  ctx.fillText(bestScore.toLocaleString(), BASE_W - PADDING_SIDE - 14, 33);

  // Combo bar
  if (combo > 1) {
    const barW = BASE_W - PADDING_SIDE * 2 - 28;
    const filled = Math.min(1, comboTimer / 2000);
    ctx.fillStyle = 'rgba(255,200,80,0.15)';
    roundRect(ctx, PADDING_SIDE + 14, 62, barW, 8, 4);
    ctx.fill();
    ctx.fillStyle = `hsl(${40 + combo * 5},90%,60%)`;
    roundRect(ctx, PADDING_SIDE + 14, 62, barW * filled, 8, 4);
    ctx.fill();

    ctx.fillStyle = '#ffe080';
    ctx.font = 'bold 11px "Segoe UI", Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`COMBO x${combo}`, BASE_W / 2, 66);
  }

  // Next stone preview
  const nx = BASE_W - PADDING_SIDE - 28;
  const ny = BASE_H - PADDING_BOT - 26;
  ctx.fillStyle = 'rgba(10,20,40,0.7)';
  roundRect(ctx, nx - 36, ny - 22, 72, 44, 10);
  ctx.fill();
  ctx.fillStyle = '#8aaccc';
  ctx.font = '10px "Segoe UI", Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText('NEXT', nx, ny - 20);
  drawStone(nx, ny + 4, { tier: nextTier, wet: false, blocked: false, squashScale: 1, squashX: 1, scale: 0.65 });

  // Column selector arrows
  const arrY = BASE_H - PADDING_BOT - 10;
  for (let c = 0; c < COLS; c++) {
    const cx = colX(c);
    if (c === selectedCol) {
      ctx.fillStyle = 'rgba(100,200,255,0.55)';
      ctx.beginPath();
      ctx.moveTo(cx, arrY - 14);
      ctx.lineTo(cx - 10, arrY);
      ctx.lineTo(cx + 10, arrY);
      ctx.closePath();
      ctx.fill();
    } else {
      ctx.fillStyle = 'rgba(100,150,200,0.18)';
      ctx.beginPath();
      ctx.moveTo(cx, arrY - 10);
      ctx.lineTo(cx - 7, arrY);
      ctx.lineTo(cx + 7, arrY);
      ctx.closePath();
      ctx.fill();
    }
  }
}

function drawComboPop() {
  const cx = BASE_W / 2;
  const cy = BASE_H / 2 - 60;
  ctx.save();
  ctx.translate(cx, cy);
  ctx.scale(comboPopScale, comboPopScale);
  ctx.globalAlpha = Math.min(1, comboPopTimer / 500);
  ctx.fillStyle = `hsl(${40 + combo * 8},100%,65%)`;
  ctx.strokeStyle = 'rgba(0,0,0,0.4)';
  ctx.lineWidth = 3;
  ctx.font = `bold 42px "Segoe UI", Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = `hsl(${40 + combo * 8},100%,70%)`;
  ctx.shadowBlur = 20;
  ctx.strokeText(comboPopText, 0, 0);
  ctx.fillText(comboPopText, 0, 0);
  ctx.restore();
  ctx.globalAlpha = 1;
}

function drawStartScreen() {
  // Overlay
  ctx.fillStyle = 'rgba(8,16,32,0.88)';
  ctx.fillRect(0, 0, BASE_W, BASE_H);

  // Title
  ctx.save();
  const titleGr = ctx.createLinearGradient(0, BASE_H * 0.28, 0, BASE_H * 0.38);
  titleGr.addColorStop(0, '#80d4ff');
  titleGr.addColorStop(1, '#4090ee');
  ctx.fillStyle = titleGr;
  ctx.font = 'bold 52px "Segoe UI", Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = '#40a0ff';
  ctx.shadowBlur = 24;
  ctx.fillText('OASIS', BASE_W / 2, BASE_H * 0.31);
  ctx.fillStyle = '#ffd060';
  ctx.shadowColor = '#ffb030';
  ctx.font = 'bold 36px "Segoe UI", Arial';
  ctx.fillText('COMBO', BASE_W / 2, BASE_H * 0.40);
  ctx.restore();

  // Tagline
  ctx.fillStyle = '#88aacc';
  ctx.font = '15px "Segoe UI", Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('Merge stones. Chain combos. Score big.', BASE_W / 2, BASE_H * 0.50);

  // Tap to start button
  const bx = BASE_W / 2, by = BASE_H * 0.62, bw = 200, bh = 52;
  ctx.fillStyle = 'rgba(60,130,220,0.85)';
  roundRect(ctx, bx - bw / 2, by - bh / 2, bw, bh, 26);
  ctx.fill();
  ctx.strokeStyle = '#80ccff';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 20px "Segoe UI", Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('TAP TO PLAY', bx, by);

  // Best
  if (bestScore > 0) {
    ctx.fillStyle = '#aaccee';
    ctx.font = '14px "Segoe UI", Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`Best: ${bestScore.toLocaleString()}`, BASE_W / 2, BASE_H * 0.73);
  }

  // Mini instructions
  ctx.fillStyle = '#5577aa';
  ctx.font = '12px "Segoe UI", Arial';
  ctx.textAlign = 'center';
  ctx.fillText('Tap column · ← → keys · Space/Enter to drop', BASE_W / 2, BASE_H * 0.82);
}

function drawGameOver() {
  ctx.fillStyle = 'rgba(8,16,32,0.92)';
  ctx.fillRect(0, 0, BASE_W, BASE_H);

  ctx.fillStyle = '#ff6655';
  ctx.font = 'bold 44px "Segoe UI", Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = '#ff4433';
  ctx.shadowBlur = 20;
  ctx.fillText('GAME OVER', BASE_W / 2, BASE_H * 0.28);
  ctx.shadowBlur = 0;

  ctx.fillStyle = '#ccddff';
  ctx.font = '16px "Segoe UI", Arial';
  ctx.fillText('SCORE', BASE_W / 2, BASE_H * 0.39);
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 40px "Segoe UI", Arial';
  ctx.fillText(score.toLocaleString(), BASE_W / 2, BASE_H * 0.46);

  if (score >= bestScore && score > 0) {
    ctx.fillStyle = '#ffd060';
    ctx.font = 'bold 15px "Segoe UI", Arial';
    ctx.fillText('★ NEW BEST! ★', BASE_W / 2, BASE_H * 0.535);
  } else {
    ctx.fillStyle = '#8899bb';
    ctx.font = '14px "Segoe UI", Arial';
    ctx.fillText(`Best: ${bestScore.toLocaleString()}`, BASE_W / 2, BASE_H * 0.535);
  }

  const bx = BASE_W / 2, by = BASE_H * 0.64, bw = 200, bh = 52;
  ctx.fillStyle = 'rgba(60,180,100,0.85)';
  roundRect(ctx, bx - bw / 2, by - bh / 2, bw, bh, 26);
  ctx.fill();
  ctx.strokeStyle = '#80ffaa';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 20px "Segoe UI", Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('PLAY AGAIN', bx, by);
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// ─── Game loop ────────────────────────────────────────────────────────────────
function loop(ts) {
  update(ts);
  draw();
  requestAnimationFrame(loop);
}

// ─── Input ────────────────────────────────────────────────────────────────────
function handleTap(px, py) {
  if (state === 'start') { initGame(); return; }
  if (state === 'gameover') { initGame(); return; }
  if (state === 'playing') {
    // Determine column from x position
    const canvasBounds = canvas.getBoundingClientRect();
    const scaleX = BASE_W / canvasBounds.width;
    const gx = px * scaleX;
    const col = Math.floor((gx - PADDING_SIDE) / CELL_W);
    if (col >= 0 && col < COLS) {
      if (!fallingStone) return;
      if (!fallingStone.landed) {
        dropIntoColumn(col);
      }
    }
  }
}

canvas.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  handleTap(e.clientX - rect.left, e.clientY - rect.top);
});

document.addEventListener('keydown', (e) => {
  if (state === 'start' || state === 'gameover') {
    if (['Space', 'Enter', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.code)) {
      initGame();
    }
    return;
  }
  if (state === 'playing') {
    if (e.code === 'ArrowLeft') {
      selectedCol = Math.max(0, selectedCol - 1);
      if (fallingStone) fallingStone.col = selectedCol;
    } else if (e.code === 'ArrowRight') {
      selectedCol = Math.min(COLS - 1, selectedCol + 1);
      if (fallingStone) fallingStone.col = selectedCol;
    } else if (e.code === 'Space' || e.code === 'Enter') {
      e.preventDefault();
      if (fallingStone && !fallingStone.landed) dropIntoColumn(selectedCol);
    }
  }
});

// Prevent default scroll on touch
document.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

// ─── Start ────────────────────────────────────────────────────────────────────
requestAnimationFrame((ts) => { lastTime = ts; loop(ts); });

})();
</script>
</body>
</html>
