<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Magma Beat - Free HTML5 Game</title>
  <meta name="description" content="Play Magma Beat - Tap precisely to the volcanic rhythm while the screen smoothly zooms in and out.">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#1a0a00">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Magma Beat - Free HTML5 Game">
  <meta property="og:description" content="Play Magma Beat - Tap precisely to the volcanic rhythm while the screen smoothly zooms in and out.">
  <meta property="og:url" content="https://balinti.github.io/magma-beat/">
  <meta property="og:image" content="https://balinti.github.io/magma-beat/og-image.png">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Magma Beat - Free HTML5 Game">
  <meta name="twitter:description" content="Play Magma Beat - Tap precisely to the volcanic rhythm.">
  <meta name="twitter:image" content="https://balinti.github.io/magma-beat/og-image.png">

  <!-- AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      width: 100%; height: 100%;
      background: #0d0500;
      color: #fff;
      font-family: 'Segoe UI', Arial, sans-serif;
      overflow-x: hidden;
      overflow-y: auto;
    }

    #ad-header {
      width: 100%; min-height: 50px;
      display: flex; align-items: center; justify-content: center;
      background: #0d0500;
      padding: 4px 0;
    }

    #game-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: calc(100vh - 50px);
      padding: 0 0 16px;
    }

    #game-container {
      position: relative;
      width: 100%;
      max-width: 420px;
      max-height: 750px;
      aspect-ratio: 420 / 750;
      overflow: hidden;
      border-radius: 12px;
      box-shadow: 0 0 40px #ff4400aa;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    #game-canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: pointer;
    }

    #share-btn {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,100,0,0.15);
      border: 1px solid rgba(255,100,0,0.5);
      color: #ffaa55;
      font-size: 13px;
      padding: 6px 18px;
      border-radius: 20px;
      cursor: pointer;
      display: none;
      z-index: 10;
      letter-spacing: 1px;
    }
    #share-btn:hover { background: rgba(255,100,0,0.3); }

    #info-section {
      width: 100%;
      max-width: 420px;
      margin-top: 16px;
      padding: 0 12px;
    }

    #info-toggle {
      background: none;
      border: 1px solid #444;
      color: #aaa;
      font-size: 13px;
      padding: 6px 14px;
      border-radius: 6px;
      cursor: pointer;
      width: 100%;
      text-align: left;
    }
    #info-toggle:hover { background: #1a0a00; border-color: #ff6600; color: #ff9955; }

    #info-content {
      display: none;
      margin-top: 10px;
      padding: 12px;
      background: #120600;
      border: 1px solid #332200;
      border-radius: 8px;
      font-size: 13px;
      color: #bba080;
      line-height: 1.7;
    }
    #info-content h3 { color: #ff8844; margin-bottom: 8px; font-size: 15px; }
    #info-content ul { padding-left: 16px; }
    #info-content li { margin-bottom: 4px; }
    #info-content p { margin-bottom: 8px; }
  </style>
</head>
<body>

<div id="ad-header">
  <!-- Ad placeholder â€“ AdSense auto ads will fill this -->
</div>

<div id="game-wrapper">
  <div id="game-container">
    <canvas id="game-canvas"></canvas>
    <button id="share-btn">&#x1F4E4; Share Score</button>
  </div>

  <div id="info-section">
    <button id="info-toggle">&#9660; How to Play / About</button>
    <div id="info-content">
      <h3>How to Play Magma Beat</h3>
      <p>A volcanic rhythm game where timing and precision are everything.</p>
      <ul>
        <li><strong>Watch</strong> the rotating safe wedge (bright slice) on the ring.</li>
        <li><strong>Watch</strong> the stamp cursor angle marker as it sweeps around.</li>
        <li><strong>Tap / press Space</strong> when the stamp cursor overlaps the safe wedge AND the beat pulse ring expands through it.</li>
        <li>Both conditions must be met for a <em>Perfect</em> or <em>Good</em> hit.</li>
        <li>Miss 3 times and the volcano erupts â€” game over!</li>
        <li>Build combos with Perfect hits to increase your Heat multiplier.</li>
      </ul>
      <p><strong>Outcomes:</strong> Perfect Â· Good Â· Early Â· Late Â· Wrong Zone</p>
      <p>Difficulty increases every 10 seconds â€” wedge narrows, rotation speeds up, and timing windows tighten. Can you survive the full eruption sequence?</p>
      <p><em>Magma Beat</em> is a free browser game. No download required.</p>
    </div>
  </div>
</div>

<script>
(function() {
'use strict';

// â”€â”€â”€ CONSTANTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CSS_W = 420, CSS_H = 750;
const CENTER_X = CSS_W / 2, CENTER_Y = CSS_H / 2 + 30;
const RING_RADIUS = 130;
const VOLCANO_R = 36;
const CRACK_MAX = 3;

// â”€â”€â”€ URL PARAMS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const urlParams = new URLSearchParams(window.location.search);
const challengeScore = urlParams.has('challenge') ? parseInt(urlParams.get('challenge'), 10) : null;

// â”€â”€â”€ CANVAS SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
let dpr = 1;

function resizeCanvas() {
  const container = document.getElementById('game-container');
  const rect = container.getBoundingClientRect();
  dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.height * dpr);
  // CSS size is handled by the container aspect-ratio CSS
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 200));

// Scale from CSS logical pixels to physical pixels
function getScale() {
  return canvas.width / CSS_W;
}

// â”€â”€â”€ AUDIO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let audioCtx = null;
let muted = true;

function ensureAudio() {
  if (!audioCtx) {
    try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {}
  }
}

function playThump(freq=80, dur=0.08, vol=0.25) {
  if (muted || !audioCtx) return;
  try {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(freq*0.4, audioCtx.currentTime + dur);
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur + 0.05);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + dur + 0.06);
  } catch(e) {}
}

function playHit(good=true) {
  if (muted || !audioCtx) return;
  try {
    const freq = good ? 440 : 220;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = good ? 'sine' : 'sawtooth';
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + 0.16);
  } catch(e) {}
}

// â”€â”€â”€ STATE MACHINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let state = 'start'; // 'start' | 'playing' | 'gameover'
let score = 0;
let bestScore = parseInt(localStorage.getItem('magmabeat_best') || '0', 10);
let combo = 0;
let heat = 1;
let cracks = 0;
let lastJudgement = '';
let lastJudgementTimer = 0;
let failReason = '';
let gameTime = 0; // seconds since game started
let hue = 0; // HSL color cycling

// â”€â”€â”€ DIFFICULTY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getDifficulty(t) {
  // t = gameTime in seconds
  let bpm, wedgeAngle, rotSpeed, beatWindow, timingWindow;

  if (t < 10) {
    // Onboarding
    bpm = 80 + t * 1;
    wedgeAngle = 80 - t * 1.5;
    rotSpeed = 0.6 + t * 0.03;
    timingWindow = 0.32;
  } else if (t < 25) {
    const p = (t - 10) / 15;
    bpm = 90 + p * 20;
    wedgeAngle = 65 - p * 20;
    rotSpeed = 0.9 + p * 0.5;
    timingWindow = 0.32 - p * 0.1;
  } else if (t < 45) {
    const p = (t - 25) / 20;
    bpm = 110 + p * 20;
    wedgeAngle = 45 - p * 12;
    rotSpeed = 1.4 + p * 0.6;
    timingWindow = 0.22 - p * 0.04;
  } else if (t < 70) {
    const p = (t - 45) / 25;
    bpm = 130 + p * 15;
    wedgeAngle = 33 - p * 8;
    rotSpeed = 2.0 + p * 0.8;
    timingWindow = 0.18 - p * 0.03;
  } else {
    const p = Math.min((t - 70) / 60, 1);
    bpm = 145 + p * 20;
    wedgeAngle = 25 - p * 5;
    rotSpeed = 2.8 + p * 1.5;
    timingWindow = 0.15;
  }

  wedgeAngle = Math.max(wedgeAngle, 18);
  timingWindow = Math.max(timingWindow, 0.12);

  return { bpm, wedgeAngle, rotSpeed, timingWindow };
}

// â”€â”€â”€ GAME ENTITIES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Beat pulse: expands outward from center
let pulses = []; // [{r, alpha}]
let beatPhase = 0; // 0..1, cycles per beat
let lastBeatPhase = 0;

// Safe wedge rotation
let wedgeAngle = 0; // current center angle of safe wedge in radians
let wedgeDir = 1; // rotation direction +1 or -1
let dirFlipTimer = 0; // countdown for direction flip

// Stamp cursor: visible angle that sweeps around the ring
let cursorAngle = 0; // radians, moves at a different (independent) speed
let cursorSpeed = 1.8; // rad/s

// Particles
let particles = [];

// Screen shake
let shakeX = 0, shakeY = 0, shakePow = 0, shakeDuration = 0, shakeTimer = 0;

// Micro-pulse squash
let microPulse = 1; // scale factor near 1

// Fake ember flashes (45-70s: visual noise)
let embers = [];

// Double pulse flag
let doublePulseActive = false;
let doublePulseTimer = 0;

function triggerShake(power, duration) {
  shakePow = power;
  shakeDuration = duration;
  shakeTimer = duration;
}

function addParticle(x, y, type) {
  const count = type === 'perfect' ? 18 : type === 'good' ? 10 : 8;
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = type === 'perfect' ? 2 + Math.random() * 4 :
                  type === 'miss'    ? 1 + Math.random() * 2.5 :
                                       1.5 + Math.random() * 2.5;
    const life = 0.5 + Math.random() * 0.6;
    const col = type === 'perfect' ? `hsl(${hue+40},100%,65%)` :
                type === 'good'    ? `hsl(${hue+20},90%,55%)` :
                                     `hsl(${hue+180},20%,60%)`;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life, maxLife: life,
      r: type === 'perfect' ? 3 + Math.random()*3 : 2 + Math.random()*2,
      col,
      type,
      gravity: type === 'miss' ? 0.08 : 0.02
    });
  }
}

function addEmber(x, y) {
  embers.push({ x, y, r: 2+Math.random()*3, life: 0.4+Math.random()*0.3, maxLife:0.7,
    vx: (Math.random()-0.5)*3, vy: -2-Math.random()*2, alpha: 1 });
}

function resetGame() {
  score = 0;
  combo = 0;
  heat = 1;
  cracks = 0;
  lastJudgement = '';
  lastJudgementTimer = 0;
  failReason = '';
  gameTime = 0;
  hue = 0;
  beatPhase = 0;
  lastBeatPhase = 0;
  wedgeAngle = 0;
  wedgeDir = 1;
  dirFlipTimer = 0;
  cursorAngle = -Math.PI / 2; // start at top
  pulses = [];
  particles = [];
  embers = [];
  shakeX = 0; shakeY = 0; shakePow = 0; shakeDuration = 0; shakeTimer = 0;
  microPulse = 1;
  doublePulseActive = false;
  doublePulseTimer = 0;
}

// â”€â”€â”€ JUDGEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function angleDiff(a, b) {
  // Returns shortest angular distance [-Ï€, Ï€]
  let d = ((a - b) % (Math.PI * 2) + Math.PI * 3) % (Math.PI * 2) - Math.PI;
  return d;
}

function judge(timestamp) {
  if (state !== 'playing') return;

  const diff = getDifficulty(gameTime);
  const wedgeHalf = (diff.wedgeAngle * Math.PI / 180) / 2;
  const timingWin = diff.timingWindow;

  // Zone check: is cursor angle inside safe wedge?
  const zoneOk = Math.abs(angleDiff(cursorAngle, wedgeAngle)) <= wedgeHalf;

  // Timing check: how far from the beat peak (beatPhase near 0 or near 1)?
  // beatPhase=0 means beat just fired, 0.5 is halfway. Window is around 0 (just fired).
  // We'll treat beatPhase < timingWin OR beatPhase > (1-timingWin) as "in window"
  const inWindow = beatPhase < timingWin || beatPhase > (1 - timingWin);
  const earlyLate = beatPhase < 0.5 ? 'Early' : 'Late';

  let judgement;
  if (!zoneOk) {
    judgement = 'Wrong Zone';
  } else if (inWindow) {
    // Perfect vs Good based on tightness
    const halfWindow = timingWin * 0.5;
    const isPerfect = beatPhase < halfWindow || beatPhase > (1 - halfWindow);
    judgement = isPerfect ? 'Perfect' : 'Good';
  } else {
    judgement = earlyLate;
  }

  // Apply judgement
  const stampX = CENTER_X + Math.cos(cursorAngle) * RING_RADIUS;
  const stampY = CENTER_Y + Math.sin(cursorAngle) * RING_RADIUS;

  lastJudgement = judgement;
  lastJudgementTimer = 1.2;

  if (judgement === 'Perfect') {
    combo++;
    heat = Math.min(1 + combo * 0.1, 4);
    score += Math.round(100 * heat);
    addParticle(stampX, stampY, 'perfect');
    triggerShake(2.5, 0.12);
    microPulse = 1.07;
    playHit(true);
  } else if (judgement === 'Good') {
    combo++;
    heat = Math.min(heat + 0.05, 4);
    score += Math.round(50 * heat);
    addParticle(stampX, stampY, 'good');
    triggerShake(1.0, 0.08);
    microPulse = 1.03;
    playHit(true);
  } else {
    // Miss
    combo = 0;
    heat = Math.max(1, heat - 0.3);
    cracks++;
    addParticle(stampX, stampY, 'miss');
    triggerShake(judgement === 'Wrong Zone' ? 7 : 5, 0.25);
    failReason = judgement;
    playHit(false);
    if (cracks >= CRACK_MAX) {
      endGame();
      return;
    }
  }
}

function endGame() {
  state = 'gameover';
  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem('magmabeat_best', bestScore);
  }
  triggerShake(18, 0.6);
  document.getElementById('share-btn').style.display = 'block';
}

// â”€â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleInput() {
  ensureAudio();
  if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  muted = false;

  if (state === 'start') {
    state = 'playing';
    resetGame();
  } else if (state === 'playing') {
    judge();
  } else if (state === 'gameover') {
    document.getElementById('share-btn').style.display = 'none';
    state = 'playing';
    resetGame();
  }
}

canvas.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  handleInput();
});

window.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter') {
    e.preventDefault();
    handleInput();
  }
});

// â”€â”€â”€ SHARE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('share-btn').addEventListener('click', (e) => {
  e.stopPropagation();
  const text = `I scored ${score} in Magma Beat! Can you beat me? ${window.location.origin + window.location.pathname}?challenge=${score}`;
  if (navigator.share) {
    navigator.share({ title: 'Magma Beat', text, url: window.location.origin + window.location.pathname + '?challenge=' + score });
  } else {
    navigator.clipboard.writeText(text).then(() => {
      const btn = document.getElementById('share-btn');
      btn.textContent = 'âœ“ Copied!';
      setTimeout(() => { btn.textContent = 'ðŸ“¤ Share Score'; }, 2000);
    }).catch(() => {});
  }
});

// â”€â”€â”€ INFO TOGGLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('info-toggle').addEventListener('click', () => {
  const c = document.getElementById('info-content');
  const btn = document.getElementById('info-toggle');
  if (c.style.display === 'block') {
    c.style.display = 'none';
    btn.textContent = 'â–¼ How to Play / About';
  } else {
    c.style.display = 'block';
    btn.textContent = 'â–² How to Play / About';
  }
});

// â”€â”€â”€ GAME LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastTime = null;

function update(dt) {
  if (state !== 'playing') return;

  gameTime += dt;
  hue = (hue + dt * 12) % 360;

  const diff = getDifficulty(gameTime);
  const bps = diff.bpm / 60; // beats per second

  lastBeatPhase = beatPhase;
  beatPhase = (beatPhase + bps * dt) % 1;

  // Beat fired when phase wraps around 0
  const beatFired = beatPhase < lastBeatPhase;
  if (beatFired) {
    // Spawn a new pulse ring
    pulses.push({ r: RING_RADIUS * 0.15, alpha: 1 });
    microPulse = 1 + 0.05;
    playThump(70 + diff.bpm * 0.3, 0.1, 0.2);
    triggerShake(0.3, 0.04);

    // Double pulse (25-70s)
    if (gameTime >= 25 && gameTime < 70 && Math.random() < 0.25) {
      doublePulseActive = true;
      doublePulseTimer = 60 / diff.bpm * 0.5; // half beat later
    }
  }

  // Double pulse
  if (doublePulseActive) {
    doublePulseTimer -= dt;
    if (doublePulseTimer <= 0) {
      doublePulseActive = false;
      pulses.push({ r: RING_RADIUS * 0.15, alpha: 0.55 });
    }
  }

  // Fake ember flashes (45-70s)
  if (gameTime >= 45 && gameTime < 70 && Math.random() < dt * 3) {
    const a = Math.random() * Math.PI * 2;
    const rr = RING_RADIUS * (1.3 + Math.random() * 0.5);
    addEmber(CENTER_X + Math.cos(a) * rr, CENTER_Y + Math.sin(a) * rr);
  }

  // Direction flip (70s+) every 4 beats occasionally
  if (gameTime >= 70) {
    dirFlipTimer -= dt;
    if (dirFlipTimer <= 0) {
      if (Math.random() < 0.3) wedgeDir *= -1;
      const nextFlip = (4 * 60 / diff.bpm);
      dirFlipTimer = nextFlip + Math.random() * nextFlip;
    }
  }

  // Rotate safe wedge
  wedgeAngle = (wedgeAngle + diff.rotSpeed * wedgeDir * dt) % (Math.PI * 2);
  if (wedgeAngle < 0) wedgeAngle += Math.PI * 2;

  // Sweep cursor at different speed (slightly offset from wedge)
  cursorSpeed = diff.rotSpeed * 1.35;
  cursorAngle = (cursorAngle + cursorSpeed * dt) % (Math.PI * 2);
  if (cursorAngle < 0) cursorAngle += Math.PI * 2;

  // Update pulses
  const pulseSpeed = RING_RADIUS * bps * 1.1;
  for (let i = pulses.length - 1; i >= 0; i--) {
    pulses[i].r += pulseSpeed * dt;
    pulses[i].alpha = Math.max(0, 1 - (pulses[i].r - RING_RADIUS*0.15) / (RING_RADIUS * 1.1));
    if (pulses[i].alpha <= 0 || pulses[i].r > RING_RADIUS * 2.5) pulses.splice(i, 1);
  }

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += p.gravity;
    p.vx *= 0.96;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Update embers
  for (let i = embers.length - 1; i >= 0; i--) {
    const e = embers[i];
    e.x += e.vx; e.y += e.vy;
    e.vy += 0.05;
    e.life -= dt;
    e.alpha = e.life / e.maxLife;
    if (e.life <= 0) embers.splice(i, 1);
  }

  // Decay micro-pulse
  microPulse += (1 - microPulse) * Math.min(1, dt * 14);

  // Screen shake decay
  if (shakeTimer > 0) {
    shakeTimer -= dt;
    const t = Math.max(0, shakeTimer / shakeDuration);
    const mag = shakePow * t;
    shakeX = (Math.random() - 0.5) * 2 * mag;
    shakeY = (Math.random() - 0.5) * 2 * mag;
  } else {
    shakeX = 0; shakeY = 0;
  }

  // Judgement text decay
  if (lastJudgementTimer > 0) lastJudgementTimer -= dt;
}

// â”€â”€â”€ DRAW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawRoundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

function draw() {
  const scale = getScale();
  ctx.save();
  ctx.setTransform(scale, 0, 0, scale, 0, 0);

  // â”€â”€ Background gradient â”€â”€
  const bg = ctx.createRadialGradient(CENTER_X, CENTER_Y, 10, CENTER_X, CENTER_Y, 420);
  bg.addColorStop(0, `hsl(${hue}, 80%, 10%)`);
  bg.addColorStop(0.6, `hsl(${hue+20}, 70%, 6%)`);
  bg.addColorStop(1, '#050200');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, CSS_W, CSS_H);

  // â”€â”€ Apply shake â”€â”€
  ctx.translate(shakeX, shakeY);

  if (state === 'start') {
    drawStartScreen();
  } else if (state === 'playing') {
    drawGame();
  } else {
    drawGame(); // draw faded game behind
    drawGameOver();
  }

  ctx.restore();
}

function drawStartScreen() {
  // Title
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Glowing title
  ctx.shadowColor = `hsl(${hue}, 100%, 60%)`;
  ctx.shadowBlur = 30;
  ctx.font = 'bold 52px Arial';
  ctx.fillStyle = `hsl(${hue}, 100%, 70%)`;
  ctx.fillText('MAGMA', CENTER_X, CENTER_Y - 80);
  ctx.fillText('BEAT', CENTER_X, CENTER_Y - 20);
  ctx.shadowBlur = 0;

  // Subtitle ring icon (animated)
  const t = Date.now() / 1000;
  const rr = 55 + Math.sin(t * 3) * 5;
  ctx.beginPath();
  ctx.arc(CENTER_X, CENTER_Y + 60, rr, 0, Math.PI * 2);
  ctx.strokeStyle = `hsl(${hue+30}, 100%, 65%)`;
  ctx.lineWidth = 3;
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(CENTER_X, CENTER_Y + 60, 12, 0, Math.PI * 2);
  ctx.fillStyle = `hsl(${hue}, 100%, 55%)`;
  ctx.fill();

  // Tap prompt
  const pulse = 0.7 + 0.3 * Math.sin(t * 4);
  ctx.globalAlpha = pulse;
  ctx.font = 'bold 20px Arial';
  ctx.fillStyle = '#fff';
  ctx.fillText('TAP TO START', CENTER_X, CENTER_Y + 160);
  ctx.globalAlpha = 1;

  // Best score
  if (bestScore > 0) {
    ctx.font = '16px Arial';
    ctx.fillStyle = '#aa7755';
    ctx.fillText(`Best: ${bestScore}`, CENTER_X, CENTER_Y + 195);
  }

  // Challenge
  if (challengeScore !== null) {
    ctx.font = 'bold 15px Arial';
    ctx.fillStyle = `hsl(${hue+60}, 100%, 70%)`;
    ctx.fillText(`Challenge: Beat ${challengeScore}!`, CENTER_X, CENTER_Y + 220);
  }

  ctx.restore();
}

function drawGame() {
  const diff = getDifficulty(gameTime);
  const wedgeHalf = (diff.wedgeAngle * Math.PI / 180) / 2;

  ctx.save();
  ctx.translate(CENTER_X, CENTER_Y);
  ctx.scale(microPulse, microPulse);
  ctx.translate(-CENTER_X, -CENTER_Y);

  // â”€â”€ Pulse rings â”€â”€
  for (const p of pulses) {
    ctx.beginPath();
    ctx.arc(CENTER_X, CENTER_Y, p.r, 0, Math.PI * 2);
    ctx.strokeStyle = `hsla(${hue}, 100%, 75%, ${p.alpha * 0.6})`;
    ctx.lineWidth = 3 * p.alpha + 1;
    ctx.stroke();
  }

  // â”€â”€ Main ring â”€â”€
  ctx.beginPath();
  ctx.arc(CENTER_X, CENTER_Y, RING_RADIUS, 0, Math.PI * 2);
  ctx.strokeStyle = `hsla(${hue+15}, 60%, 40%, 0.5)`;
  ctx.lineWidth = 8;
  ctx.stroke();

  // â”€â”€ Safe wedge arc â”€â”€
  const wedgeStart = wedgeAngle - wedgeHalf;
  const wedgeEnd = wedgeAngle + wedgeHalf;

  // Glow for safe wedge
  ctx.save();
  ctx.shadowColor = `hsl(${hue+60}, 100%, 80%)`;
  ctx.shadowBlur = 18;
  ctx.beginPath();
  ctx.arc(CENTER_X, CENTER_Y, RING_RADIUS, wedgeStart, wedgeEnd);
  ctx.strokeStyle = `hsl(${hue+60}, 100%, 80%)`;
  ctx.lineWidth = 10;
  ctx.lineCap = 'round';
  ctx.stroke();
  ctx.restore();

  // â”€â”€ Stamp cursor marker â”€â”€
  const cx = CENTER_X + Math.cos(cursorAngle) * RING_RADIUS;
  const cy = CENTER_Y + Math.sin(cursorAngle) * RING_RADIUS;

  // Is cursor in zone?
  const inZone = Math.abs(angleDiff(cursorAngle, wedgeAngle)) <= wedgeHalf;
  const inTiming = beatPhase < diff.timingWindow || beatPhase > (1 - diff.timingWindow);

  const cursorCol = inZone
    ? (inTiming ? `hsl(60, 100%, 70%)` : `hsl(${hue+90}, 100%, 65%)`)
    : `hsl(${hue+180}, 70%, 55%)`;

  ctx.save();
  ctx.shadowColor = cursorCol;
  ctx.shadowBlur = inZone ? 22 : 10;
  ctx.beginPath();
  ctx.arc(cx, cy, inZone ? 10 : 8, 0, Math.PI * 2);
  ctx.fillStyle = cursorCol;
  ctx.fill();
  // Inner dot
  ctx.beginPath();
  ctx.arc(cx, cy, 4, 0, Math.PI * 2);
  ctx.fillStyle = '#fff';
  ctx.fill();
  ctx.restore();

  // Cursor spoke line
  ctx.beginPath();
  ctx.moveTo(CENTER_X, CENTER_Y);
  ctx.lineTo(cx, cy);
  ctx.strokeStyle = `hsla(${hue+180}, 50%, 50%, 0.2)`;
  ctx.lineWidth = 1;
  ctx.stroke();

  ctx.restore(); // micro-pulse

  // â”€â”€ Embers (fake flashes) â”€â”€
  for (const e of embers) {
    ctx.save();
    ctx.globalAlpha = e.alpha * 0.7;
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
    ctx.fillStyle = `hsl(${hue+40}, 100%, 70%)`;
    ctx.fill();
    ctx.restore();
  }

  // â”€â”€ Particles â”€â”€
  for (const p of particles) {
    const t = p.life / p.maxLife;
    ctx.save();
    ctx.globalAlpha = t;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * t, 0, Math.PI * 2);
    ctx.fillStyle = p.col;
    ctx.fill();
    ctx.restore();
  }

  // â”€â”€ Volcano center â”€â”€
  {
    const pulseBeat = beatPhase < 0.15 ? (1 - beatPhase / 0.15) : 0;
    const vr = VOLCANO_R + pulseBeat * 8;
    const vGrad = ctx.createRadialGradient(CENTER_X, CENTER_Y, 0, CENTER_X, CENTER_Y, vr);
    vGrad.addColorStop(0, `hsl(${hue+10}, 100%, 80%)`);
    vGrad.addColorStop(0.5, `hsl(${hue}, 100%, 55%)`);
    vGrad.addColorStop(1, `hsl(${hue-10}, 80%, 25%)`);
    ctx.beginPath();
    ctx.arc(CENTER_X, CENTER_Y, vr, 0, Math.PI * 2);
    ctx.fillStyle = vGrad;
    ctx.fill();

    // Crater detail
    ctx.beginPath();
    ctx.arc(CENTER_X, CENTER_Y, vr * 0.45, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${hue+30}, 100%, 90%, ${0.4 + pulseBeat * 0.5})`;
    ctx.fill();
  }

  // â”€â”€ Crack indicators â”€â”€
  for (let i = 0; i < CRACK_MAX; i++) {
    const cx2 = CENTER_X - 20 + i * 20;
    const cy2 = CENTER_Y + RING_RADIUS + 30;
    ctx.beginPath();
    ctx.arc(cx2, cy2, 7, 0, Math.PI * 2);
    ctx.fillStyle = i < cracks ? `hsl(${hue}, 100%, 55%)` : 'rgba(255,255,255,0.15)';
    ctx.fill();
    if (i < cracks) {
      // Crack lines
      ctx.save();
      ctx.translate(cx2, cy2);
      ctx.strokeStyle = `hsl(${hue+20}, 80%, 80%)`;
      ctx.lineWidth = 1.5;
      for (let j = 0; j < 4; j++) {
        const a = (j / 4) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(a)*9, Math.sin(a)*9);
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  // â”€â”€ HUD â”€â”€
  // Score
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.font = 'bold 36px Arial';
  ctx.fillStyle = '#fff';
  ctx.shadowColor = `hsl(${hue}, 100%, 60%)`;
  ctx.shadowBlur = 12;
  ctx.fillText(score, CENTER_X, 55);
  ctx.shadowBlur = 0;

  // Heat multiplier
  if (heat > 1.05) {
    ctx.font = 'bold 15px Arial';
    ctx.fillStyle = `hsl(${hue+40}, 100%, 70%)`;
    ctx.fillText(`x${heat.toFixed(1)} HEAT`, CENTER_X, 95);
  }

  // Combo
  if (combo >= 3) {
    ctx.font = 'bold 14px Arial';
    ctx.fillStyle = `hsl(${hue+60}, 100%, 75%)`;
    ctx.fillText(`${combo} COMBO`, CENTER_X, 115);
  }

  // Beat timing bar (bottom)
  const barW = 160, barH = 8;
  const barX = CENTER_X - barW/2, barY = CENTER_Y + RING_RADIUS + 55;
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  drawRoundRect(barX, barY, barW, barH, 4);
  ctx.fill();
  // Phase indicator
  const phaseX = barX + beatPhase * barW;
  const diff2 = getDifficulty(gameTime);
  const winFrac = diff2.timingWindow;
  ctx.fillStyle = `hsla(${hue+60},100%,65%,0.4)`;
  ctx.fillRect(barX, barY, barW * winFrac, barH);
  ctx.fillRect(barX + barW * (1 - winFrac), barY, barW * winFrac, barH);
  ctx.beginPath();
  ctx.arc(phaseX, barY + barH/2, 5, 0, Math.PI * 2);
  ctx.fillStyle = `hsl(${hue+30},100%,70%)`;
  ctx.fill();

  // Judgement text
  if (lastJudgementTimer > 0) {
    const t = Math.min(lastJudgementTimer / 1.2, 1);
    const col = lastJudgement === 'Perfect' ? '#ffe060' :
                lastJudgement === 'Good' ? '#88ff88' :
                '#ff6644';
    ctx.save();
    ctx.globalAlpha = t;
    ctx.font = `bold ${22 + (1-t)*8}px Arial`;
    ctx.fillStyle = col;
    ctx.shadowColor = col;
    ctx.shadowBlur = 15;
    ctx.fillText(lastJudgement.toUpperCase(), CENTER_X, CENTER_Y - RING_RADIUS - 30);
    ctx.restore();
  }

  // Game time
  ctx.font = '12px Arial';
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.textAlign = 'right';
  ctx.fillText(`${Math.floor(gameTime)}s`, CSS_W - 12, 12);

  ctx.restore();
}

function drawGameOver() {
  // Overlay
  ctx.save();
  ctx.fillStyle = 'rgba(5, 2, 0, 0.78)';
  ctx.fillRect(0, 0, CSS_W, CSS_H);

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Title
  ctx.font = 'bold 42px Arial';
  ctx.fillStyle = `hsl(${hue}, 100%, 65%)`;
  ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
  ctx.shadowBlur = 25;
  ctx.fillText('ERUPTION!', CENTER_X, CENTER_Y - 155);
  ctx.shadowBlur = 0;

  // Score
  ctx.font = 'bold 64px Arial';
  ctx.fillStyle = '#fff';
  ctx.fillText(score, CENTER_X, CENTER_Y - 80);

  ctx.font = 'bold 16px Arial';
  ctx.fillStyle = '#ff9955';
  ctx.fillText(`BEST: ${bestScore}`, CENTER_X, CENTER_Y - 35);

  // Challenge
  if (challengeScore !== null) {
    const beat = score > challengeScore;
    ctx.font = 'bold 15px Arial';
    ctx.fillStyle = beat ? '#88ff88' : '#ff6644';
    ctx.fillText(beat ? `âœ“ Challenge beaten! (${challengeScore})` : `âœ— Challenge: ${challengeScore}`, CENTER_X, CENTER_Y - 10);
  }

  // Fail reason
  if (failReason) {
    ctx.font = '16px Arial';
    ctx.fillStyle = '#ff8844';
    ctx.fillText(`Failed: ${failReason}`, CENTER_X, CENTER_Y + 20);
  }

  // Cracks
  ctx.font = '14px Arial';
  ctx.fillStyle = '#aa6644';
  ctx.fillText(`${cracks}/${CRACK_MAX} cracks`, CENTER_X, CENTER_Y + 45);

  // Retry
  const t = Date.now() / 1000;
  const pulse = 0.75 + 0.25 * Math.sin(t * 3.5);
  ctx.globalAlpha = pulse;
  ctx.font = 'bold 22px Arial';
  ctx.fillStyle = '#fff';
  ctx.fillText('TAP TO RETRY', CENTER_X, CENTER_Y + 110);
  ctx.globalAlpha = 1;

  // Share hint
  ctx.font = '13px Arial';
  ctx.fillStyle = 'rgba(255,180,100,0.6)';
  ctx.fillText('or use Share button below', CENTER_X, CENTER_Y + 140);

  ctx.restore();
}

// â”€â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop(ts) {
  if (!lastTime) lastTime = ts;
  const dt = Math.min((ts - lastTime) / 1000, 0.05); // cap at 50ms
  lastTime = ts;

  update(dt);
  draw();

  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);

})();
</script>

</body>
</html>
