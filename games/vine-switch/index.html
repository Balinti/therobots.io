<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Vine Switch - Free HTML5 Game</title>
  <meta name="description" content="Play Vine Switch - Swipe to flip gravity while swinging on jungle vines that change colors instantly.">
  <meta name="theme-color" content="#0b1210">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Vine Switch - Free HTML5 Game">
  <meta property="og:description" content="Swipe to flip gravity while swinging on jungle vines that change colors instantly.">
  <meta property="og:url" content="https://balinti.github.io/vine-switch/">
  <meta property="og:image" content="https://balinti.github.io/vine-switch/og-image.png">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Vine Switch - Free HTML5 Game">
  <meta name="twitter:description" content="Swipe to flip gravity while swinging on jungle vines that change colors instantly.">
  <meta name="twitter:image" content="https://balinti.github.io/vine-switch/og-image.png">

  <!-- AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>

  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      background: #060a08;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    #game-container {
      position: relative;
      width: 100%;
      max-width: 420px;
      height: 100vh;
      max-height: 750px;
      margin: 0 auto;
      overflow: hidden;
      background: linear-gradient(180deg, #0b1210 0%, #0f1a15 50%, #0b1210 100%);
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Overlays */
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(6, 10, 8, 0.88);
      z-index: 10;
      transition: opacity 0.25s;
      pointer-events: auto;
    }
    .overlay.hidden { opacity: 0; pointer-events: none; }

    .overlay h1 {
      font-size: 2.4em;
      font-weight: 800;
      letter-spacing: -1px;
      margin-bottom: 6px;
      background: linear-gradient(135deg, #3dff8a, #b44dff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .overlay .subtitle {
      color: #7a9a88;
      font-size: 0.95em;
      margin-bottom: 28px;
      text-align: center;
      line-height: 1.5;
      max-width: 280px;
    }

    .overlay .score-display {
      font-size: 3em;
      font-weight: 800;
      color: #fff;
      margin: 8px 0 2px;
    }

    .overlay .score-label {
      color: #5a7a66;
      font-size: 0.85em;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .overlay .best-display {
      color: #b44dff;
      font-size: 1.1em;
      margin: 6px 0 10px;
    }

    .overlay .death-reason {
      color: #ff5a5a;
      font-size: 1em;
      margin-bottom: 18px;
      font-weight: 600;
    }

    .tap-prompt {
      color: #3dff8a;
      font-size: 1.15em;
      margin-top: 22px;
      animation: pulse 1.4s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    .share-btn {
      margin-top: 14px;
      padding: 8px 22px;
      background: rgba(180, 77, 255, 0.2);
      border: 1px solid rgba(180, 77, 255, 0.4);
      color: #c77dff;
      border-radius: 20px;
      font-size: 0.85em;
      cursor: pointer;
      transition: background 0.2s;
    }
    .share-btn:hover { background: rgba(180, 77, 255, 0.35); }

    .how-to {
      display: flex;
      gap: 16px;
      margin-bottom: 12px;
      color: #8ab89a;
      font-size: 0.82em;
      text-align: center;
    }
    .how-to div { max-width: 120px; line-height: 1.4; }
    .how-to .icon { font-size: 1.6em; display: block; margin-bottom: 4px; }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="gc"></canvas>

    <!-- Start Overlay -->
    <div class="overlay" id="start-overlay">
      <h1>Vine Switch</h1>
      <p class="subtitle">Color Gate Flip</p>
      <div class="how-to">
        <div><span class="icon">&#x1F3AF;</span>Match your color to the gate</div>
        <div><span class="icon">&#x1F504;</span>Tap to flip lane &amp; swap color</div>
        <div><span class="icon">&#x1F525;</span>Build streaks for multipliers</div>
      </div>
      <p class="tap-prompt">Tap to Start</p>
    </div>

    <!-- Game Over Overlay -->
    <div class="overlay hidden" id="gameover-overlay">
      <p class="death-reason" id="death-reason">Wrong color!</p>
      <p class="score-label">Score</p>
      <p class="score-display" id="final-score">0</p>
      <p class="best-display" id="final-best">Best: 0</p>
      <p class="tap-prompt">Tap to Retry</p>
      <button class="share-btn" id="share-btn">Share Score</button>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const DW = 420, DH = 750;                       // design dimensions
  const LS_KEY = "vineSwitchBest_v1";
  const GREEN_HUE = 145, PURPLE_HUE = 275;
  const LANE_TOP_Y = DH * 0.30, LANE_BOT_Y = DH * 0.70;
  const PLAYER_X = 90;
  const PLAYER_R = 16;

  // â”€â”€ DOM refs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const container = document.getElementById("game-container");
  const canvas    = document.getElementById("gc");
  const ctx       = canvas.getContext("2d");
  const startOv   = document.getElementById("start-overlay");
  const overOv    = document.getElementById("gameover-overlay");
  const deathEl   = document.getElementById("death-reason");
  const finalScEl = document.getElementById("final-score");
  const finalBsEl = document.getElementById("final-best");
  const shareBtn  = document.getElementById("share-btn");

  // â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let state = "start"; // start | playing | gameover
  let score, best, streak, multiplier;
  let playerLane; // 0 = top, 1 = bottom
  let playerColorIdx; // 0 = green, 1 = purple
  let gates, particles, bgVines, trail;
  let speed, gateTimer, gateInterval;
  let shakeX, shakeY, shakeDur;
  let hitStop, hitStopTimer;
  let deathReason;
  let elapsed; // total seconds of play
  let lastTime;

  // â”€â”€ Sizing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let scale = 1, dpr = 1;

  function resize() {
    const cw = container.clientWidth;
    const ch = container.clientHeight;
    dpr = Math.min(window.devicePixelRatio || 1, 3);
    scale = Math.min(cw / DW, ch / DH);
    canvas.width  = DW * dpr;
    canvas.height = DH * dpr;
    canvas.style.width  = (DW * scale) + "px";
    canvas.style.height = (DH * scale) + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();

  // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function laneY(lane) { return lane === 0 ? LANE_TOP_Y : LANE_BOT_Y; }

  function colorStr(idx, l, a) {
    const h = idx === 0 ? GREEN_HUE : PURPLE_HUE;
    return `hsla(${h}, 85%, ${l || 55}%, ${a !== undefined ? a : 1})`;
  }

  function lerp(a, b, t) { return a + (b - a) * t; }
  function rand(a, b) { return a + Math.random() * (b - a); }

  function loadBest() {
    try { best = parseInt(localStorage.getItem(LS_KEY)) || 0; } catch { best = 0; }
  }
  function saveBest() {
    try { localStorage.setItem(LS_KEY, best); } catch {}
  }

  // â”€â”€ Particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function spawnParticles(x, y, colorIdx, count) {
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const sp = rand(60, 200);
      particles.push({
        x, y,
        vx: Math.cos(angle) * sp,
        vy: Math.sin(angle) * sp,
        r: rand(2, 5),
        life: 1,
        decay: rand(1.2, 2.5),
        ci: colorIdx,
      });
    }
  }

  function updateParticles(dt) {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= p.decay * dt;
      p.r *= 0.995;
      if (p.life <= 0) particles.splice(i, 1);
    }
  }

  function drawParticles() {
    for (const p of particles) {
      ctx.globalAlpha = Math.max(0, p.life) * 0.8;
      ctx.fillStyle = colorStr(p.ci, 60);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // â”€â”€ Background vines (parallax) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function initBgVines() {
    bgVines = [];
    for (let i = 0; i < 12; i++) {
      bgVines.push({
        x: rand(0, DW),
        y: rand(0, DH),
        len: rand(80, 250),
        angle: rand(-0.3, 0.3),
        speed: rand(0.15, 0.4),
        alpha: rand(0.03, 0.08),
      });
    }
  }

  function updateBgVines(dt) {
    for (const v of bgVines) {
      v.x -= speed * v.speed * dt;
      if (v.x + v.len < 0) {
        v.x = DW + rand(0, 60);
        v.y = rand(0, DH);
        v.len = rand(80, 250);
      }
    }
  }

  function drawBgVines() {
    for (const v of bgVines) {
      ctx.strokeStyle = `rgba(61, 255, 138, ${v.alpha})`;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(v.x, v.y);
      ctx.lineTo(v.x + v.len * Math.cos(v.angle), v.y + v.len * Math.sin(v.angle));
      ctx.stroke();
    }
  }

  // â”€â”€ Trail â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function updateTrail() {
    const py = laneY(playerLane);
    trail.push({ x: PLAYER_X, y: py, life: 1, ci: playerColorIdx });
    if (trail.length > 30) trail.shift();
    for (let i = trail.length - 1; i >= 0; i--) {
      trail[i].life -= 0.06;
      if (trail[i].life <= 0) trail.splice(i, 1);
    }
  }

  function drawTrail() {
    for (const t of trail) {
      ctx.globalAlpha = t.life * 0.35;
      ctx.fillStyle = colorStr(t.ci, 55);
      ctx.beginPath();
      ctx.arc(t.x, t.y, PLAYER_R * t.life * 0.7, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // â”€â”€ Gate generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function difficulty() {
    // Returns a difficulty factor 0..1 based on score
    return Math.min(1, score / 80);
  }

  function gateSpeed() {
    return lerp(220, 460, difficulty());
  }

  function gateIntervalCalc() {
    return lerp(1.3, 0.55, difficulty());
  }

  function gateRingRadius() {
    return lerp(38, 26, difficulty());
  }

  function spawnGate() {
    const d = difficulty();
    let lane, ci;

    // After score 30, sometimes spawn double gates (both lanes)
    if (score >= 30 && Math.random() < 0.25) {
      const r = gateRingRadius();
      // Double gate: one on each lane, same or different colors
      const c1 = Math.random() < 0.5 ? 0 : 1;
      const c2 = Math.random() < 0.5 ? 0 : 1;
      gates.push({ x: DW + 60, lane: 0, ci: c1, r, passed: false });
      gates.push({ x: DW + 60, lane: 1, ci: c2, r, passed: false });
      return;
    }

    // After score 10, allow same-color repeats on same lane
    if (score >= 10 && Math.random() < 0.3 && gates.length > 0) {
      const last = gates[gates.length - 1];
      lane = last.lane;
      ci = last.ci;
    } else {
      lane = Math.random() < 0.5 ? 0 : 1;
      ci = Math.random() < 0.5 ? 0 : 1;
    }

    gates.push({
      x: DW + 60,
      lane,
      ci,
      r: gateRingRadius(),
      passed: false,
    });
  }

  // â”€â”€ Shake â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function triggerShake(dur, mag) {
    shakeDur = dur;
    shakeX = (Math.random() - 0.5) * mag;
    shakeY = (Math.random() - 0.5) * mag;
  }

  function updateShake(dt) {
    if (shakeDur > 0) {
      shakeDur -= dt;
      shakeX = (Math.random() - 0.5) * shakeDur * 30;
      shakeY = (Math.random() - 0.5) * shakeDur * 30;
    } else {
      shakeX = shakeY = 0;
    }
  }

  // â”€â”€ Multiplier calc â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function calcMultiplier() {
    if (streak >= 45) return 4;
    if (streak >= 25) return 3;
    if (streak >= 10) return 2;
    return 1;
  }

  // â”€â”€ Init / Reset â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function initGame() {
    loadBest();
    score = 0;
    streak = 0;
    multiplier = 1;
    playerLane = 1;       // start bottom
    playerColorIdx = 0;   // start green
    gates = [];
    particles = [];
    trail = [];
    speed = gateSpeed();
    gateTimer = 0;
    gateInterval = gateIntervalCalc();
    shakeX = shakeY = shakeDur = 0;
    hitStop = false;
    hitStopTimer = 0;
    deathReason = "";
    elapsed = 0;
    initBgVines();
  }

  // â”€â”€ Input: flip lane + swap color â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function flip() {
    if (state !== "playing") return;
    playerLane = playerLane === 0 ? 1 : 0;
    playerColorIdx = playerColorIdx === 0 ? 1 : 0;
    // Small trail burst on flip
    spawnParticles(PLAYER_X, laneY(playerLane), playerColorIdx, 4);
  }

  // â”€â”€ Collision / scoring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function checkGates(dt) {
    const px = PLAYER_X;
    const py = laneY(playerLane);
    const forgivePad = lerp(14, 5, difficulty());

    for (let i = gates.length - 1; i >= 0; i--) {
      const g = gates[i];

      // Gate passed player x without being scored
      if (!g.passed && g.x + g.r + forgivePad < px) {
        // Player was on this lane?
        if (playerLane === g.lane) {
          // They missed by being too late â€” end
          die("Missed ring!");
          return;
        }
        // Player was on other lane â€” gate just scrolls by (they dodged it basically)
        // But we need to check: player MUST go through gates.
        // Actually the rule is: every gate on either lane must be passed through correctly.
        // If player is on wrong lane entirely, they missed the ring.
        die("Missed ring!");
        return;
      }

      // Check if gate is crossing player x zone
      if (!g.passed && Math.abs(g.x - px) < g.r + forgivePad) {
        // Is player on the same lane?
        if (playerLane === g.lane) {
          // Check color match
          if (playerColorIdx === g.ci) {
            // SUCCESS
            g.passed = true;
            streak++;
            multiplier = calcMultiplier();
            score += multiplier;
            if (score > best) { best = score; saveBest(); }

            // Particles
            const pCount = streak % 10 === 0 ? 30 : (streak % 5 === 0 ? 18 : 8);
            spawnParticles(g.x, laneY(g.lane), g.ci, pCount);

            // Micro-shake on success
            triggerShake(0.08, 3);

            // Update speed/interval
            speed = gateSpeed();
            gateInterval = gateIntervalCalc();
          } else {
            // Wrong color
            die("Wrong color!");
            return;
          }
        }
        // Player on different lane â€” gate hasn't fully passed yet, wait
      }
    }

    // Remove off-screen gates
    for (let i = gates.length - 1; i >= 0; i--) {
      if (gates[i].x < -60) gates.splice(i, 1);
    }
  }

  function die(reason) {
    deathReason = reason;
    state = "gameover";
    hitStop = true;
    hitStopTimer = 0.12;
    triggerShake(0.5, 18);
    spawnParticles(PLAYER_X, laneY(playerLane), playerColorIdx, 25);
    showGameOver();
  }

  // â”€â”€ Drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function drawLanes() {
    // Lane lines
    ctx.strokeStyle = "rgba(61, 255, 138, 0.07)";
    ctx.lineWidth = 1;
    ctx.setLineDash([8, 12]);
    ctx.beginPath();
    ctx.moveTo(0, LANE_TOP_Y); ctx.lineTo(DW, LANE_TOP_Y);
    ctx.moveTo(0, LANE_BOT_Y); ctx.lineTo(DW, LANE_BOT_Y);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  function drawPlayer() {
    const px = PLAYER_X;
    const py = laneY(playerLane);

    // Glow
    const grad = ctx.createRadialGradient(px, py, 0, px, py, PLAYER_R * 2.5);
    grad.addColorStop(0, colorStr(playerColorIdx, 55, 0.25));
    grad.addColorStop(1, colorStr(playerColorIdx, 55, 0));
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(px, py, PLAYER_R * 2.5, 0, Math.PI * 2);
    ctx.fill();

    // Body
    ctx.fillStyle = colorStr(playerColorIdx, 58);
    ctx.beginPath();
    ctx.arc(px, py, PLAYER_R, 0, Math.PI * 2);
    ctx.fill();

    // Inner highlight
    ctx.fillStyle = colorStr(playerColorIdx, 75, 0.5);
    ctx.beginPath();
    ctx.arc(px - 3, py - 3, PLAYER_R * 0.45, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawGates() {
    for (const g of gates) {
      if (g.passed) continue;
      const gx = g.x;
      const gy = laneY(g.lane);

      // Outer glow
      ctx.strokeStyle = colorStr(g.ci, 50, 0.2);
      ctx.lineWidth = g.r * 0.35;
      ctx.beginPath();
      ctx.arc(gx, gy, g.r + 4, 0, Math.PI * 2);
      ctx.stroke();

      // Main ring
      ctx.strokeStyle = colorStr(g.ci, 60, 0.9);
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(gx, gy, g.r, 0, Math.PI * 2);
      ctx.stroke();

      // Inner ring
      ctx.strokeStyle = colorStr(g.ci, 70, 0.4);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(gx, gy, g.r * 0.65, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  function drawTether() {
    // Line from player to next upcoming gate
    let nearest = null;
    let nearDist = Infinity;
    for (const g of gates) {
      if (g.passed) continue;
      const d = g.x - PLAYER_X;
      if (d > 0 && d < nearDist) {
        nearDist = d;
        nearest = g;
      }
    }
    if (nearest) {
      const px = PLAYER_X, py = laneY(playerLane);
      const gx = nearest.x, gy = laneY(nearest.lane);
      ctx.strokeStyle = colorStr(playerColorIdx, 55, 0.15);
      ctx.lineWidth = 1.5;
      ctx.setLineDash([4, 6]);
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(gx, gy);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  function drawHUD() {
    // Score
    ctx.fillStyle = "#fff";
    ctx.font = "bold 28px 'Segoe UI', system-ui, sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(score, 18, 42);

    // Multiplier
    if (multiplier > 1) {
      ctx.fillStyle = colorStr(playerColorIdx, 65);
      ctx.font = "bold 18px 'Segoe UI', system-ui, sans-serif";
      ctx.fillText(`x${multiplier}`, 18, 66);

      // Streak bar
      const nextThresh = multiplier >= 4 ? 45 : multiplier >= 3 ? 45 : multiplier >= 2 ? 25 : 10;
      const prevThresh = multiplier >= 4 ? 45 : multiplier >= 3 ? 25 : multiplier >= 2 ? 10 : 0;
      const progress = Math.min(1, (streak - prevThresh) / (nextThresh - prevThresh));
      ctx.fillStyle = colorStr(playerColorIdx, 55, 0.2);
      ctx.fillRect(18, 74, 80, 4);
      ctx.fillStyle = colorStr(playerColorIdx, 55, 0.7);
      ctx.fillRect(18, 74, 80 * progress, 4);
    }

    // Best
    ctx.fillStyle = "rgba(180, 77, 255, 0.5)";
    ctx.font = "600 14px 'Segoe UI', system-ui, sans-serif";
    ctx.textAlign = "right";
    ctx.fillText(`Best: ${best}`, DW - 18, 38);
    ctx.textAlign = "left";
  }

  // â”€â”€ Overlays â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function showStart() {
    startOv.classList.remove("hidden");
    overOv.classList.add("hidden");
  }

  function showGameOver() {
    overOv.classList.remove("hidden");
    deathEl.textContent = deathReason;
    finalScEl.textContent = score;
    finalBsEl.textContent = `Best: ${best}`;
  }

  function hideOverlays() {
    startOv.classList.add("hidden");
    overOv.classList.add("hidden");
  }

  // â”€â”€ Share â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  shareBtn.addEventListener("click", async (e) => {
    e.stopPropagation();
    const text = `I scored ${score} in Vine Switch! ðŸŒ¿ Can you beat me?\nhttps://balinti.github.io/vine-switch/`;
    if (navigator.share) {
      try { await navigator.share({ title: "Vine Switch", text }); } catch {}
    } else {
      try {
        await navigator.clipboard.writeText(text);
        shareBtn.textContent = "Copied!";
        setTimeout(() => { shareBtn.textContent = "Share Score"; }, 1500);
      } catch {}
    }
  });

  // â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function handleTap(e) {
    // Ignore if clicking share button
    if (e && e.target && e.target.id === "share-btn") return;

    if (state === "start") {
      state = "playing";
      initGame();
      hideOverlays();
      lastTime = performance.now();
      return;
    }
    if (state === "gameover") {
      state = "playing";
      initGame();
      hideOverlays();
      lastTime = performance.now();
      return;
    }
    if (state === "playing") {
      flip();
    }
  }

  container.addEventListener("pointerdown", handleTap);
  document.addEventListener("keydown", (e) => {
    if (e.code === "Space" || e.code === "Enter") {
      e.preventDefault();
      handleTap(null);
    }
  });

  // â”€â”€ Game loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function update(dt) {
    if (hitStop) {
      hitStopTimer -= dt;
      if (hitStopTimer <= 0) hitStop = false;
      updateShake(dt);
      updateParticles(dt);
      return;
    }

    elapsed += dt;

    // Move gates
    const currentSpeed = gateSpeed();
    for (const g of gates) {
      g.x -= currentSpeed * dt;
    }

    // Spawn gates
    gateTimer += dt;
    if (gateTimer >= gateIntervalCalc()) {
      gateTimer = 0;
      spawnGate();
    }

    checkGates(dt);
    updateBgVines(dt);
    updateTrail();
    updateParticles(dt);
    updateShake(dt);
  }

  function draw() {
    ctx.save();
    ctx.translate(shakeX, shakeY);

    // Clear
    ctx.fillStyle = "#0b1210";
    ctx.fillRect(-20, -20, DW + 40, DH + 40);

    // Subtle gradient overlay
    const bgGrad = ctx.createLinearGradient(0, 0, 0, DH);
    bgGrad.addColorStop(0, "rgba(11, 18, 16, 1)");
    bgGrad.addColorStop(0.5, "rgba(15, 26, 21, 1)");
    bgGrad.addColorStop(1, "rgba(11, 18, 16, 1)");
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, DW, DH);

    drawBgVines();
    drawLanes();

    if (state === "playing" || state === "gameover") {
      drawTether();
      drawGates();
      drawTrail();
      drawPlayer();
      drawParticles();
      drawHUD();
    }

    ctx.restore();
  }

  let rafId;
  function loop(now) {
    rafId = requestAnimationFrame(loop);
    const dt = Math.min((now - lastTime) / 1000, 0.05);
    lastTime = now;

    if (state === "playing" || (state === "gameover" && (hitStop || shakeDur > 0 || particles.length > 0))) {
      update(dt);
    }
    draw();
  }

  // â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  loadBest();
  initGame();
  showStart();
  lastTime = performance.now();
  loop(lastTime);
})();
</script>
</body>
</html>
