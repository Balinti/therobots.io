<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Sugar Rush - Free HTML5 Game</title>
<meta name="description" content="Play Sugar Rush - Tap to merge number candies rapidly under intense time pressure.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#1a0030">
<meta property="og:type" content="website">
<meta property="og:title" content="Sugar Rush - Free HTML5 Game">
<meta property="og:description" content="Play Sugar Rush - Tap to merge number candies rapidly under intense time pressure.">
<meta property="og:url" content="https://balinti.github.io/sugar-rush/">
<meta property="og:image" content="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='1200' height='630' viewBox='0 0 1200 630'><defs><linearGradient id='bg' x1='0' y1='0' x2='1' y2='1'><stop offset='0%25' stop-color='%231a0030'/><stop offset='100%25' stop-color='%23330066'/></linearGradient></defs><rect width='1200' height='630' fill='url(%23bg)'/><text x='600' y='220' font-family='Arial Black,sans-serif' font-size='110' font-weight='900' text-anchor='middle' fill='%23ff69b4'>SUGAR</text><text x='600' y='360' font-family='Arial Black,sans-serif' font-size='110' font-weight='900' text-anchor='middle' fill='%23ffd700'>RUSH</text><text x='600' y='460' font-family='Arial,sans-serif' font-size='48' text-anchor='middle' fill='%23cc88ff'>Merge Candies &bull; Stack &amp; Combo</text><circle cx='200' cy='320' r='55' fill='%23ff4488' opacity='0.7'/><text x='200' y='337' font-family='Arial Black,sans-serif' font-size='42' text-anchor='middle' fill='white'>8</text><circle cx='400' cy='280' r='55' fill='%23ff8800' opacity='0.7'/><text x='400' y='297' font-family='Arial Black,sans-serif' font-size='42' text-anchor='middle' fill='white'>4</text><circle cx='1000' cy='300' r='55' fill='%2300ccff' opacity='0.7'/><text x='1000' y='317' font-family='Arial Black,sans-serif' font-size='42' text-anchor='middle' fill='white'>16</text><circle cx='800' cy='260' r='55' fill='%2300ff88' opacity='0.7'/><text x='800' y='277' font-family='Arial Black,sans-serif' font-size='42' text-anchor='middle' fill='white'>32</text></svg>">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Sugar Rush - Free HTML5 Game">
<meta name="twitter:description" content="Play Sugar Rush - Tap to merge number candies rapidly under intense time pressure.">
<meta name="twitter:image" content="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='1200' height='630' viewBox='0 0 1200 630'><rect width='1200' height='630' fill='%231a0030'/><text x='600' y='300' font-family='Arial Black' font-size='110' text-anchor='middle' fill='%23ff69b4'>SUGAR RUSH</text></svg>">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "VideoGame",
  "name": "Sugar Rush",
  "description": "Tap to merge number candies rapidly under intense time pressure in this hyper-casual HTML5 game.",
  "genre": "Hyper-Casual",
  "playMode": "SinglePlayer",
  "url": "https://balinti.github.io/sugar-rush/",
  "applicationCategory": "Game",
  "operatingSystem": "Any",
  "offers": {"@type": "Offer", "price": "0", "priceCurrency": "USD"}
}
</script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;background:#0d001a;font-family:'Segoe UI',Arial,sans-serif;overflow:hidden;touch-action:none}
body{display:flex;flex-direction:column;align-items:center;justify-content:flex-start;background:radial-gradient(ellipse at 50% 0%,#2d0050 0%,#0d001a 70%)}
#game-wrap{position:relative;width:100%;max-width:420px;height:100vh;max-height:750px;display:flex;flex-direction:column;align-items:stretch;overflow:hidden}
#hud-top{height:64px;display:flex;align-items:center;justify-content:space-between;padding:0 14px;background:rgba(0,0,0,0.35);border-bottom:1px solid rgba(255,255,255,0.07);flex-shrink:0;z-index:10}
#hud-bottom{height:72px;display:flex;align-items:center;justify-content:center;padding:0 14px;background:rgba(0,0,0,0.35);border-top:1px solid rgba(255,255,255,0.07);flex-shrink:0;z-index:10}
canvas{display:block;flex:1;width:100%;cursor:pointer}
.hud-block{display:flex;flex-direction:column;align-items:center;gap:2px}
.hud-label{font-size:10px;text-transform:uppercase;letter-spacing:1.5px;color:rgba(255,255,255,0.45);font-weight:600}
.hud-val{font-size:22px;font-weight:900;color:#fff;text-shadow:0 0 12px rgba(255,150,255,0.6);letter-spacing:-0.5px}
#streak-wrap{display:flex;flex-direction:column;align-items:center;gap:3px}
#streak-bar-bg{width:64px;height:6px;background:rgba(255,255,255,0.12);border-radius:3px;overflow:hidden}
#streak-bar{height:100%;width:0%;background:linear-gradient(90deg,#ff69b4,#ffd700);border-radius:3px;transition:width 0.1s}
#btn-sound{background:none;border:1px solid rgba(255,255,255,0.2);color:rgba(255,255,255,0.55);font-size:18px;width:36px;height:36px;border-radius:50%;cursor:pointer;transition:all 0.2s;display:flex;align-items:center;justify-content:center}
#btn-sound:hover{border-color:rgba(255,255,255,0.5);color:#fff}
#info-section{display:none;position:absolute;bottom:-9999px}
</style>
</head>
<body>
<div id="game-wrap">
  <div id="hud-top">
    <div class="hud-block">
      <span class="hud-label">Score</span>
      <span class="hud-val" id="hud-score">0</span>
    </div>
    <div id="streak-wrap">
      <span class="hud-label">Sugar Streak</span>
      <div id="streak-bar-bg"><div id="streak-bar"></div></div>
      <span style="font-size:11px;color:#ffd700;font-weight:700" id="hud-streak">x1.0</span>
    </div>
    <div class="hud-block">
      <span class="hud-label">Best</span>
      <span class="hud-val" id="hud-best">0</span>
    </div>
  </div>
  <canvas id="gc"></canvas>
  <div id="hud-bottom">
    <button id="btn-sound" title="Toggle Sound">ðŸ”‡</button>
  </div>
</div>

<div id="info-section" aria-hidden="true">
  <h2>How to Play Sugar Rush</h2>
  <p>Tap or press Space/Enter to switch lanes. Candies fall into the selected lane and stack from the bottom. When two candies with the same number land on each other, they merge into the next value. Chain merges give combo bonuses!</p>
  <h3>Tips</h3>
  <ul>
    <li>Keep your Sugar Streak alive for score multipliers.</li>
    <li>Watch out when lanes get full â€” game over if a stack reaches the top!</li>
    <li>After 60 seconds, hard candies appear that require chain merges.</li>
  </ul>
  <h3>About Sugar Rush</h3>
  <p>Sugar Rush is a free hyper-casual HTML5 game. No download needed â€” play instantly in your browser.</p>
</div>

<script>
(function(){
'use strict';

// â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const LANES       = 3;
const HUD_TOP_H   = 64;
const HUD_BOTTOM_H= 72;
const TOP_LINE    = 18;  // cells from top that trigger game over
const MAX_STACK   = 18;  // max cells per lane
const DPR         = Math.min(window.devicePixelRatio||1, 2);
const SHARE_URL   = 'https://balinti.github.io/sugar-rush/';
const LS_HS       = 'SR_HS';
const LS_BESTVAL  = 'SR_BESTVAL';

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let state = 'start'; // 'start' | 'playing' | 'gameover'
let score = 0, bestScore = 0, bestVal = 1, bestCombo = 0;
let t = 0; // seconds alive
let cursor = 0; // 0,1,2
let lanes = [[],[],[]]; // each: array of {val, hard, hue, sq}
let fallingCandy = null;
// {lane, y, vy, val, hard, hue, trail:[]}
let particles = [];
let shakeAmt = 0, shakeDX = 0, shakeDY = 0;
let spawnTimer = 0;
let streakMeter = 0; // 0..1
let streakMult = 1.0;
let pendingMergeOnDrop = false;
let comboChain = 0; // per-drop chain count
let comboMult  = 1.0;
let rng = null; // seeded RNG for challenge mode
let seedMode = false;
let seedDrops = [];
let dropIdx = 0;
let soundOn = false;
let audioCtx = null;
let highestVal = 1;

// â”€â”€ Canvas setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const wrap = document.getElementById('game-wrap');
const canvas = document.getElementById('gc');
const ctx = canvas.getContext('2d');

let W, H, laneW, cellSize, laneXs, topY, bottomY;

function resize() {
  const rect = wrap.getBoundingClientRect();
  W = rect.width;
  H = rect.height - HUD_TOP_H - HUD_BOTTOM_H;
  canvas.width  = W * DPR;
  canvas.height = H * DPR;
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

  laneW = W / LANES;
  cellSize = Math.floor(Math.min(laneW * 0.78, 64));
  laneXs = [laneW*0.5, laneW*1.5, laneW*2.5];
  topY = cellSize * TOP_LINE / MAX_STACK * H; // danger line y
  bottomY = H - cellSize * 0.6;
}

// â”€â”€ Difficulty â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnDelay(t) {
  return Math.max(0.12, Math.min(0.42, 0.42 - 0.0035 * t));
}
function vy0(t) {
  return Math.min(520, Math.max(220, 220 + 4.0 * t));
}
const AY = 1200;

// â”€â”€ RNG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function mulberry32(seed) {
  return function() {
    seed |= 0; seed = seed + 0x6D2B79F5 | 0;
    let z = Math.imul(seed ^ seed >>> 15, 1 | seed);
    z ^= z + Math.imul(z ^ z >>> 7, 61 | z);
    return ((z ^ z >>> 14) >>> 0) / 4294967296;
  };
}

function initSeed() {
  const params = new URLSearchParams(location.search);
  const s = params.get('seed');
  if (s && /^[0-9]+$/.test(s)) {
    seedMode = true;
    rng = mulberry32(parseInt(s));
    // Pre-generate 30 drops
    for (let i = 0; i < 30; i++) seedDrops.push(rng());
    dropIdx = 0;
  }
}

function rand() {
  if (seedMode && dropIdx < seedDrops.length) return seedDrops[dropIdx++];
  return Math.random();
}

// â”€â”€ Value distribution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function pickVal(t) {
  const r = rand();
  if (t < 15)  return r < 0.75 ? 1 : 2;
  if (t < 30)  return r < 0.55 ? 1 : r < 0.85 ? 2 : 4;
  if (t < 50)  return r < 0.40 ? 1 : r < 0.72 ? 2 : r < 0.90 ? 4 : 8;
  if (t < 80)  return r < 0.30 ? 1 : r < 0.58 ? 2 : r < 0.80 ? 4 : r < 0.93 ? 8 : 16;
  return r < 0.20 ? 1 : r < 0.45 ? 2 : r < 0.68 ? 4 : r < 0.84 ? 8 : r < 0.93 ? 16 : 32;
}

function valHue(v) {
  const map = {1:0,2:30,4:60,8:120,16:180,32:210,64:270,128:300,256:330,512:0,1024:180};
  return map[v] !== undefined ? map[v] : (Math.log2(v) * 40) % 360;
}

// â”€â”€ Spawn candy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnCandy() {
  if (fallingCandy) return;
  const val  = pickVal(t);
  const hard = t > 60 && rand() < 0.22;
  const hue  = valHue(val);
  fallingCandy = {
    lane: cursor,
    y: -cellSize,
    vy: vy0(t),
    val, hard, hue,
    trail: [],
    squash: 1.0, squashV: 0
  };
  spawnTimer = 0;
}

// â”€â”€ Stack helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function stackTopY(lane) {
  const stack = lanes[lane];
  if (!stack.length) return bottomY;
  return bottomY - stack.length * (cellSize + 4);
}

function isOverflow(lane) {
  return lanes[lane].length >= TOP_LINE;
}

// â”€â”€ Merge resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resolveStack(laneIdx, firstDrop) {
  const stack = lanes[laneIdx];
  let merged = false;
  let localCombo = 0;
  let hardOk = !firstDrop; // if not hard-first, always allowed to merge

  while (stack.length >= 2) {
    const top = stack[stack.length - 1];
    const below = stack[stack.length - 2];
    if (top.val !== below.val) break;

    // Hard candy check: hard candy won't merge unless at least 2 merges will happen
    if ((top.hard || below.hard) && !hardOk) {
      // Peek: would there be a chain? check if merged val matches stack[len-3]
      const newVal = top.val * 2;
      const wouldChain = stack.length >= 3 && stack[stack.length - 3].val === newVal;
      if (!wouldChain) break;
    }
    hardOk = true;

    const newVal = top.val * 2;
    const hue = valHue(newVal);
    stack.pop(); stack.pop();
    stack.push({val: newVal, hard: false, hue, sq: 1.3});
    merged = true;
    localCombo++;
    pendingMergeOnDrop = true;

    if (newVal > highestVal) highestVal = newVal;
    if (newVal > bestVal) {
      bestVal = newVal;
      try { localStorage.setItem(LS_BESTVAL, bestVal); } catch(e){}
    }

    // Scoring
    const cv = 1.0 + (comboChain + localCombo - 1) * 0.5;
    comboMult = Math.min(cv, 5.0);
    score += Math.round(newVal * comboMult * streakMult);

    // Particles
    const px = laneXs[laneIdx];
    const py = bottomY - (stack.length - 1) * (cellSize + 4);
    spawnMergeParticles(px, py, hue, newVal >= 16 ? 18 : 10);
    spawnImpactRing(px, py, hue);

    // Shake on big merges
    if (newVal >= 32) triggerShake(Math.min(newVal / 64, 1) * 6);

    playMerge(newVal);
  }

  if (localCombo > 0) {
    comboChain += localCombo;
    if (comboChain > bestCombo) bestCombo = comboChain;
  }
  return merged;
}

// â”€â”€ Landing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function landCandy(fc) {
  const stack = lanes[fc.lane];
  comboChain = 0;
  comboMult  = 1.0;
  pendingMergeOnDrop = false;

  stack.push({val: fc.val, hard: fc.hard, hue: fc.hue, sq: 1.3});
  const isHardFirst = fc.hard;
  resolveStack(fc.lane, isHardFirst);

  // Impact ring
  const px = laneXs[fc.lane];
  const py = stackTopY(fc.lane) + cellSize * 0.5;
  spawnImpactRing(px, py + cellSize * 0.5, fc.hue);
  playLand();

  // Streak update
  if (pendingMergeOnDrop) {
    streakMeter = Math.min(1, streakMeter + 0.25);
  } else {
    streakMeter = Math.max(0, streakMeter - 0.15);
  }
  streakMult = 1.0 + streakMeter * 1.5;

  // Check game over
  if (isOverflow(fc.lane)) {
    endGame();
  }
}

// â”€â”€ Particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnMergeParticles(x, y, hue, n) {
  for (let i = 0; i < n; i++) {
    const angle = (Math.PI * 2 * i) / n + rand() * 0.4;
    const spd = 60 + rand() * 140;
    particles.push({
      x, y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd - 40,
      life: 1.0,
      decay: 0.022 + rand() * 0.018,
      r: 3 + rand() * 4,
      hue: hue + rand() * 30 - 15,
      type: 'shard'
    });
  }
}

function spawnImpactRing(x, y, hue) {
  particles.push({x, y, r: cellSize * 0.4, maxR: cellSize * 1.4, life: 1.0, decay: 0.055, hue, type: 'ring'});
}

function spawnTrail(x, y, hue) {
  particles.push({
    x: x + (rand()-0.5)*cellSize*0.3,
    y,
    vx: (rand()-0.5)*20,
    vy: -20 - rand()*30,
    life: 0.7,
    decay: 0.04,
    r: 2 + rand()*3,
    hue,
    type: 'trail'
  });
}

// â”€â”€ Shake â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function triggerShake(amt) {
  shakeAmt = Math.max(shakeAmt, amt);
}

// â”€â”€ Audio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initAudio() {
  if (audioCtx) return;
  try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){}
}

function playBeep(freq, dur, type, vol) {
  if (!soundOn || !audioCtx) return;
  try {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.type = type || 'sine';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(vol || 0.15, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    osc.start(); osc.stop(audioCtx.currentTime + dur);
  } catch(e){}
}

function playLand()  { playBeep(220, 0.06, 'square', 0.08); }
function playMerge(v){ playBeep(200 + Math.log2(v)*80, 0.12, 'sine', 0.12); }
function playGO()    { playBeep(80, 0.5, 'sawtooth', 0.15); }

// â”€â”€ HUD helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const hudScore  = document.getElementById('hud-score');
const hudBest   = document.getElementById('hud-best');
const hudStreak = document.getElementById('hud-streak');
const streakBar = document.getElementById('streak-bar');

function updateHUD() {
  hudScore.textContent  = score;
  hudBest.textContent   = bestScore;
  hudStreak.textContent = 'x' + streakMult.toFixed(1);
  streakBar.style.width = (streakMeter * 100) + '%';
  streakBar.style.background = streakMeter > 0.6
    ? 'linear-gradient(90deg,#ffd700,#ff69b4)'
    : 'linear-gradient(90deg,#ff69b4,#ffd700)';
}

// â”€â”€ Load / save â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loadBests() {
  try {
    bestScore = parseInt(localStorage.getItem(LS_HS)) || 0;
    bestVal   = parseInt(localStorage.getItem(LS_BESTVAL)) || 1;
  } catch(e){}
}
function saveBests() {
  try {
    if (score > bestScore) { bestScore = score; localStorage.setItem(LS_HS, bestScore); }
    localStorage.setItem(LS_BESTVAL, bestVal);
  } catch(e){}
}

// â”€â”€ Game flow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startGame() {
  state = 'playing';
  score = 0; t = 0; cursor = 0;
  lanes = [[],[],[]];
  fallingCandy = null;
  particles = [];
  shakeAmt = 0;
  spawnTimer = 999; // spawn immediately
  streakMeter = 0; streakMult = 1.0;
  comboChain = 0; comboMult = 1.0;
  highestVal = 1;
  bestCombo = 0;
  dropIdx = 0;
  if (seedMode) dropIdx = 0;
}

function endGame() {
  state = 'gameover';
  saveBests();
  triggerShake(10);
  playGO();
}

// â”€â”€ Drawing helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+r);
  ctx.lineTo(x+w, y+h-r);
  ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
  ctx.lineTo(x+r, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-r);
  ctx.lineTo(x, y+r);
  ctx.quadraticCurveTo(x, y, x+r, y);
  ctx.closePath();
}

function drawCandy(x, y, val, hue, hard, sq, alpha) {
  const r = cellSize * 0.5 * (sq || 1);
  const scaleY = 1 / (sq || 1);
  ctx.save();
  ctx.globalAlpha = alpha !== undefined ? alpha : 1;
  ctx.translate(x, y);
  ctx.scale(1, scaleY);

  // Shadow glow
  ctx.shadowColor = `hsl(${hue},100%,60%)`;
  ctx.shadowBlur = hard ? 16 : 10;

  // Body
  const grad = ctx.createRadialGradient(-r*0.25, -r*0.25, r*0.05, 0, 0, r);
  grad.addColorStop(0, `hsl(${hue},100%,80%)`);
  grad.addColorStop(0.6, `hsl(${hue},90%,55%)`);
  grad.addColorStop(1, `hsl(${hue},80%,35%)`);
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI*2);
  ctx.fill();

  // Hard candy pattern
  if (hard) {
    ctx.strokeStyle = `rgba(255,255,255,0.6)`;
    ctx.lineWidth = 2.5;
    ctx.setLineDash([4, 3]);
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.72, 0, Math.PI*2);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Highlight
  ctx.shadowBlur = 0;
  const hl = ctx.createRadialGradient(-r*0.3, -r*0.35, 0, -r*0.2, -r*0.25, r*0.5);
  hl.addColorStop(0, 'rgba(255,255,255,0.55)');
  hl.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = hl;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI*2);
  ctx.fill();

  // Number
  ctx.shadowBlur = 0;
  const fontSize = val >= 1000 ? r * 0.55 : val >= 100 ? r * 0.65 : r * 0.75;
  ctx.font = `900 ${fontSize}px Arial Black, Arial, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillText(val, 1, 2);
  ctx.fillStyle = '#fff';
  ctx.fillText(val, 0, 0);

  ctx.restore();
}

// â”€â”€ Draw overlay screens â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawStart() {
  ctx.save();
  // Background gradient
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, 'rgba(45,0,80,0.97)');
  bg.addColorStop(1, 'rgba(13,0,26,0.97)');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  // Title
  const pulse = 1 + 0.04 * Math.sin(Date.now() * 0.003);
  ctx.save();
  ctx.translate(W/2, H * 0.22);
  ctx.scale(pulse, pulse);
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = `900 ${W*0.13}px Arial Black, Arial, sans-serif`;
  ctx.fillStyle = '#ff69b4';
  ctx.shadowColor = '#ff69b4';
  ctx.shadowBlur = 30;
  ctx.fillText('SUGAR', 0, 0);
  ctx.restore();

  ctx.save();
  ctx.translate(W/2, H * 0.34);
  ctx.scale(pulse, pulse);
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = `900 ${W*0.18}px Arial Black, Arial, sans-serif`;
  ctx.fillStyle = '#ffd700';
  ctx.shadowColor = '#ffd700';
  ctx.shadowBlur = 30;
  ctx.fillText('RUSH', 0, 0);
  ctx.restore();

  // Decorative candies
  const demoVals = [1,2,4,8];
  demoVals.forEach((v,i) => {
    const angle = Date.now() * 0.001 + i * Math.PI * 0.5;
    const r = W * 0.28;
    const x = W/2 + Math.cos(angle) * r * 0.9;
    const y = H * 0.52 + Math.sin(angle * 0.7) * 22;
    drawCandy(x, y, v, valHue(v), false, 1, 0.5 + 0.3*Math.sin(angle));
  });

  // Instructions
  ctx.font = `bold ${W*0.038}px Arial, sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(255,255,255,0.75)';
  ctx.shadowBlur = 0;
  ctx.fillText('Merge candies â€¢ Stack combos', W/2, H * 0.65);

  ctx.font = `${W*0.032}px Arial, sans-serif`;
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('Tap or press Space to switch lanes', W/2, H * 0.71);

  // Start button
  const bw = W * 0.58, bh = 52, bx = W/2 - bw/2, by = H * 0.79;
  const btnPulse = 1 + 0.06 * Math.sin(Date.now() * 0.004);
  ctx.save();
  ctx.translate(W/2, by + bh/2);
  ctx.scale(btnPulse, btnPulse);
  const bg2 = ctx.createLinearGradient(-bw/2, -bh/2, bw/2, bh/2);
  bg2.addColorStop(0, '#ff4d88');
  bg2.addColorStop(1, '#cc00cc');
  roundRect(ctx, -bw/2, -bh/2, bw, bh, 26);
  ctx.fillStyle = bg2;
  ctx.shadowColor = '#ff69b4';
  ctx.shadowBlur = 20;
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.font = `900 ${bh*0.42}px Arial Black, Arial, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#fff';
  ctx.fillText('TAP TO PLAY', 0, 0);
  ctx.restore();

  if (bestScore > 0) {
    ctx.font = `${W*0.03}px Arial, sans-serif`;
    ctx.fillStyle = '#ffd700';
    ctx.textAlign = 'center';
    ctx.fillText('Best: ' + bestScore, W/2, H * 0.93);
  }
  ctx.restore();
}

function drawGameOver() {
  ctx.save();
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, 'rgba(20,0,40,0.93)');
  bg.addColorStop(1, 'rgba(5,0,15,0.93)');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  ctx.font = `900 ${W*0.11}px Arial Black, Arial, sans-serif`;
  ctx.fillStyle = '#ff4444';
  ctx.shadowColor = '#ff0000';
  ctx.shadowBlur = 24;
  ctx.fillText('GAME OVER', W/2, H * 0.17);
  ctx.shadowBlur = 0;

  // Score
  ctx.font = `900 ${W*0.14}px Arial Black, Arial, sans-serif`;
  ctx.fillStyle = '#fff';
  ctx.fillText(score, W/2, H * 0.30);

  ctx.font = `${W*0.034}px Arial, sans-serif`;
  ctx.fillStyle = 'rgba(255,255,255,0.55)';
  ctx.fillText('SCORE', W/2, H * 0.38);

  // Stats
  const stats = [
    ['Best Score', bestScore],
    ['Highest Candy', highestVal],
    ['Best Combo', 'x' + bestCombo],
  ];
  stats.forEach((s, i) => {
    const sy = H * 0.47 + i * 44;
    roundRect(ctx, W*0.12, sy-18, W*0.76, 36, 8);
    ctx.fillStyle = 'rgba(255,255,255,0.07)';
    ctx.fill();
    ctx.font = `${W*0.032}px Arial, sans-serif`;
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.textAlign = 'left';
    ctx.fillText(s[0], W*0.18, sy + 0.5);
    ctx.textAlign = 'right';
    ctx.fillStyle = '#ffd700';
    ctx.font = `bold ${W*0.034}px Arial, sans-serif`;
    ctx.fillText(s[1], W*0.88, sy + 0.5);
  });

  // Retry button
  const bw = W*0.52, bh = 48, by = H * 0.71;
  roundRect(ctx, W/2-bw/2, by, bw, bh, 24);
  ctx.fillStyle = 'rgba(255,70,140,0.85)';
  ctx.shadowColor = '#ff69b4';
  ctx.shadowBlur = 14;
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = `900 ${bh*0.42}px Arial Black, Arial, sans-serif`;
  ctx.fillStyle = '#fff';
  ctx.fillText('PLAY AGAIN', W/2, by + bh/2);

  // Share button
  const sw = W*0.52, sh = 44, sy2 = H * 0.81;
  roundRect(ctx, W/2-sw/2, sy2, sw, sh, 22);
  ctx.fillStyle = 'rgba(255,215,0,0.15)';
  ctx.strokeStyle = '#ffd700';
  ctx.lineWidth = 2;
  ctx.fill();
  ctx.stroke();
  ctx.font = `bold ${sh*0.38}px Arial, sans-serif`;
  ctx.fillStyle = '#ffd700';
  ctx.fillText('SHARE SCORE', W/2, sy2 + sh/2);

  ctx.restore();
}

// â”€â”€ Share â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function shareScore() {
  const text = `ðŸ¬ Sugar Rush Score: ${score}! Highest candy: ${highestVal}, Best combo: x${bestCombo}. Can you beat me? ${SHARE_URL}`;
  if (navigator.share) {
    try { await navigator.share({title:'Sugar Rush', text, url: SHARE_URL}); return; } catch(e){}
  }
  try {
    await navigator.clipboard.writeText(text);
    alert('Score copied to clipboard!');
  } catch(e) {
    prompt('Copy your score:', text);
  }
}

// â”€â”€ Hit test for gameover buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function hitRetry(x, y) {
  const bw = W*0.52, bh = 48, by = H * 0.71;
  return x >= W/2-bw/2 && x <= W/2+bw/2 && y >= by && y <= by+bh;
}
function hitShare(x, y) {
  const sw = W*0.52, sh = 44, sy = H * 0.81;
  return x >= W/2-sw/2 && x <= W/2+sw/2 && y >= sy && y <= sy+sh;
}

// â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleAction(x, y) {
  initAudio();
  if (state === 'start') { startGame(); return; }
  if (state === 'gameover') {
    if (hitShare(x, y)) { shareScore(); return; }
    startGame();
    return;
  }
  if (state === 'playing') {
    cursor = (cursor + 1) % LANES;
    if (fallingCandy) fallingCandy.lane = cursor;
  }
}

canvas.addEventListener('pointerdown', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  handleAction(e.clientX - rect.left, e.clientY - rect.top);
});

document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'Enter') {
    e.preventDefault();
    handleAction(W/2, H/2);
  }
  if (e.code === 'ArrowLeft' && state === 'playing') {
    cursor = (cursor - 1 + LANES) % LANES;
    if (fallingCandy) fallingCandy.lane = cursor;
  }
  if (e.code === 'ArrowRight' && state === 'playing') {
    cursor = (cursor + 1) % LANES;
    if (fallingCandy) fallingCandy.lane = cursor;
  }
});

// Sound toggle
const btnSound = document.getElementById('btn-sound');
btnSound.addEventListener('click', e => {
  e.stopPropagation();
  initAudio();
  soundOn = !soundOn;
  btnSound.textContent = soundOn ? 'ðŸ”Š' : 'ðŸ”‡';
});

// â”€â”€ Main loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let last = 0;
let hue = 0;
let bgPulse = 0;

function loop(now) {
  requestAnimationFrame(loop);
  const dtRaw = (now - last) / 1000;
  last = now;
  const dt = Math.min(dtRaw, 0.033);

  // Shake
  if (shakeAmt > 0.1) {
    shakeAmt *= 0.82;
    shakeDX = (Math.random()-0.5)*shakeAmt;
    shakeDY = (Math.random()-0.5)*shakeAmt;
  } else { shakeAmt=0; shakeDX=0; shakeDY=0; }

  ctx.save();
  ctx.translate(shakeDX, shakeDY);

  // Background
  hue = (hue + dt * 8) % 360;
  bgPulse += dt;
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  const streakGlow = streakMeter > 0.5 ? streakMeter - 0.5 : 0;
  bg.addColorStop(0, `hsl(${hue},60%,${6+streakGlow*8}%)`);
  bg.addColorStop(1, `hsl(${(hue+30)%360},50%,${3+streakGlow*5}%)`);
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  if (state === 'start') {
    drawStart();
    ctx.restore();
    updateHUD();
    return;
  }

  if (state === 'gameover') {
    // Draw lanes dimmed
    drawLanes(0.3);
    drawParticles(dt);
    drawGameOver();
    ctx.restore();
    return;
  }

  // â”€â”€ Playing â”€â”€
  t += dt;

  // Spawn logic
  spawnTimer += dt;
  if (!fallingCandy && spawnTimer >= spawnDelay(t)) {
    spawnCandy();
  }

  // Update falling candy
  if (fallingCandy) {
    const fc = fallingCandy;
    fc.vy += AY * dt;
    fc.y  += fc.vy * dt;

    // Trail
    if (fc.vy > 150) spawnTrail(laneXs[fc.lane], fc.y + cellSize*0.5, fc.hue);

    // Squash spring
    if (fc.squash !== 1) {
      fc.squashV += (1 - fc.squash) * 400 * dt;
      fc.squashV *= 0.85;
      fc.squash += fc.squashV * dt;
      if (Math.abs(fc.squash - 1) < 0.01 && Math.abs(fc.squashV) < 0.5) fc.squash = 1;
    }

    // Landing check
    const landY = stackTopY(fc.lane) - cellSize * 0.5;
    if (fc.y >= landY) {
      fc.y = landY;
      fc.squash = 1.35;
      fc.squashV = -2;
      landCandy(fc);
      fallingCandy = null;
      spawnTimer = 0;
    }
  }

  // Update stacked candy squash
  lanes.forEach(stack => {
    stack.forEach(c => {
      if (c.sq && c.sq !== 1) {
        c.sq += (1 - c.sq) * 8 * dt;
        if (Math.abs(c.sq - 1) < 0.02) c.sq = 1;
      }
    });
  });

  // Update particles
  updateParticles(dt);

  // â”€â”€ Draw â”€â”€
  drawLanes(1);
  drawParticles(dt);

  // Cursor indicator
  drawCursor();

  // Falling candy
  if (fallingCandy) {
    const fc = fallingCandy;
    drawCandy(laneXs[fc.lane], fc.y, fc.val, fc.hue, fc.hard, fc.squash);
  }

  // Danger flash
  lanes.forEach((stack, i) => {
    const fill = stack.length / TOP_LINE;
    if (fill > 0.7) {
      const alpha = 0.3 + 0.4 * Math.abs(Math.sin(bgPulse * 6));
      ctx.strokeStyle = `rgba(255,50,50,${alpha * fill})`;
      ctx.lineWidth = 3;
      ctx.strokeRect(i*laneW + 2, 0, laneW - 4, H);
    }
  });

  ctx.restore();
  updateHUD();
}

function drawLanes(alpha) {
  ctx.save();
  ctx.globalAlpha = alpha;

  // Lane dividers
  for (let i = 1; i < LANES; i++) {
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(i * laneW, 0);
    ctx.lineTo(i * laneW, H);
    ctx.stroke();
  }

  // Top-out line
  ctx.strokeStyle = 'rgba(255,80,80,0.4)';
  ctx.lineWidth = 2;
  ctx.setLineDash([6,4]);
  const topLineY = H - (TOP_LINE * (cellSize + 4)) - cellSize * 0.5;
  ctx.beginPath();
  ctx.moveTo(0, topLineY);
  ctx.lineTo(W, topLineY);
  ctx.stroke();
  ctx.setLineDash([]);

  // Stacked candies
  lanes.forEach((stack, li) => {
    stack.forEach((c, ci) => {
      const x = laneXs[li];
      const y = bottomY - ci * (cellSize + 4);
      drawCandy(x, y, c.val, c.hue, c.hard, c.sq || 1);
    });
  });

  ctx.restore();
}

function drawCursor() {
  const x = laneXs[cursor];
  const y = 20;
  ctx.save();
  ctx.strokeStyle = `hsla(${hue},100%,75%,0.85)`;
  ctx.lineWidth = 3;
  ctx.shadowColor = `hsl(${hue},100%,70%)`;
  ctx.shadowBlur = 10;
  // Triangle pointer
  ctx.beginPath();
  ctx.moveTo(x, y + 14);
  ctx.lineTo(x - 9, y);
  ctx.lineTo(x + 9, y);
  ctx.closePath();
  ctx.fillStyle = `hsla(${hue},100%,75%,0.9)`;
  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function updateParticles(dt) {
  particles = particles.filter(p => {
    p.life -= p.decay;
    if (p.type === 'ring') {
      p.r += (p.maxR - p.r) * 0.2;
    } else {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 200 * dt;
    }
    return p.life > 0;
  });
}

function drawParticles() {
  particles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = Math.max(0, p.life);
    if (p.type === 'ring') {
      ctx.strokeStyle = `hsl(${p.hue},100%,70%)`;
      ctx.lineWidth = 2.5 * p.life;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.stroke();
    } else if (p.type === 'trail') {
      ctx.fillStyle = `hsl(${p.hue},80%,65%)`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r * p.life, 0, Math.PI*2);
      ctx.fill();
    } else {
      ctx.fillStyle = `hsl(${p.hue},100%,65%)`;
      ctx.shadowColor = `hsl(${p.hue},100%,70%)`;
      ctx.shadowBlur = 6;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.life * 8);
      const s = p.r * p.life;
      ctx.fillRect(-s/2, -s/2, s, s);
      ctx.restore();
    }
    ctx.restore();
  });
}

// â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
loadBests();
initSeed();
resize();
window.addEventListener('resize', resize);
last = performance.now();
requestAnimationFrame(loop);

})();
</script>

<section id="info-section" aria-label="Game Information" style="max-width:420px;margin:0 auto;padding:16px;color:rgba(255,255,255,0.6);font-size:13px;line-height:1.6">
  <h2 style="color:#ff69b4;font-size:16px;margin-bottom:8px">How to Play Sugar Rush</h2>
  <p>Tap the screen or press <strong>Space/Enter</strong> to cycle between the 3 lanes. Candies fall into the selected lane and stack from the bottom. When two candies with the same number land on each other, they merge into the next value â€” creating chain combos!</p>
  <h3 style="color:#ffd700;font-size:14px;margin:12px 0 6px">Tips</h3>
  <ul style="padding-left:16px">
    <li>Maintain your <strong>Sugar Streak</strong> for a score multiplier boost.</li>
    <li>Chain merges give exponentially higher combo multipliers.</li>
    <li>Watch for the red danger line â€” game over if a stack reaches the top!</li>
    <li>After 60 seconds, hard candies appear that need chain merges to break.</li>
    <li>Use arrow keys to quickly switch lanes on desktop.</li>
  </ul>
  <h3 style="color:#ffd700;font-size:14px;margin:12px 0 6px">About Sugar Rush</h3>
  <p>Sugar Rush is a free hyper-casual HTML5 browser game. No download, no install â€” play instantly on any device. Stack and merge number candies to reach the highest score possible!</p>
</section>
</body>
</html>
