<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Twix Twist - Free HTML5 Game</title>
  <meta name="description" content="Play Twix Twist - Bounce your orbiting chocolate circles, splitting them to collect candy pieces and dodge traps.">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#1a0a2e">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Twix Twist - Free HTML5 Game">
  <meta property="og:description" content="Play Twix Twist - Bounce your orbiting chocolate circles, splitting them to collect candy pieces and dodge traps.">
  <meta property="og:url" content="https://balinti.github.io/twix-twist/">
  <meta property="og:image" content="https://balinti.github.io/twix-twist/preview.png">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Twix Twist - Free HTML5 Game">
  <meta name="twitter:description" content="Play Twix Twist - Bounce your orbiting chocolate circles, splitting them to collect candy pieces and dodge traps.">
  <meta name="twitter:image" content="https://balinti.github.io/twix-twist/preview.png">

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%;
      background: #0d0618;
      display: flex; align-items: center; justify-content: center;
      overflow: hidden;
      font-family: 'Segoe UI', system-ui, sans-serif;
      touch-action: none;
    }
    #container {
      position: relative;
      width: 420px;
      max-width: 100vw;
      height: 750px;
      max-height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      image-rendering: crisp-edges;
    }
    #howto {
      position: absolute;
      bottom: -9999px;
      left: 0;
      width: 1px;
      height: 1px;
      overflow: hidden;
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
<div id="container">
  <canvas id="c"></canvas>
  <!-- SEO content block, visually hidden -->
  <div id="howto" aria-hidden="true">
    <h2>How to Play Twix Twist</h2>
    <p>Twix Twist is a free hyper-casual HTML5 game. Your ball auto-orbits the center of the screen on one of two rings – an inner ring and an outer ring. Tap or press Space/Enter to snap your ball between the two rings instantly.</p>
    <h3>Rules</h3>
    <ul>
      <li>Collect candy pieces (golden circles) that appear on the rings for points.</li>
      <li>Avoid red trap segments rotating around the rings.</li>
      <li>Miss 3 candies or hit a trap and it's game over.</li>
      <li>Consecutive candy combos multiply your score.</li>
      <li>Speed increases over time – how long can you last?</li>
    </ul>
    <h3>Controls</h3>
    <ul>
      <li>Tap / Click – snap between inner and outer ring</li>
      <li>Space or Enter – snap between rings</li>
    </ul>
  </div>
</div>

<script>
(function(){
'use strict';

// ─── Constants ────────────────────────────────────────────────────────────────
const W = 420, H = 750;
const CX = W / 2, CY = H / 2;
const INNER_R = 100, OUTER_R = 175;
const BALL_R = 14;
const CANDY_R = 10;
const TRAP_ARC = 0.55; // radians
const LS_KEY = 'twix_best';

// ─── State ────────────────────────────────────────────────────────────────────
let state = 'start'; // 'start' | 'playing' | 'gameover'
let score = 0, best = 0, combo = 0;
let missBuffer = 0;
const MAX_MISS = 3;

// ─── Ball ─────────────────────────────────────────────────────────────────────
let ball = { angle: -Math.PI / 2, ring: 'inner', r: 0 };

// ─── Timing / Difficulty ──────────────────────────────────────────────────────
let elapsed = 0;           // seconds since game start
let baseSpeed = 1.2;       // rad/s
let orbitSpeed = 0;        // current rotation speed
let spawnInterval = 2.2;   // seconds between spawns
let lastSpawn = 0;

// ─── Entities ─────────────────────────────────────────────────────────────────
let candies = [];   // { angle, ring, alive, hue }
let traps = [];     // { angle, ring, alive, arc }

// ─── Particles ────────────────────────────────────────────────────────────────
let particles = []; // { x, y, vx, vy, life, maxLife, r, hue, alpha }

// ─── Screen shake ─────────────────────────────────────────────────────────────
let shake = { mag: 0, decay: 0.88 };

// ─── Color cycling ────────────────────────────────────────────────────────────
let hueShift = 0;

// ─── Canvas setup ─────────────────────────────────────────────────────────────
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let dpr = 1, scaleX = 1, scaleY = 1;

function setupCanvas() {
  dpr = window.devicePixelRatio || 1;
  const container = canvas.parentElement;
  const cw = container.clientWidth;
  const ch = container.clientHeight;
  scaleX = cw / W;
  scaleY = ch / H;
  canvas.width = cw * dpr;
  canvas.height = ch * dpr;
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(dpr * scaleX, dpr * scaleY);
}

// ─── Utility ──────────────────────────────────────────────────────────────────
function wrapAngle(a) {
  while (a > Math.PI) a -= 2 * Math.PI;
  while (a < -Math.PI) a += 2 * Math.PI;
  return a;
}

function angleDiff(a, b) {
  return wrapAngle(b - a);
}

function ringRadius(ring) {
  return ring === 'inner' ? INNER_R : OUTER_R;
}

function getPos(angle, ring) {
  const r = ringRadius(ring);
  return { x: CX + Math.cos(angle) * r, y: CY + Math.sin(angle) * r };
}

function randHue() {
  return (Math.random() * 360) | 0;
}

function lerp(a, b, t) { return a + (b - a) * t; }

// ─── Particles ────────────────────────────────────────────────────────────────
function burst(x, y, count, hue, speedMul) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = (1.5 + Math.random() * 3) * (speedMul || 1);
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1, maxLife: 1,
      r: 2 + Math.random() * 4,
      hue: hue + (Math.random() * 40 - 20),
      alpha: 1
    });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.92;
    p.vy *= 0.92;
    p.life -= dt * 1.8;
    p.alpha = Math.max(0, p.life);
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.save();
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = `hsl(${p.hue},90%,65%)`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * p.life + 0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// ─── Difficulty ───────────────────────────────────────────────────────────────
function getDifficulty() {
  const t = elapsed;
  const speed = baseSpeed + Math.min(t * 0.06, 2.8);
  const interval = Math.max(0.9, spawnInterval - t * 0.025);
  const trapChance = Math.min(0.55, 0.1 + t * 0.008);
  const gateArcs = t > 15;
  return { speed, interval, trapChance, gateArcs };
}

// ─── Spawning ─────────────────────────────────────────────────────────────────
function spawnItem() {
  const d = getDifficulty();
  const ring = Math.random() < 0.5 ? 'inner' : 'outer';
  // spawn ahead of player in rotation direction
  const spawnOffset = Math.PI * (0.6 + Math.random() * 0.8);
  const spawnAngle = wrapAngle(ball.angle + spawnOffset);

  if (Math.random() < d.trapChance) {
    const arc = d.gateArcs ? (TRAP_ARC * (0.5 + Math.random() * 0.7)) : TRAP_ARC;
    traps.push({ angle: spawnAngle, ring, alive: true, arc });
  } else {
    candies.push({ angle: spawnAngle, ring, alive: true, hue: randHue() });
  }
}

// ─── Snap ─────────────────────────────────────────────────────────────────────
function snap() {
  if (state !== 'playing') return;
  ball.ring = ball.ring === 'inner' ? 'outer' : 'inner';
  // snap burst
  const pos = getPos(ball.angle, ball.ring);
  burst(pos.x, pos.y, 10, hueShift, 0.7);
}

// ─── Collision ────────────────────────────────────────────────────────────────
function checkCollisions() {
  const bPos = getPos(ball.angle, ball.ring);

  // Candy collection
  for (let i = candies.length - 1; i >= 0; i--) {
    const c = candies[i];
    if (!c.alive || c.ring !== ball.ring) continue;
    const diff = Math.abs(angleDiff(ball.angle, c.angle));
    if (diff < 0.22) {
      c.alive = false;
      combo++;
      const mult = Math.min(combo, 8);
      score += mult;
      const pos = getPos(c.angle, c.ring);
      burst(pos.x, pos.y, 16, c.hue, 1.2);
      // micro-shake on candy
      shake.mag = Math.max(shake.mag, 1.5);
    }
  }

  // Trap collision
  for (const t of traps) {
    if (!t.alive || t.ring !== ball.ring) continue;
    const diff = Math.abs(angleDiff(ball.angle, t.angle));
    if (diff < t.arc / 2 + 0.08) {
      triggerDeath();
      return;
    }
  }
}

// ─── Near-miss check ──────────────────────────────────────────────────────────
function checkNearMiss() {
  for (const t of traps) {
    if (!t.alive || t.ring !== ball.ring) continue;
    const diff = Math.abs(angleDiff(ball.angle, t.angle));
    const nearZone = t.arc / 2 + 0.25;
    if (diff < nearZone && diff > t.arc / 2 + 0.08) {
      shake.mag = Math.max(shake.mag, 2.5);
    }
  }
}

// ─── Miss detection ───────────────────────────────────────────────────────────
function checkMissed() {
  // candy passed behind player (rotated past by PI)
  for (let i = candies.length - 1; i >= 0; i--) {
    const c = candies[i];
    if (!c.alive) continue;
    const diff = angleDiff(ball.angle, c.angle);
    // diff goes from positive (ahead) to negative (behind)
    if (diff < -0.35) {
      c.alive = false;
      combo = 0;
      missBuffer++;
      shake.mag = Math.max(shake.mag, 3);
      if (missBuffer >= MAX_MISS) {
        triggerDeath();
        return;
      }
    }
  }
}

// ─── Death ────────────────────────────────────────────────────────────────────
function triggerDeath() {
  if (state !== 'playing') return;
  state = 'gameover';
  const bPos = getPos(ball.angle, ball.ring);
  burst(bPos.x, bPos.y, 50, 0, 1.5);
  burst(bPos.x, bPos.y, 30, 30, 1.2);
  shake.mag = 18;
  if (score > best) {
    best = score;
    try { localStorage.setItem(LS_KEY, best); } catch(e) {}
  }
}

// ─── Start game ───────────────────────────────────────────────────────────────
function startGame() {
  state = 'playing';
  score = 0;
  combo = 0;
  missBuffer = 0;
  elapsed = 0;
  lastSpawn = 0;
  ball = { angle: -Math.PI / 2, ring: 'inner' };
  candies = [];
  traps = [];
  particles = [];
  shake = { mag: 0, decay: 0.88 };
  spawnInterval = 2.2;
}

// ─── Input ────────────────────────────────────────────────────────────────────
function handleInput() {
  if (state === 'start') {
    startGame();
  } else if (state === 'playing') {
    snap();
  } else if (state === 'gameover') {
    startGame();
  }
}

canvas.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  handleInput();
});

window.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter') {
    e.preventDefault();
    handleInput();
  }
});

// ─── Draw helpers ─────────────────────────────────────────────────────────────
function drawRing(r, alpha, hue) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = `hsl(${hue},60%,45%)`;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(CX, CY, r, 0, Math.PI * 2);
  ctx.stroke();
  ctx.restore();
}

function drawBall(x, y, hue) {
  ctx.save();
  // glow
  const g = ctx.createRadialGradient(x, y, 0, x, y, BALL_R * 2.5);
  g.addColorStop(0, `hsla(${hue},100%,80%,0.5)`);
  g.addColorStop(1, `hsla(${hue},100%,50%,0)`);
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(x, y, BALL_R * 2.5, 0, Math.PI * 2);
  ctx.fill();

  // main ball
  ctx.fillStyle = `hsl(${hue},90%,65%)`;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(x, y, BALL_R, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function drawCandy(c) {
  if (!c.alive) return;
  const pos = getPos(c.angle, c.ring);
  ctx.save();
  // glow
  const g = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, CANDY_R * 2);
  g.addColorStop(0, `hsla(${c.hue},100%,80%,0.6)`);
  g.addColorStop(1, `hsla(${c.hue},100%,50%,0)`);
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, CANDY_R * 2, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = `hsl(${c.hue},90%,65%)`;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, CANDY_R, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function drawTrap(t) {
  if (!t.alive) return;
  const r = ringRadius(t.ring);
  const a0 = t.angle - t.arc / 2;
  const a1 = t.angle + t.arc / 2;
  ctx.save();

  // red arc fill glow
  ctx.strokeStyle = 'rgba(255,50,50,0.25)';
  ctx.lineWidth = 26;
  ctx.beginPath();
  ctx.arc(CX, CY, r, a0, a1);
  ctx.stroke();

  // main red arc
  ctx.strokeStyle = '#ff3030';
  ctx.lineWidth = 13;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.arc(CX, CY, r, a0, a1);
  ctx.stroke();

  // white outline
  ctx.strokeStyle = 'rgba(255,255,255,0.7)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(CX, CY, r, a0, a1);
  ctx.stroke();

  ctx.restore();
}

function drawBackground(hue) {
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, `hsl(${hue + 200},60%,6%)`);
  bg.addColorStop(1, `hsl(${hue + 260},60%,3%)`);
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);
}

function drawCenterDot(hue) {
  ctx.save();
  ctx.fillStyle = `hsl(${hue},70%,50%)`;
  ctx.globalAlpha = 0.4;
  ctx.beginPath();
  ctx.arc(CX, CY, 6, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawMissIndicator() {
  // 3 hearts / dots at top
  const filled = MAX_MISS - missBuffer;
  for (let i = 0; i < MAX_MISS; i++) {
    ctx.save();
    ctx.fillStyle = i < filled ? '#ff6060' : 'rgba(255,96,96,0.2)';
    ctx.strokeStyle = '#ff6060';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(CX - (MAX_MISS - 1) * 14 + i * 28, 40, 8, 0, Math.PI * 2);
    if (i < filled) ctx.fill();
    ctx.stroke();
    ctx.restore();
  }
}

function drawScore(hue) {
  ctx.save();
  ctx.textAlign = 'center';
  ctx.fillStyle = `hsl(${hue},80%,80%)`;
  ctx.font = 'bold 52px system-ui, sans-serif';
  ctx.fillText(score, CX, 110);

  if (combo >= 2) {
    ctx.font = 'bold 18px system-ui, sans-serif';
    ctx.fillStyle = `hsl(${(hue + 60) % 360},90%,70%)`;
    ctx.fillText(`x${Math.min(combo, 8)} combo`, CX, 132);
  }
  ctx.restore();
}

function drawStartScreen(hue) {
  drawBackground(hue);

  // Rings (decorative)
  drawRing(INNER_R, 0.4, hue);
  drawRing(OUTER_R, 0.4, hue + 30);

  ctx.save();
  ctx.textAlign = 'center';

  // Title
  ctx.font = 'bold 54px system-ui, sans-serif';
  const grad = ctx.createLinearGradient(CX - 120, CY - 120, CX + 120, CY - 80);
  grad.addColorStop(0, `hsl(${hue},90%,70%)`);
  grad.addColorStop(0.5, `hsl(${hue + 60},90%,80%)`);
  grad.addColorStop(1, `hsl(${hue + 120},90%,70%)`);
  ctx.fillStyle = grad;
  ctx.fillText('TWIX', CX, CY - 100);

  ctx.font = 'bold 42px system-ui, sans-serif';
  ctx.fillStyle = `hsl(${hue + 60},80%,65%)`;
  ctx.fillText('TWIST', CX, CY - 58);

  // Subtitle
  ctx.font = '18px system-ui, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.65)';
  ctx.fillText('Snap between rings', CX, CY - 10);
  ctx.fillText('Collect candies · Dodge traps', CX, CY + 14);

  // Best
  if (best > 0) {
    ctx.font = 'bold 16px system-ui, sans-serif';
    ctx.fillStyle = `hsl(${hue + 40},80%,70%)`;
    ctx.fillText(`Best: ${best}`, CX, CY + 50);
  }

  // Tap to start
  const pulse = 0.65 + 0.35 * Math.sin(Date.now() * 0.003);
  ctx.globalAlpha = pulse;
  ctx.font = 'bold 22px system-ui, sans-serif';
  ctx.fillStyle = '#fff';
  ctx.fillText('Tap to Start', CX, CY + 120);
  ctx.restore();

  drawParticles();
}

function drawGameOver(hue) {
  drawBackground(hue);
  drawParticles();

  ctx.save();
  ctx.globalAlpha = 0.55;
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.roundRect(CX - 155, CY - 180, 310, 340, 20);
  ctx.fill();
  ctx.restore();

  ctx.save();
  ctx.textAlign = 'center';

  ctx.font = 'bold 36px system-ui, sans-serif';
  ctx.fillStyle = '#ff5555';
  ctx.fillText('GAME OVER', CX, CY - 120);

  ctx.font = 'bold 72px system-ui, sans-serif';
  const grad = ctx.createLinearGradient(CX - 80, CY - 80, CX + 80, CY - 40);
  grad.addColorStop(0, `hsl(${hue},90%,75%)`);
  grad.addColorStop(1, `hsl(${hue + 80},90%,75%)`);
  ctx.fillStyle = grad;
  ctx.fillText(score, CX, CY - 30);

  ctx.font = '20px system-ui, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fillText('Score', CX, CY - 5);

  ctx.font = 'bold 24px system-ui, sans-serif';
  ctx.fillStyle = `hsl(${hue + 60},80%,70%)`;
  ctx.fillText(`Best: ${best}`, CX, CY + 50);

  const pulse = 0.65 + 0.35 * Math.sin(Date.now() * 0.003);
  ctx.globalAlpha = pulse;
  ctx.font = 'bold 22px system-ui, sans-serif';
  ctx.fillStyle = '#fff';
  ctx.fillText('Tap to Retry', CX, CY + 120);
  ctx.restore();
}

function drawPlayingScreen(hue) {
  drawBackground(hue);

  // Rings
  drawRing(INNER_R, 0.55, hue);
  drawRing(OUTER_R, 0.55, hue + 30);

  drawCenterDot(hue);

  // Traps
  for (const t of traps) drawTrap(t);

  // Candies
  for (const c of candies) drawCandy(c);

  // Ball
  const bPos = getPos(ball.angle, ball.ring);
  drawBall(bPos.x, bPos.y, hue);

  // UI
  drawMissIndicator();
  drawScore(hue);
  drawParticles();
}

// ─── Game loop ────────────────────────────────────────────────────────────────
let lastTime = 0;

function loop(ts) {
  requestAnimationFrame(loop);
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;

  // color cycle
  hueShift = (hueShift + dt * 25) % 360;

  // shake
  shake.mag *= shake.decay;
  const sx = shake.mag > 0.5 ? (Math.random() - 0.5) * shake.mag : 0;
  const sy = shake.mag > 0.5 ? (Math.random() - 0.5) * shake.mag : 0;

  ctx.save();
  ctx.translate(sx, sy);

  if (state === 'start') {
    updateParticles(dt);
    drawStartScreen(hueShift);
  } else if (state === 'playing') {
    elapsed += dt;
    const d = getDifficulty();
    orbitSpeed = d.speed;

    // Move ball
    ball.angle = wrapAngle(ball.angle + orbitSpeed * dt);

    // Spawn items
    if (elapsed - lastSpawn >= d.interval) {
      spawnItem();
      lastSpawn = elapsed;
    }

    // Move entities (they are stationary in angle; ball moves to them)
    // Check collisions
    checkCollisions();
    if (state === 'playing') {
      checkMissed();
      checkNearMiss();
    }

    // Prune dead entities
    candies = candies.filter(c => c.alive || ((() => { return false; })()));
    traps = traps.filter(t => {
      if (!t.alive) return false;
      // remove traps that went far behind ball
      const diff = angleDiff(ball.angle, t.angle);
      return diff > -Math.PI * 1.2;
    });

    updateParticles(dt);
    drawPlayingScreen(hueShift);
  } else if (state === 'gameover') {
    updateParticles(dt);
    drawGameOver(hueShift);
  }

  ctx.restore();
}

// ─── Init ─────────────────────────────────────────────────────────────────────
function init() {
  try { best = parseInt(localStorage.getItem(LS_KEY)) || 0; } catch(e) {}
  setupCanvas();
  window.addEventListener('resize', setupCanvas);
  requestAnimationFrame((ts) => { lastTime = ts; loop(ts); });
}

init();
})();
</script>
</body>
</html>
