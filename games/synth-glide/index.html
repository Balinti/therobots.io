<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Synth Glide - Free HTML5 Game</title>
  <meta name="description" content="Play Synth Glide - Tap to navigate a neon synthbird between floating pastel pillars while velocity ramps up.">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#0a0a1a">

  <!-- Open Graph -->
  <meta property="og:title" content="Synth Glide - Free HTML5 Game">
  <meta property="og:description" content="Tap to navigate a neon synthbird through rhythm gates. How far can you glide?">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://balinti.github.io/synth-glide/">
  <meta property="og:image" content="https://balinti.github.io/synth-glide/og-image.png">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Synth Glide - Free HTML5 Game">
  <meta name="twitter:description" content="Tap to navigate a neon synthbird through rhythm gates. How far can you glide?">
  <meta name="twitter:image" content="https://balinti.github.io/synth-glide/og-image.png">

  <!-- Canonical -->
  <link rel="canonical" href="https://balinti.github.io/synth-glide/">

  <!-- AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Courier New', monospace;
      overflow: hidden;
      touch-action: none;
    }

    #game-wrap {
      position: relative;
      width: 420px;
      max-width: 100vw;
      height: 750px;
      max-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Ad-safe padding areas */
    #ad-top {
      height: 0px;
      width: 100%;
      flex-shrink: 0;
    }
    #ad-bottom {
      height: 0px;
      width: 100%;
      flex-shrink: 0;
    }

    #canvas-container {
      position: relative;
      flex: 1;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    #share-btn {
      position: absolute;
      bottom: 20px;
      right: 16px;
      background: rgba(255,255,255,0.15);
      border: 1px solid rgba(255,255,255,0.3);
      color: #fff;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      padding: 6px 12px;
      border-radius: 20px;
      cursor: pointer;
      display: none;
      z-index: 10;
      backdrop-filter: blur(4px);
    }
    #share-btn:active { background: rgba(255,255,255,0.25); }

    @media (max-height: 700px) {
      #game-wrap { height: 100vh; }
    }
  </style>
</head>
<body>
  <div id="game-wrap">
    <div id="ad-top"></div>
    <div id="canvas-container">
      <canvas id="c"></canvas>
      <button id="share-btn">&#8679; Share</button>
    </div>
    <div id="ad-bottom"></div>
  </div>

<script>
(function() {
'use strict';

// ─── Canvas Setup ────────────────────────────────────────────────────────────
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvas-container');
const shareBtn = document.getElementById('share-btn');

const LOGICAL_W = 420;
const LOGICAL_H = 750;
let dpr = Math.min(window.devicePixelRatio || 1, 2);
let W = LOGICAL_W, H = LOGICAL_H;

function resizeCanvas() {
  const rect = container.getBoundingClientRect();
  W = rect.width || LOGICAL_W;
  H = rect.height || LOGICAL_H;
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// ─── Constants ───────────────────────────────────────────────────────────────
const LS_KEY = 'synthglide_highscore';
const BIRD_R = 12;
const GATE_W = 60;
const GAP_H_BASE = 160;
const GRAVITY = 900;
const LIFT_ACCEL = -600;
const BASE_SPEED = 200;
const SPEED_INC = 18;
const GATES_PER_LEVEL = 8;
const SHAKE_DECAY = 8;
const TRAIL_LEN = 16;
const NOTE_R = 10;

// ─── State ───────────────────────────────────────────────────────────────────
let state = 'start'; // 'start' | 'playing' | 'gameover'
let highScore = parseInt(localStorage.getItem(LS_KEY) || '0', 10);

// Bird
let bird = {};
// Gates
let gates = [];
// Notes
let notes = [];
// Particles
let particles = [];
// Trail
let trail = [];

// Game vars
let score, combo, gatesCleared, level, speed, hue;
let shake = { x: 0, y: 0, mag: 0 };
let sectionHue = 0;
let comboFlash = 0;
let lastTime = 0;
let animId = null;
let bgHue = 0;

// ─── Helpers ─────────────────────────────────────────────────────────────────
function lerp(a, b, t) { return a + (b - a) * t; }
function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }
function randRange(a, b) { return a + Math.random() * (b - a); }

function saveHigh() {
  if (score > highScore) {
    highScore = score;
    localStorage.setItem(LS_KEY, highScore);
  }
}

// ─── Particles ───────────────────────────────────────────────────────────────
function spawnParticles(x, y, count, h, s, l, speed, spread) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd = randRange(speed * 0.4, speed);
    particles.push({
      x, y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd - spread,
      life: 1,
      decay: randRange(1.5, 3),
      r: randRange(2, 5),
      h, s, l
    });
  }
}

function spawnBurstParticles(x, y, isPerfect) {
  const h = sectionHue;
  const count = isPerfect ? 24 : 14;
  const spd = isPerfect ? 220 : 140;
  spawnParticles(x, y, count, h, 90, 65, spd, 60);
}

function spawnDeathParticles(x, y) {
  spawnParticles(x, y, 32, 0, 90, 60, 280, 100);
  spawnParticles(x, y, 16, 30, 80, 70, 180, 60);
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 200 * dt;
    p.life -= p.decay * dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.save();
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.fillStyle = `hsl(${p.h},${p.s}%,${p.l}%)`;
    ctx.shadowColor = `hsl(${p.h},${p.s}%,${p.l}%)`;
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * p.life, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// ─── Screen Shake ─────────────────────────────────────────────────────────────
function triggerShake(mag) {
  shake.mag = Math.max(shake.mag, mag);
}

function updateShake(dt) {
  shake.mag = Math.max(0, shake.mag - SHAKE_DECAY * dt * shake.mag);
  shake.x = (Math.random() - 0.5) * shake.mag * 2;
  shake.y = (Math.random() - 0.5) * shake.mag * 2;
}

// ─── Gate Logic ──────────────────────────────────────────────────────────────
function gapH() {
  const lvl = Math.min(level, 8);
  return Math.max(100, GAP_H_BASE - lvl * 6);
}

function pulseWindow() {
  // fraction of gate transit time that counts as "on pulse"
  return Math.max(0.25, 0.65 - level * 0.03);
}

function makeGate(x) {
  const gap = gapH();
  const minY = 80;
  const maxY = H - 80 - gap;
  const variance = 30 + level * 10;
  const centerY = clamp(randRange(H / 2 - variance, H / 2 + variance), minY, maxY);
  const pw = pulseWindow();
  const pOffset = randRange(0.15, 0.85 - pw);
  return {
    x,
    gapTop: centerY,
    gapBot: centerY + gap,
    w: GATE_W,
    passed: false,
    scored: false,
    // pulse timing as fraction of gate traversal
    pulseStart: pOffset,
    pulseEnd: pOffset + pw,
    pulsePhase: 0,     // animated 0..1 oscillation
    glow: 0,           // flash on pass
    h: sectionHue
  };
}

function makeNote(x, y) {
  return { x, y, r: NOTE_R, collected: false, glow: 0, h: (sectionHue + 60) % 360 };
}

function gateSpacing() {
  return clamp(240 + level * 15, 240, 380);
}

function spawnInitialGates() {
  gates = [];
  notes = [];
  let x = W * 0.75;
  for (let i = 0; i < 5; i++) {
    gates.push(makeGate(x));
    x += gateSpacing();
  }
}

function spawnNotesForLevel() {
  // after level 1 (gate 8+), notes appear
  if (level < 1) return;
  // sparse notes between gates
  notes = notes.filter(n => !n.collected && n.x > -20);
  // spawn a note if few present
  const lastGate = gates[gates.length - 1];
  if (lastGate && notes.length < 2 && Math.random() < 0.5) {
    const nx = lastGate.x + randRange(60, gateSpacing() - 60);
    const ny = randRange(100, H - 100);
    notes.push(makeNote(nx, ny));
  }
}

// ─── Bird ─────────────────────────────────────────────────────────────────────
function resetBird() {
  bird = {
    x: W * 0.25,
    y: H / 2,
    vy: 0,
    gliding: false,
    r: BIRD_R,
    angle: 0,
    dead: false
  };
  trail = [];
}

function updateBird(dt) {
  if (bird.dead) return;

  // Physics
  if (bird.gliding) {
    bird.vy += LIFT_ACCEL * dt;
    // Spring toward mid lane
    const laneY = H * 0.45;
    bird.vy += (laneY - bird.y) * 1.2 * dt;
  } else {
    bird.vy += GRAVITY * dt;
  }
  bird.vy = clamp(bird.vy, -420, 600);
  bird.y += bird.vy * dt;

  // Visual angle
  const targetAngle = clamp(bird.vy * 0.0012, -0.6, 0.8);
  bird.angle = lerp(bird.angle, targetAngle, 10 * dt);

  // Trail
  trail.unshift({ x: bird.x, y: bird.y });
  if (trail.length > TRAIL_LEN) trail.pop();

  // Bounds (ceiling/floor = death)
  if (bird.y - bird.r < 0 || bird.y + bird.r > H) {
    die();
  }
}

// ─── Collision ────────────────────────────────────────────────────────────────
function circleRect(cx, cy, cr, rx, ry, rw, rh) {
  const nearX = clamp(cx, rx, rx + rw);
  const nearY = clamp(cy, ry, ry + rh);
  const dx = cx - nearX, dy = cy - nearY;
  return dx * dx + dy * dy < cr * cr;
}

function circleCircle(ax, ay, ar, bx, by, br) {
  const dx = ax - bx, dy = ay - by;
  const rr = ar + br;
  return dx * dx + dy * dy < rr * rr;
}

// ─── Scoring ──────────────────────────────────────────────────────────────────
function checkGates() {
  for (const g of gates) {
    if (g.passed || g.scored) continue;

    // Check collision with gate blocks
    const topBlock = { x: g.x, y: 0, w: g.w, h: g.gapTop };
    const botBlock = { x: g.x, y: g.gapBot, w: g.w, h: H - g.gapBot };

    if (
      circleRect(bird.x, bird.y, bird.r, topBlock.x, topBlock.y, topBlock.w, topBlock.h) ||
      circleRect(bird.x, bird.y, bird.r, botBlock.x, botBlock.y, botBlock.w, botBlock.h)
    ) {
      die();
      return;
    }

    // Bird passed through gate center
    if (bird.x > g.x + g.w / 2 && !g.passed) {
      g.passed = true;
      g.scored = true;

      // Determine pulse fraction: where in gate transit is bird's center?
      // Use bird.x relative to gate x range
      const frac = (bird.x - g.x) / g.w;
      const onPulse = frac >= g.pulseStart && frac <= g.pulseEnd;

      let pts = 10;
      if (onPulse) {
        pts = 20;
        combo++;
        comboFlash = 1;
        g.glow = 1;
        spawnBurstParticles(g.x + g.w / 2, bird.y, true);
        triggerShake(4);
      } else {
        // off-pulse: allow, slight combo drain
        combo = Math.max(0, combo - 1);
        spawnBurstParticles(g.x + g.w / 2, bird.y, false);
        triggerShake(1.5);
      }

      pts += Math.floor(combo * 2);
      score += pts;
      gatesCleared++;

      // Level up every GATES_PER_LEVEL
      const newLevel = Math.floor(gatesCleared / GATES_PER_LEVEL);
      if (newLevel > level) {
        level = newLevel;
        speed = BASE_SPEED + level * SPEED_INC;
        sectionHue = (sectionHue + 40) % 360;
      }
    }
  }
}

function checkNotes() {
  for (const n of notes) {
    if (n.collected) continue;
    if (circleCircle(bird.x, bird.y, bird.r, n.x, n.y, n.r)) {
      n.collected = true;
      n.glow = 1;
      const bonus = 5 + combo * 2;
      score += bonus;
      combo++;
      comboFlash = 1;
      spawnParticles(n.x, n.y, 10, n.h, 90, 70, 150, 40);
      triggerShake(2);
    }
  }
}

// ─── Death ────────────────────────────────────────────────────────────────────
function die() {
  if (bird.dead) return;
  bird.dead = true;
  spawnDeathParticles(bird.x, bird.y);
  triggerShake(18);
  saveHigh();
  setTimeout(() => {
    state = 'gameover';
    shareBtn.style.display = 'block';
  }, 800);
}

// ─── Init / Reset ─────────────────────────────────────────────────────────────
function startGame() {
  score = 0;
  combo = 0;
  gatesCleared = 0;
  level = 0;
  speed = BASE_SPEED;
  sectionHue = 200;
  comboFlash = 0;
  particles = [];
  shake.mag = 0;
  bgHue = 220;
  shareBtn.style.display = 'none';
  resetBird();
  spawnInitialGates();
  state = 'playing';
}

// ─── Input ───────────────────────────────────────────────────────────────────
function handleInput() {
  if (state === 'start') {
    startGame();
  } else if (state === 'playing') {
    bird.gliding = !bird.gliding;
  } else if (state === 'gameover') {
    startGame();
  }
}

canvas.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  handleInput();
}, { passive: false });

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter') {
    e.preventDefault();
    handleInput();
  }
});

document.addEventListener('pointerup', () => {
  // glide toggles on down only
});

// ─── Double-gate logic ────────────────────────────────────────────────────────
function tryDoubleGate(x) {
  if (level >= 2 && Math.random() < 0.18) {
    // Two gates side by side with small offset
    const g1 = makeGate(x);
    const g2 = makeGate(x + GATE_W + 30);
    return [g1, g2];
  }
  return [makeGate(x)];
}

// ─── Update ───────────────────────────────────────────────────────────────────
function update(dt) {
  if (state !== 'playing') return;

  bgHue = lerp(bgHue, sectionHue, dt * 0.5);
  comboFlash = Math.max(0, comboFlash - dt * 3);

  updateBird(dt);
  updateParticles(dt);
  updateShake(dt);

  // Move gates & notes
  const dx = speed * dt;
  for (const g of gates) {
    g.x -= dx;
    g.pulsePhase = (g.pulsePhase + dt * 3) % 1;
    g.glow = Math.max(0, g.glow - dt * 2);
  }
  for (const n of notes) {
    n.x -= dx;
    n.glow = Math.max(0, n.glow - dt * 3);
  }

  // Remove offscreen
  while (gates.length && gates[0].x + gates[0].w < -10) gates.shift();
  notes = notes.filter(n => n.x > -30 && !n.collected);

  // Spawn new gates
  const lastGate = gates[gates.length - 1];
  if (!lastGate || lastGate.x < W + 20) {
    const spawnX = lastGate ? lastGate.x + gateSpacing() : W + 60;
    const newGates = tryDoubleGate(spawnX);
    gates.push(...newGates);
    spawnNotesForLevel();
  }

  if (!bird.dead) {
    checkGates();
    checkNotes();
  }
}

// ─── Drawing ──────────────────────────────────────────────────────────────────
function drawBackground() {
  // Animated gradient background
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, `hsl(${bgHue},60%,6%)`);
  grad.addColorStop(0.5, `hsl(${(bgHue + 20) % 360},50%,9%)`);
  grad.addColorStop(1, `hsl(${(bgHue + 40) % 360},55%,5%)`);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Scanlines
  ctx.save();
  ctx.globalAlpha = 0.04;
  for (let y = 0; y < H; y += 4) {
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, y, W, 1);
  }
  ctx.restore();

  // Grid lines
  ctx.save();
  ctx.globalAlpha = 0.07;
  ctx.strokeStyle = `hsl(${bgHue},60%,50%)`;
  ctx.lineWidth = 0.5;
  const gridSpacing = 60;
  for (let x = 0; x < W; x += gridSpacing) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, H);
    ctx.stroke();
  }
  for (let y = 0; y < H; y += gridSpacing) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(W, y);
    ctx.stroke();
  }
  ctx.restore();
}

function drawTrail() {
  if (trail.length < 2) return;
  for (let i = 0; i < trail.length - 1; i++) {
    const t = i / trail.length;
    const alpha = (1 - t) * 0.55;
    const r = bird.r * (1 - t * 0.7);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = bird.gliding
      ? `hsl(${sectionHue},100%,70%)`
      : `hsl(${(sectionHue + 180) % 360},80%,65%)`;
    ctx.shadowColor = ctx.fillStyle;
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(trail[i].x, trail[i].y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

function drawBird() {
  if (bird.dead) return;
  ctx.save();
  ctx.translate(bird.x, bird.y);
  ctx.rotate(bird.angle);

  const h = bird.gliding ? sectionHue : (sectionHue + 180) % 360;
  const bodyColor = `hsl(${h},100%,70%)`;
  const glowColor = `hsl(${h},100%,80%)`;

  // Glow
  ctx.shadowColor = glowColor;
  ctx.shadowBlur = bird.gliding ? 22 : 14;

  // Body
  ctx.fillStyle = bodyColor;
  ctx.beginPath();
  ctx.ellipse(0, 0, bird.r * 1.3, bird.r * 0.85, 0, 0, Math.PI * 2);
  ctx.fill();

  // Core
  ctx.fillStyle = '#fff';
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 0.7;
  ctx.beginPath();
  ctx.ellipse(bird.r * 0.1, 0, bird.r * 0.55, bird.r * 0.38, 0, 0, Math.PI * 2);
  ctx.fill();

  // Wing
  ctx.globalAlpha = 1;
  ctx.fillStyle = glowColor;
  ctx.shadowColor = glowColor;
  ctx.shadowBlur = 8;
  if (bird.gliding) {
    ctx.beginPath();
    ctx.moveTo(-bird.r * 0.3, 0);
    ctx.lineTo(-bird.r * 1.4, -bird.r * 1.1);
    ctx.lineTo(-bird.r * 1.6, bird.r * 0.2);
    ctx.closePath();
    ctx.fill();
  } else {
    ctx.beginPath();
    ctx.moveTo(-bird.r * 0.2, 0);
    ctx.lineTo(-bird.r * 0.9, bird.r * 0.7);
    ctx.lineTo(-bird.r * 1.1, bird.r * 0.2);
    ctx.closePath();
    ctx.fill();
  }

  // Eye
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#0a0a1a';
  ctx.beginPath();
  ctx.arc(bird.r * 0.55, -bird.r * 0.15, bird.r * 0.22, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(bird.r * 0.6, -bird.r * 0.18, bird.r * 0.09, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawGate(g) {
  const pulse = 0.5 + 0.5 * Math.sin(g.pulsePhase * Math.PI * 2);
  const glowAlpha = 0.5 + 0.5 * pulse;
  const h = g.h;

  // Top block
  const topH = g.gapTop;
  const botH = H - g.gapBot;

  // Gate blocks
  for (let side = 0; side < 2; side++) {
    const bx = g.x;
    const by = side === 0 ? 0 : g.gapBot;
    const bh = side === 0 ? topH : botH;

    if (bh <= 0) continue;

    // Block fill
    const grad = ctx.createLinearGradient(bx, by, bx + g.w, by + bh);
    grad.addColorStop(0, `hsla(${h},70%,25%,0.95)`);
    grad.addColorStop(1, `hsla(${h},70%,15%,0.95)`);
    ctx.fillStyle = grad;
    ctx.fillRect(bx, by, g.w, bh);

    // Border glow
    ctx.strokeStyle = `hsl(${h},90%,60%)`;
    ctx.lineWidth = 2;
    ctx.shadowColor = `hsl(${h},100%,70%)`;
    ctx.shadowBlur = 10 + 8 * pulse;
    ctx.strokeRect(bx + 1, by + 1, g.w - 2, bh - 2);
    ctx.shadowBlur = 0;

    // Inner stripe
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = `hsl(${h},80%,70%)`;
    ctx.fillRect(bx + g.w - 8, by, 4, bh);
    ctx.fillRect(bx + 4, by, 4, bh);
    ctx.restore();
  }

  // Pulse window highlight on gate edge
  const edgeY1 = g.gapTop * g.pulseStart;
  const edgeH = g.gapTop * (g.pulseEnd - g.pulseStart);
  ctx.save();
  ctx.globalAlpha = 0.22 * glowAlpha;
  ctx.fillStyle = `hsl(${h},100%,80%)`;
  ctx.fillRect(g.x, 0, g.w, g.gapTop);
  ctx.globalAlpha = 0.22 * glowAlpha;
  ctx.fillRect(g.x, g.gapBot, g.w, H - g.gapBot);
  ctx.restore();

  // Gap portal glow
  ctx.save();
  const portalGrad = ctx.createLinearGradient(g.x, g.gapTop, g.x + g.w, g.gapTop);
  portalGrad.addColorStop(0, `hsla(${h},100%,70%,0)`);
  portalGrad.addColorStop(0.5, `hsla(${h},100%,80%,${0.18 * glowAlpha})`);
  portalGrad.addColorStop(1, `hsla(${h},100%,70%,0)`);
  ctx.fillStyle = portalGrad;
  ctx.fillRect(g.x, g.gapTop, g.w, g.gapBot - g.gapTop);
  ctx.restore();

  // Edge glow beams (top and bottom of gap)
  for (const edgeY of [g.gapTop, g.gapBot]) {
    ctx.save();
    ctx.shadowColor = `hsl(${h},100%,80%)`;
    ctx.shadowBlur = 12 * glowAlpha;
    ctx.strokeStyle = `hsl(${h},100%,80%)`;
    ctx.lineWidth = 2.5;
    ctx.globalAlpha = 0.8 * glowAlpha;
    ctx.beginPath();
    ctx.moveTo(g.x, edgeY);
    ctx.lineTo(g.x + g.w, edgeY);
    ctx.stroke();
    ctx.restore();
  }

  // Pass glow burst
  if (g.glow > 0) {
    ctx.save();
    ctx.globalAlpha = g.glow * 0.6;
    ctx.shadowColor = `hsl(${h},100%,90%)`;
    ctx.shadowBlur = 40 * g.glow;
    ctx.fillStyle = `hsl(${h},100%,80%)`;
    ctx.fillRect(g.x, g.gapTop, g.w, g.gapBot - g.gapTop);
    ctx.restore();
  }

  // Pulse timing indicator — small dots on gate edge
  ctx.save();
  ctx.globalAlpha = 0.7 * glowAlpha;
  ctx.fillStyle = `hsl(${h},100%,90%)`;
  ctx.shadowColor = `hsl(${h},100%,80%)`;
  ctx.shadowBlur = 8;
  const midY = (g.gapTop + g.gapBot) / 2;
  ctx.beginPath();
  ctx.arc(g.x + g.w / 2, midY, 5 + 3 * pulse, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawNote(n) {
  if (n.collected) return;
  const pulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.006);
  ctx.save();
  ctx.shadowColor = `hsl(${n.h},100%,80%)`;
  ctx.shadowBlur = 12 + 8 * pulse + n.glow * 20;
  ctx.fillStyle = `hsl(${n.h},90%,70%)`;
  ctx.globalAlpha = 0.85 + 0.15 * pulse;
  ctx.beginPath();
  ctx.arc(n.x, n.y, n.r + 2 * pulse, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#fff';
  ctx.globalAlpha = 0.7;
  ctx.font = `bold ${n.r}px Courier New`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('♪', n.x, n.y);
  ctx.restore();
}

function drawHUD() {
  // Score
  ctx.save();
  const scoreTint = comboFlash > 0
    ? `hsl(${sectionHue},100%,80%)`
    : '#fff';
  ctx.font = 'bold 32px Courier New';
  ctx.textAlign = 'center';
  ctx.fillStyle = scoreTint;
  ctx.shadowColor = scoreTint;
  ctx.shadowBlur = comboFlash * 20;
  ctx.fillText(score, W / 2, 48);
  ctx.restore();

  // Combo
  if (combo > 1) {
    ctx.save();
    ctx.font = `bold 16px Courier New`;
    ctx.textAlign = 'center';
    ctx.fillStyle = `hsl(${sectionHue},100%,70%)`;
    ctx.shadowColor = ctx.fillStyle;
    ctx.shadowBlur = 12;
    ctx.fillText(`x${combo} COMBO`, W / 2, 72);
    ctx.restore();
  }

  // Glide indicator
  ctx.save();
  ctx.font = '12px Courier New';
  ctx.textAlign = 'left';
  ctx.fillStyle = bird.gliding
    ? `hsl(${sectionHue},100%,70%)`
    : `rgba(255,255,255,0.35)`;
  ctx.shadowColor = ctx.fillStyle;
  ctx.shadowBlur = bird.gliding ? 10 : 0;
  ctx.fillText(bird.gliding ? '▲ GLIDE' : '▼ FALL', 16, H - 20);
  ctx.restore();

  // Level indicator
  if (level > 0) {
    ctx.save();
    ctx.font = '11px Courier New';
    ctx.textAlign = 'right';
    ctx.fillStyle = `hsl(${sectionHue},80%,60%)`;
    ctx.fillText(`LVL ${level}`, W - 16, H - 20);
    ctx.restore();
  }
}

function drawStartScreen() {
  // Title
  ctx.save();
  ctx.textAlign = 'center';

  // Glow title
  const t = Date.now() * 0.001;
  const h = (200 + t * 20) % 360;

  ctx.font = 'bold 52px Courier New';
  ctx.fillStyle = `hsl(${h},100%,70%)`;
  ctx.shadowColor = `hsl(${h},100%,80%)`;
  ctx.shadowBlur = 30 + 10 * Math.sin(t * 2);
  ctx.fillText('SYNTH', W / 2, H / 2 - 60);
  ctx.fillStyle = `hsl(${(h + 40) % 360},100%,70%)`;
  ctx.shadowColor = `hsl(${(h + 40) % 360},100%,80%)`;
  ctx.fillText('GLIDE', W / 2, H / 2 - 5);

  ctx.shadowBlur = 0;
  ctx.font = '15px Courier New';
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fillText('BEATSTREAM SWITCH', W / 2, H / 2 + 28);

  const blink = Math.sin(t * 3) > 0;
  if (blink) {
    ctx.font = 'bold 17px Courier New';
    ctx.fillStyle = '#fff';
    ctx.shadowColor = '#fff';
    ctx.shadowBlur = 12;
    ctx.fillText('TAP TO START', W / 2, H / 2 + 80);
  }

  ctx.shadowBlur = 0;
  ctx.font = '13px Courier New';
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.fillText('Tap to toggle Glide / Fall', W / 2, H / 2 + 115);
  ctx.fillText('Pass through rhythm gates for points', W / 2, H / 2 + 136);
  ctx.fillText('Hit pulse windows for 2× bonus!', W / 2, H / 2 + 157);

  if (highScore > 0) {
    ctx.font = '14px Courier New';
    ctx.fillStyle = `hsl(${h},80%,65%)`;
    ctx.fillText(`BEST: ${highScore}`, W / 2, H / 2 + 195);
  }

  ctx.restore();
}

function drawGameOverScreen() {
  ctx.save();
  ctx.textAlign = 'center';
  const t = Date.now() * 0.001;
  const h = sectionHue;

  // Panel
  ctx.fillStyle = 'rgba(0,0,0,0.65)';
  ctx.beginPath();
  ctx.roundRect(W / 2 - 160, H / 2 - 140, 320, 280, 18);
  ctx.fill();

  ctx.strokeStyle = `hsl(${h},80%,50%)`;
  ctx.lineWidth = 2;
  ctx.shadowColor = `hsl(${h},100%,70%)`;
  ctx.shadowBlur = 16;
  ctx.stroke();
  ctx.shadowBlur = 0;

  ctx.font = 'bold 30px Courier New';
  ctx.fillStyle = '#ff4466';
  ctx.shadowColor = '#ff4466';
  ctx.shadowBlur = 20;
  ctx.fillText('GAME OVER', W / 2, H / 2 - 100);
  ctx.shadowBlur = 0;

  ctx.font = 'bold 50px Courier New';
  ctx.fillStyle = '#fff';
  ctx.fillText(score, W / 2, H / 2 - 46);

  ctx.font = '16px Courier New';
  ctx.fillStyle = 'rgba(255,255,255,0.55)';
  ctx.fillText('SCORE', W / 2, H / 2 - 18);

  ctx.font = '18px Courier New';
  ctx.fillStyle = `hsl(${h},90%,70%)`;
  ctx.fillText(`BEST: ${highScore}`, W / 2, H / 2 + 20);

  if (combo > 0) {
    ctx.font = '15px Courier New';
    ctx.fillStyle = 'rgba(255,255,255,0.45)';
    ctx.fillText(`Max Combo: x${combo}`, W / 2, H / 2 + 50);
  }

  const blink = Math.sin(t * 3) > 0;
  if (blink) {
    ctx.font = 'bold 17px Courier New';
    ctx.fillStyle = '#fff';
    ctx.shadowColor = '#fff';
    ctx.shadowBlur = 12;
    ctx.fillText('TAP TO RETRY', W / 2, H / 2 + 95);
    ctx.shadowBlur = 0;
  }

  ctx.restore();
}

// ─── Main Draw ────────────────────────────────────────────────────────────────
function draw() {
  ctx.save();
  ctx.translate(shake.x, shake.y);

  drawBackground();

  if (state === 'playing' || state === 'gameover') {
    for (const g of gates) drawGate(g);
    for (const n of notes) drawNote(n);
    drawTrail();
    drawParticles();
    drawBird();
    if (state === 'playing') drawHUD();
  }

  ctx.restore();

  if (state === 'start') drawStartScreen();
  if (state === 'gameover') {
    drawParticles();
    drawGameOverScreen();
  }
}

// ─── Game Loop ────────────────────────────────────────────────────────────────
function loop(ts) {
  const dt = Math.min((ts - lastTime) / 1000, 0.033);
  lastTime = ts;

  if (state === 'playing') {
    update(dt);
  } else if (state === 'start' || state === 'gameover') {
    // Still animate particles and background
    bgHue = (bgHue + 8 * dt) % 360;
    updateParticles(dt);
    updateShake(dt);
  }

  draw();
  animId = requestAnimationFrame(loop);
}

// ─── Share ────────────────────────────────────────────────────────────────────
shareBtn.addEventListener('click', async (e) => {
  e.stopPropagation();
  const text = `I scored ${score} in Synth Glide! Can you beat me?\nhttps://balinti.github.io/synth-glide/`;
  if (navigator.share) {
    try {
      await navigator.share({ title: 'Synth Glide', text, url: 'https://balinti.github.io/synth-glide/' });
    } catch (_) {}
  } else {
    try {
      await navigator.clipboard.writeText(text);
      const orig = shareBtn.textContent;
      shareBtn.textContent = 'Copied!';
      setTimeout(() => { shareBtn.textContent = orig; }, 1500);
    } catch (_) {}
  }
});

// Prevent share button from triggering game input
shareBtn.addEventListener('pointerdown', (e) => e.stopPropagation());

// ─── Start ────────────────────────────────────────────────────────────────────
// Draw start screen immediately
drawBackground();
drawStartScreen();

lastTime = performance.now();
animId = requestAnimationFrame(loop);

})();
</script>
</body>
</html>
