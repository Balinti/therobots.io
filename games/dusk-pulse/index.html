<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Dusk Pulse - Free HTML5 Game</title>
<meta name="description" content="Play Dusk Pulse - Tap timed pulses along a setting sun's horizon to chain combos and trigger vibrant color bursts.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#1a0a2e">
<link rel="canonical" href="https://balinti.github.io/dusk-pulse/">
<meta property="og:type" content="website">
<meta property="og:title" content="Dusk Pulse - Free HTML5 Game">
<meta property="og:description" content="Play Dusk Pulse - Tap timed pulses along a setting sun's horizon to chain combos and trigger vibrant color bursts.">
<meta property="og:url" content="https://balinti.github.io/dusk-pulse/">
<meta property="og:image" content="https://balinti.github.io/dusk-pulse/og-image.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Dusk Pulse - Free HTML5 Game">
<meta name="twitter:description" content="Play Dusk Pulse - Tap timed pulses along a setting sun's horizon to chain combos and trigger vibrant color bursts.">
<meta name="twitter:image" content="https://balinti.github.io/dusk-pulse/og-image.jpg">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0d0518;font-family:'Segoe UI',system-ui,sans-serif;touch-action:none;-webkit-tap-highlight-color:transparent;user-select:none}
#shell{position:relative;max-width:420px;max-height:750px;width:100%;height:100vh;margin:0 auto;background:linear-gradient(180deg,#1a0a2e 0%,#0d0518 100%);overflow:hidden}
canvas{display:block;width:100%;height:100%}
#share-btn{display:none;position:absolute;bottom:18%;left:50%;transform:translateX(-50%);background:rgba(255,255,255,0.12);color:#fff;border:1px solid rgba(255,255,255,0.25);border-radius:22px;padding:10px 28px;font-size:15px;cursor:pointer;backdrop-filter:blur(6px);z-index:2;letter-spacing:0.5px;transition:background 0.2s}
#share-btn:hover{background:rgba(255,255,255,0.22)}
</style>
</head>
<body>
<div id="shell">
<canvas id="gc"></canvas>
<button id="share-btn">Share Score</button>
</div>
<script>
'use strict';
(()=>{

// ── Canvas Setup ──
const shell = document.getElementById('shell');
const cv = document.getElementById('gc');
const ctx = cv.getContext('2d');
const shareBtn = document.getElementById('share-btn');

let W, H, dpr, horizonY;

function resize() {
  const r = shell.getBoundingClientRect();
  dpr = Math.min(window.devicePixelRatio || 1, 3);
  W = r.width;
  H = r.height;
  cv.width = W * dpr;
  cv.height = H * dpr;
  cv.style.width = W + 'px';
  cv.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  horizonY = H * 0.62;
}
window.addEventListener('resize', resize);
resize();

// ── Constants ──
const WARM_HUE = 25;
const COOL_HUE = 210;
const POLARITY_WARM = 0;
const POLARITY_COOL = 1;
const MISS_LIMIT = 3;
const SURGE_DURATION = 3;
const FLIP_COOLDOWN = 0.18;
const PERFECT_DIST = 4;
const STREAK_PER_MULTI = 8;
const MAX_MULTI = 5;

// ── State ──
const STATE = { START: 0, PLAYING: 1, GAMEOVER: 2 };
let state = STATE.START;
let score, bestScore, streak, misses, sunDim, surgeMeter, surgeTimer, surgeActive;
let cursorX, cursorDir, cursorPolarity, flipCooldown;
let gates, particles, shakeX, shakeY, shakeDur;
let tRun, lastGateSpawn, perfectStreak, hueShift;
let newBest;
let lastTime = 0;

bestScore = parseInt(localStorage.getItem('dp_best') || '0', 10);

function initGame() {
  score = 0; streak = 0; misses = 0; sunDim = 0; newBest = false;
  surgeMeter = 0; surgeTimer = 0; surgeActive = false;
  cursorX = W * 0.5; cursorDir = 1; cursorPolarity = POLARITY_WARM;
  flipCooldown = 0; gates = []; particles = [];
  shakeX = 0; shakeY = 0; shakeDur = 0;
  tRun = 0; lastGateSpawn = -1; perfectStreak = 0; hueShift = 0;
}

// ── Difficulty helpers ──
function cursorSpeed() {
  const base = 160 + Math.min(220, 3.2 * tRun);
  return base * (surgeActive ? 1.35 : 1);
}
function spawnInterval() {
  const base = Math.max(0.42, 0.95 - 0.0065 * tRun);
  return base * (surgeActive ? 0.75 : 1);
}
function gateWidth() {
  return Math.max(18, 34 - 0.12 * tRun);
}
function gateTypeProbabilities() {
  if (tRun < 12) return [1, 0, 0];
  if (tRun < 30) return [0.6, 0.3, 0.1];
  if (tRun < 60) return [0.35, 0.35, 0.3];
  return [0.25, 0.35, 0.4];
}
function pickGateType() {
  const p = gateTypeProbabilities();
  const r = Math.random();
  if (r < p[0]) return 'single';
  if (r < p[0] + p[1]) return 'double';
  return 'mirror';
}

// ── Gate spawning ──
function spawnGate() {
  const type = pickGateType();
  const w = gateWidth();
  const margin = 30;
  if (type === 'single') {
    const x = margin + Math.random() * (W - 2 * margin);
    const pol = Math.random() < 0.5 ? POLARITY_WARM : POLARITY_COOL;
    gates.push({ x, w, polarity: pol, type: 'single', processed: false, flashTimer: 0 });
  } else if (type === 'double') {
    const x1 = margin + Math.random() * (W * 0.5 - margin);
    const x2 = x1 + w + 8 + Math.random() * 20;
    const pol1 = Math.random() < 0.5 ? POLARITY_WARM : POLARITY_COOL;
    const pol2 = Math.random() < 0.4 ? (1 - pol1) : pol1;
    gates.push({ x: x1, w, polarity: pol1, type: 'double-a', processed: false, flashTimer: 0 });
    gates.push({ x: Math.min(x2, W - margin), w, polarity: pol2, type: 'double-b', processed: false, flashTimer: 0 });
  } else {
    const x1 = margin + Math.random() * (W * 0.3);
    const x2 = W - margin - Math.random() * (W * 0.3);
    const pol1 = Math.random() < 0.5 ? POLARITY_WARM : POLARITY_COOL;
    const pol2 = 1 - pol1;
    gates.push({ x: x1, w, polarity: pol1, type: 'mirror-a', processed: false, flashTimer: 0 });
    gates.push({ x: x2, w, polarity: pol2, type: 'mirror-b', processed: false, flashTimer: 0 });
  }
}

// ── Particles ──
function emitParticles(x, y, count, hue, sat, bright, spread) {
  for (let i = 0; i < count; i++) {
    const angle = -Math.PI * 0.5 + (Math.random() - 0.5) * spread;
    const speed = 40 + Math.random() * 120;
    particles.push({
      x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
      life: 0.5 + Math.random() * 0.7, maxLife: 0.5 + Math.random() * 0.7,
      size: 2 + Math.random() * 3, hue, sat, bright
    });
  }
}

// ── Shake ──
function triggerShake(intensity, dur) {
  shakeDur = dur;
  shakeX = (Math.random() - 0.5) * intensity;
  shakeY = (Math.random() - 0.5) * intensity;
}

// ── Polarity flip ──
function flipPolarity() {
  if (flipCooldown > 0) return;
  cursorPolarity = 1 - cursorPolarity;
  flipCooldown = FLIP_COOLDOWN;
  // small visual burst
  const hue = cursorPolarity === POLARITY_WARM ? WARM_HUE : COOL_HUE;
  emitParticles(cursorX, horizonY, 5, hue, 90, 70, 1.2);
}

// ── Scoring / collision ──
function processGate(gate, dx) {
  const perfect = Math.abs(dx) <= PERFECT_DIST;
  const matched = gate.polarity === cursorPolarity;

  if (matched) {
    // Hit
    streak++;
    const multi = Math.min(MAX_MULTI, 1 + Math.floor(streak / STREAK_PER_MULTI));
    let pts = 10;
    if (perfect) { pts += 5; perfectStreak++; } else { perfectStreak = 0; }
    if (surgeActive) pts *= 2;
    pts *= multi;
    score += pts;

    surgeMeter = Math.min(1, surgeMeter + (perfect ? 0.14 : 0.09));

    const hue = gate.polarity === POLARITY_WARM ? WARM_HUE : COOL_HUE;
    emitParticles(gate.x, horizonY, perfect ? 24 : 14, hue, 95, 80, 2.0);
    gate.flashTimer = 0.3;
    triggerShake(perfect ? 5 : 3, 0.12);

    // Retention: 3 perfects in a row restores 1 miss
    if (perfectStreak >= 3 && misses > 0) {
      misses = Math.max(0, misses - 1);
      sunDim = Math.max(0, sunDim - 0.34);
      perfectStreak = 0;
      emitParticles(W * 0.5, horizonY - 60, 10, 55, 100, 90, 3);
    }
  } else {
    // Near-miss / miss
    const nearMiss = Math.abs(dx) < gate.w * 0.8;
    streak = 0; perfectStreak = 0;
    misses++;
    sunDim = Math.min(1, sunDim + 0.34);
    surgeMeter = Math.max(0, surgeMeter - 0.18);
    emitParticles(gate.x, horizonY, 22, 0, 30, 30, 2.5);
    triggerShake(nearMiss ? 4 : 7, nearMiss ? 0.15 : 0.25);
    gate.flashTimer = 0.3;

    if (misses >= MISS_LIMIT) {
      endGame();
      return;
    }
  }
  gate.processed = true;
}

function endGame() {
  state = STATE.GAMEOVER;
  triggerShake(14, 0.5);
  emitParticles(cursorX, horizonY, 40, 0, 50, 50, Math.PI);
  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem('dp_best', bestScore.toString());
    newBest = true;
  }
  shareBtn.style.display = 'block';
}

// ── Surge ──
function activateSurge() {
  surgeActive = true;
  surgeTimer = SURGE_DURATION;
  surgeMeter = 0;
  emitParticles(W * 0.5, horizonY, 30, 55, 100, 95, Math.PI);
}

// ── Input ──
function handleInput() {
  if (state === STATE.START) {
    initGame();
    state = STATE.PLAYING;
  } else if (state === STATE.PLAYING) {
    flipPolarity();
  } else if (state === STATE.GAMEOVER) {
    shareBtn.style.display = 'none';
    state = STATE.START;
  }
}

cv.addEventListener('pointerdown', (e) => { e.preventDefault(); handleInput(); });
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); handleInput(); }
});

// ── Share ──
shareBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  const text = `I scored ${score} in Dusk Pulse! Can you beat me?\nhttps://balinti.github.io/dusk-pulse/?challengeScore=${score}`;
  if (navigator.share) {
    navigator.share({ title: 'Dusk Pulse', text }).catch(() => {});
  } else if (navigator.clipboard) {
    navigator.clipboard.writeText(text).then(() => {
      shareBtn.textContent = 'Copied!';
      setTimeout(() => { shareBtn.textContent = 'Share Score'; }, 1500);
    });
  }
});

// ── Drawing helpers ──
function polarityColor(pol, alpha) {
  const h = pol === POLARITY_WARM ? WARM_HUE : COOL_HUE;
  return `hsla(${h},90%,65%,${alpha})`;
}
function polarityGlow(pol) {
  const h = pol === POLARITY_WARM ? WARM_HUE : COOL_HUE;
  return `hsla(${h},100%,70%,0.5)`;
}

// ── Render: Background ──
function drawBackground() {
  const dimFactor = 1 - sunDim * 0.6;
  // Sky gradient
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  skyGrad.addColorStop(0, `hsl(${260 + hueShift * 10},45%,${8 * dimFactor}%)`);
  skyGrad.addColorStop(0.5, `hsl(${280 + hueShift * 15},50%,${14 * dimFactor}%)`);
  skyGrad.addColorStop(0.7, `hsl(${310 + hueShift * 20},55%,${22 * dimFactor}%)`);
  skyGrad.addColorStop(1, `hsl(${340 + hueShift * 8},40%,${6 * dimFactor}%)`);
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);

  // Sun
  const sunR = 35 * (1 - sunDim * 0.5);
  const sunY = horizonY - 10;
  const sunGrad = ctx.createRadialGradient(W * 0.5, sunY, 0, W * 0.5, sunY, sunR * 3);
  const sunAlpha = (0.8 - sunDim * 0.6).toFixed(2);
  sunGrad.addColorStop(0, `hsla(${35 + hueShift * 30},100%,70%,${sunAlpha})`);
  sunGrad.addColorStop(0.4, `hsla(${20 + hueShift * 20},90%,55%,${(sunAlpha * 0.5).toFixed(2)})`);
  sunGrad.addColorStop(1, 'hsla(0,0%,0%,0)');
  ctx.fillStyle = sunGrad;
  ctx.fillRect(0, sunY - sunR * 3, W, sunR * 6);

  ctx.beginPath();
  ctx.arc(W * 0.5, sunY, sunR, 0, Math.PI * 2);
  ctx.fillStyle = `hsla(${40 + hueShift * 30},100%,${75 * dimFactor}%,${sunAlpha})`;
  ctx.fill();
}

// ── Render: Horizon line ──
function drawHorizon() {
  ctx.save();
  ctx.strokeStyle = `hsla(${280 + hueShift * 20},40%,35%,0.6)`;
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(0, horizonY);
  ctx.lineTo(W, horizonY);
  ctx.stroke();
  ctx.restore();
}

// ── Render: Gates ──
function drawGates() {
  for (const g of gates) {
    if (g.processed) continue;
    const hue = g.polarity === POLARITY_WARM ? WARM_HUE : COOL_HUE;
    const alpha = 0.6 + Math.sin(tRun * 6 + g.x) * 0.2;
    const flash = g.flashTimer > 0 ? g.flashTimer * 3 : 0;

    // Gate beam
    ctx.save();
    ctx.strokeStyle = `hsla(${hue},85%,${60 + flash * 30}%,${alpha + flash})`;
    ctx.lineWidth = 2 + flash * 2;
    ctx.shadowColor = `hsla(${hue},100%,60%,${0.4 + flash})`;
    ctx.shadowBlur = 8 + flash * 15;
    ctx.beginPath();
    ctx.moveTo(g.x, horizonY - 18 - flash * 5);
    ctx.lineTo(g.x, horizonY + 18 + flash * 5);
    ctx.stroke();

    // Gate wings
    const hw = g.w * 0.5;
    ctx.strokeStyle = `hsla(${hue},80%,55%,${alpha * 0.7})`;
    ctx.lineWidth = 1.5;
    ctx.shadowBlur = 4;
    ctx.beginPath();
    ctx.moveTo(g.x - hw, horizonY - 6);
    ctx.lineTo(g.x - hw, horizonY + 6);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(g.x + hw, horizonY - 6);
    ctx.lineTo(g.x + hw, horizonY + 6);
    ctx.stroke();
    ctx.restore();

    // Polarity pip
    ctx.beginPath();
    ctx.arc(g.x, horizonY - 22, 3, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${hue},90%,70%,${alpha})`;
    ctx.fill();
  }
}

// ── Render: Cursor ──
function drawCursor() {
  const hue = cursorPolarity === POLARITY_WARM ? WARM_HUE : COOL_HUE;
  const pulse = 1 + Math.sin(tRun * 10) * 0.15;

  // Trail
  ctx.save();
  ctx.globalAlpha = 0.3;
  for (let i = 1; i <= 5; i++) {
    const tx = cursorX - cursorDir * i * 4;
    const r = (6 - i) * pulse;
    ctx.beginPath();
    ctx.arc(tx, horizonY, r, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${hue},80%,60%,${0.15 / i})`;
    ctx.fill();
  }
  ctx.restore();

  // Glow
  ctx.save();
  ctx.shadowColor = `hsla(${hue},100%,65%,0.8)`;
  ctx.shadowBlur = 16 * pulse;
  ctx.beginPath();
  ctx.arc(cursorX, horizonY, 7 * pulse, 0, Math.PI * 2);
  ctx.fillStyle = `hsla(${hue},90%,70%,0.95)`;
  ctx.fill();
  ctx.restore();

  // Core
  ctx.beginPath();
  ctx.arc(cursorX, horizonY, 4, 0, Math.PI * 2);
  ctx.fillStyle = '#fff';
  ctx.fill();
}

// ── Render: Particles ──
function drawParticles() {
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for (const p of particles) {
    const t = p.life / p.maxLife;
    ctx.globalAlpha = t * 0.8;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * t, 0, Math.PI * 2);
    ctx.fillStyle = `hsl(${p.hue},${p.sat}%,${p.bright}%)`;
    ctx.fill();
  }
  ctx.restore();
}

// ── Render: HUD ──
function drawHUD() {
  // Score
  ctx.save();
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.font = 'bold 28px "Segoe UI", system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(score, W * 0.5, 48);

  // Streak
  if (streak > 0) {
    const multi = Math.min(MAX_MULTI, 1 + Math.floor(streak / STREAK_PER_MULTI));
    ctx.font = '16px "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = `hsla(${45},90%,70%,0.85)`;
    ctx.fillText(`x${multi}  streak ${streak}`, W * 0.5, 70);
  }

  // Miss indicator (3 dots)
  for (let i = 0; i < MISS_LIMIT; i++) {
    const mx = W * 0.5 - 20 + i * 20;
    const my = 88;
    ctx.beginPath();
    ctx.arc(mx, my, 5, 0, Math.PI * 2);
    if (i < MISS_LIMIT - misses) {
      ctx.fillStyle = `hsla(${40},100%,70%,0.8)`;
    } else {
      ctx.fillStyle = 'hsla(0,0%,30%,0.5)';
    }
    ctx.fill();
  }

  // Surge meter bar
  const barW = 100, barH = 6;
  const barX = (W - barW) * 0.5, barY = 100;
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.fillRect(barX, barY, barW, barH);
  if (surgeMeter > 0) {
    const surgeHue = surgeActive ? (tRun * 200 % 360) : 45;
    ctx.fillStyle = `hsla(${surgeHue},90%,65%,0.9)`;
    ctx.fillRect(barX, barY, barW * surgeMeter, barH);
  }
  if (surgeActive) {
    ctx.font = 'bold 12px "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = `hsla(${(tRun * 200) % 360},100%,75%,0.9)`;
    ctx.fillText('SURGE', W * 0.5, barY + 20);
  }

  // Polarity indicator
  const indR = 10;
  const indX = W - 30, indY = 40;
  ctx.beginPath();
  ctx.arc(indX, indY, indR, 0, Math.PI * 2);
  ctx.fillStyle = polarityColor(cursorPolarity, 0.9);
  ctx.shadowColor = polarityGlow(cursorPolarity);
  ctx.shadowBlur = 10;
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.font = '9px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.fillText(cursorPolarity === POLARITY_WARM ? 'W' : 'C', indX, indY + 3.5);

  ctx.restore();
}

// ── Render: Start screen ──
function drawStartScreen() {
  ctx.save();
  ctx.fillStyle = 'rgba(255,255,255,0.92)';
  ctx.textAlign = 'center';
  ctx.font = 'bold 36px "Segoe UI", system-ui, sans-serif';
  ctx.fillText('DUSK PULSE', W * 0.5, H * 0.28);

  ctx.font = '14px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('Sunline Switch', W * 0.5, H * 0.28 + 26);

  // Animated pulse
  const p = 0.6 + Math.sin(Date.now() * 0.004) * 0.3;
  ctx.font = '18px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = `rgba(255,255,255,${p})`;
  ctx.fillText('Tap to Start', W * 0.5, H * 0.48);

  // How to play
  ctx.font = '13px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.fillText('Tap / Space to flip polarity', W * 0.5, H * 0.58);

  // Warm/Cool labels
  ctx.fillStyle = polarityColor(POLARITY_WARM, 0.7);
  ctx.fillText('● Warm', W * 0.5 - 45, H * 0.63);
  ctx.fillStyle = polarityColor(POLARITY_COOL, 0.7);
  ctx.fillText('● Cool', W * 0.5 + 45, H * 0.63);

  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fillText('Match the gate color to score!', W * 0.5, H * 0.68);
  ctx.fillText('3 misses = game over', W * 0.5, H * 0.72);

  if (bestScore > 0) {
    ctx.font = '14px "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.fillText(`Best: ${bestScore}`, W * 0.5, H * 0.82);
  }
  ctx.restore();
}

// ── Render: Game Over ──
function drawGameOver() {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.font = 'bold 30px "Segoe UI", system-ui, sans-serif';
  ctx.fillText('GAME OVER', W * 0.5, H * 0.3);

  ctx.font = 'bold 48px "Segoe UI", system-ui, sans-serif';
  ctx.fillText(score, W * 0.5, H * 0.42);

  if (newBest) {
    ctx.font = 'bold 16px "Segoe UI", system-ui, sans-serif';
    const nb = 0.6 + Math.sin(Date.now() * 0.006) * 0.4;
    ctx.fillStyle = `hsla(50,100%,65%,${nb})`;
    ctx.fillText('NEW BEST!', W * 0.5, H * 0.48);
  }

  ctx.font = '15px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText(`Best: ${bestScore}`, W * 0.5, H * 0.54);

  const tp = 0.5 + Math.sin(Date.now() * 0.004) * 0.3;
  ctx.font = '17px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = `rgba(255,255,255,${tp})`;
  ctx.fillText('Tap to Retry', W * 0.5, H * 0.68);
  ctx.restore();
}

// ── Update ──
function update(dt) {
  hueShift = (hueShift + dt * 0.03) % 1;

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 120 * dt; // gravity
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Shake decay
  if (shakeDur > 0) {
    shakeDur -= dt;
    const intensity = shakeDur * 20;
    shakeX = (Math.random() - 0.5) * intensity;
    shakeY = (Math.random() - 0.5) * intensity;
    if (shakeDur <= 0) { shakeX = 0; shakeY = 0; }
  }

  // Gate flash decay
  for (const g of gates) {
    if (g.flashTimer > 0) g.flashTimer -= dt;
  }

  if (state !== STATE.PLAYING) return;

  tRun += dt;
  flipCooldown = Math.max(0, flipCooldown - dt);

  // Surge timer
  if (surgeActive) {
    surgeTimer -= dt;
    if (surgeTimer <= 0) { surgeActive = false; surgeTimer = 0; }
  }

  // Activate surge
  if (!surgeActive && surgeMeter >= 1) {
    activateSurge();
  }

  // Move cursor
  const speed = cursorSpeed();
  cursorX += cursorDir * speed * dt;

  // Bounce off walls
  if (cursorX >= W - 10) { cursorX = W - 10; cursorDir = -1; }
  if (cursorX <= 10) { cursorX = 10; cursorDir = 1; }

  // Spawn gates
  if (tRun - lastGateSpawn >= spawnInterval()) {
    spawnGate();
    lastGateSpawn = tRun;
  }

  // Process gate collisions
  for (const g of gates) {
    if (g.processed) continue;
    const dx = cursorX - g.x;
    const hw = g.w * 0.5;
    // Cursor passed through gate window
    if (Math.abs(dx) <= hw + 3) {
      processGate(g, dx);
    }
    // Cursor far past gate - auto-miss if unprocessed
    else if (Math.abs(dx) > hw + 30 && (
      (cursorDir > 0 && cursorX > g.x + hw + 30) ||
      (cursorDir < 0 && cursorX < g.x - hw - 30)
    )) {
      // auto miss - cursor swept past without entering
      g.processed = true;
      streak = 0;
      perfectStreak = 0;
      misses++;
      sunDim = Math.min(1, sunDim + 0.34);
      surgeMeter = Math.max(0, surgeMeter - 0.18);
      emitParticles(g.x, horizonY, 12, 0, 20, 25, 2);
      triggerShake(5, 0.15);
      if (misses >= MISS_LIMIT) { endGame(); return; }
    }
  }

  // Cleanup old processed gates
  gates = gates.filter(g => !(g.processed && g.flashTimer <= 0));
}

// ── Main loop ──
function loop(ts) {
  requestAnimationFrame(loop);
  const dt = Math.min(0.05, (ts - lastTime) / 1000);
  lastTime = ts;

  update(dt);

  ctx.save();
  ctx.translate(shakeX, shakeY);

  drawBackground();
  drawHorizon();

  if (state === STATE.PLAYING) {
    drawGates();
    drawCursor();
    drawHUD();
  } else if (state === STATE.START) {
    // Animate some idle particles
    if (Math.random() < 0.03) {
      emitParticles(Math.random() * W, horizonY, 2, 280, 50, 50, 2);
    }
    drawStartScreen();
  } else if (state === STATE.GAMEOVER) {
    drawGates();
    drawCursor();
    drawHUD();
    drawGameOver();
  }

  drawParticles();
  ctx.restore();
}

requestAnimationFrame(loop);

})();
</script>
</body>
</html>
