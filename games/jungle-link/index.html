<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Jungle Link - Free HTML5 Game</title>
<meta name="description" content="Play Jungle Link - Tap to connect jungle vines while controls reverse unpredictably to challenge your reflexes.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#1a2e1a">
<meta property="og:type" content="website">
<meta property="og:title" content="Jungle Link - Free HTML5 Game">
<meta property="og:description" content="Tap to zip through glowing vine rings! Time your links perfectly for combos and bonus points.">
<meta property="og:url" content="https://balinti.github.io/jungle-link/">
<meta property="og:image" content="https://balinti.github.io/jungle-link/preview.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Jungle Link - Free HTML5 Game">
<meta name="twitter:description" content="Tap to zip through glowing vine rings! Time your links perfectly for combos and bonus points.">
<meta name="twitter:image" content="https://balinti.github.io/jungle-link/preview.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;background:#0d1f0d;overflow:hidden;font-family:'Segoe UI',sans-serif;touch-action:none}
#wrap{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;height:100%}
#gameContainer{position:relative;width:100%;max-width:420px;height:100%;max-height:750px;overflow:hidden;background:#0d1f0d}
canvas{display:block;width:100%;height:100%}
#seoContent{display:none}
</style>
</head>
<body>
<div id="wrap"><div id="gameContainer"><canvas id="gc"></canvas></div></div>
<section id="seoContent">
<h1>Jungle Link - Vine Zip Game</h1>
<p>Jungle Link is a free hyper-casual HTML5 game. Tap to zip your runner through glowing vine rings as they approach. Time your tap inside the ring to succeed — hit the golden perfect zone for bonus points and combos. Miss, and it's game over!</p>
<h2>How to Play</h2>
<ul>
<li>Tap, click, or press Space/Enter to attempt a vine link.</li>
<li>Your runner moves forward automatically.</li>
<li>Hit inside the glowing ring to link — hit the golden core for a Perfect.</li>
<li>Chain Perfects to build a combo multiplier up to 6x.</li>
<li>Rings shrink, sway, and add thorns as you progress.</li>
</ul>
<h2>FAQ</h2>
<dl>
<dt>Is Jungle Link free?</dt><dd>Yes, completely free to play in your browser.</dd>
<dt>Does it work on mobile?</dt><dd>Yes, tap anywhere to play on any device.</dd>
<dt>How do I get a high score?</dt><dd>Chain perfect links for the combo multiplier.</dd>
</dl>
</section>
<script>
(function(){
'use strict';

// ── URL params ──────────────────────────────────────────────────────────────
const params = new URLSearchParams(location.search);
const challengeScore = parseInt(params.get('challenge')) || 0;

// ── Canvas setup ─────────────────────────────────────────────────────────────
const canvas = document.getElementById('gc');
const ctx = canvas.getContext('2d', {alpha: false});
const container = document.getElementById('gameContainer');
let W, H, DPR;

function resize() {
  const rect = container.getBoundingClientRect();
  W = rect.width; H = rect.height;
  DPR = window.devicePixelRatio || 1;
  canvas.width = W * DPR;
  canvas.height = H * DPR;
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
resize();
window.addEventListener('resize', resize);

// ── Storage ───────────────────────────────────────────────────────────────────
function getToday(){ return new Date().toISOString().slice(0,10); }
let hiScore = parseInt(localStorage.getItem('jl_hi')||'0');
let todayKey = 'jl_today_'+getToday();
let todayBest = parseInt(localStorage.getItem(todayKey)||'0');

function saveScores(s){
  if(s>hiScore){hiScore=s;localStorage.setItem('jl_hi',s);}
  if(s>todayBest){todayBest=s;localStorage.setItem(todayKey,s);}
}

// ── Particle pool ─────────────────────────────────────────────────────────────
const POOL_SIZE = 300;
const pool = [];
for(let i=0;i<POOL_SIZE;i++) pool.push({active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:0,r:3,hue:120,alpha:1,type:'leaf'});
let poolIdx = 0;

function spawnParticle(x,y,vx,vy,life,r,hue,type){
  let p = pool[poolIdx % POOL_SIZE]; poolIdx++;
  p.active=true; p.x=x; p.y=y; p.vx=vx; p.vy=vy;
  p.life=life; p.maxLife=life; p.r=r; p.hue=hue; p.type=type; p.alpha=1;
}

function spawnBurst(x,y,count,hue,type){
  for(let i=0;i<count;i++){
    const a=Math.random()*Math.PI*2;
    const spd=1+Math.random()*4;
    spawnParticle(x,y,Math.cos(a)*spd,Math.sin(a)*spd,
      0.4+Math.random()*0.5, 2+Math.random()*4, hue+(Math.random()-0.5)*40, type);
  }
}

// ── Game state ────────────────────────────────────────────────────────────────
let state = 'start';
let score = 0;
let combo = 0;
let consecutivePerfects = 0;
let bgHue = 120;
let speed = 0;
let shakeAmt = 0;
let shakeDecay = 0;
let speedLines = [];
let rings = [];
let ringSpawnDist = 0;
let ringSpawnInterval = 260;
let totalDist = 0;
let frameHue = 120;
let windActive = false;
let windTimer = 0;
let windDir = 0;
let windWarning = false;
let windWarnTimer = 0;

// ── Runner ────────────────────────────────────────────────────────────────────
const runner = {
  x: 0, y: 0,
  vy: 0,
  trail: [],
  linked: false,
  linkFlash: 0,
  perfectFlash: 0,
  squash: 1,
  stretch: 1,
};

// ── Ring definition ───────────────────────────────────────────────────────────
// rings: {x, y, baseX, r, perfectR, z (0..1 depth), sway, swayAmp, swayFreq, swayOff, type:'normal'|'thorn'|'split', partner (for split), inflate, squash, hue, hit, miss, fadeOut}

function getDifficulty(){
  const s = score;
  if(s<10) return {ringR:80,perfectRatio:0.38,swayAmp:0,thorn:false,split:false,wind:false};
  if(s<25) return {ringR:65-s*0.4,perfectRatio:0.33,swayAmp:0,thorn:false,split:false,wind:false};
  if(s<50) return {ringR:55-(s-25)*0.3,perfectRatio:0.30,swayAmp:18+(s-25)*0.8,thorn:false,split:false,wind:false};
  if(s<80) return {ringR:48-(s-50)*0.15,perfectRatio:0.27,swayAmp:28+(s-50)*0.5,thorn:s>65,split:true,wind:false};
  return {ringR:Math.max(28,44-(s-80)*0.1),perfectRatio:0.22,swayAmp:35+(s-80)*0.3,thorn:true,split:true,wind:true};
}

function spawnRing(){
  const d = getDifficulty();
  let r = Math.max(22, d.ringR + (Math.random()-0.5)*12);
  const perfectR = r * d.perfectRatio;
  const isSplit = d.split && Math.random()<0.25 && score>50;
  const isThorn = d.thorn && Math.random()<0.3 && !isSplit;
  const isWind = d.wind && Math.random()<0.18 && !windActive;
  const hue = (bgHue + Math.random()*60 - 30 + 360) % 360;
  const swayAmp = d.swayAmp * (0.7+Math.random()*0.6);
  const swayFreq = 0.8 + Math.random()*0.8;
  const bx = W*0.5 + (Math.random()-0.5)*(W*0.3);

  const ring = {
    x: bx, y: -r-20, baseX: bx,
    r, perfectR, sway: 0, swayAmp, swayFreq, swayOff: Math.random()*Math.PI*2,
    type: isThorn?'thorn':'normal',
    hue, inflate:0, squashY:1, hit:false, miss:false, fadeOut:0,
    isWind, windTriggered:false,
    split: isSplit, partner: null,
  };

  if(isSplit){
    const r2 = Math.max(22, r*(0.85+Math.random()*0.2));
    const pf2 = r2 * d.perfectRatio;
    const bx2 = bx + (Math.random()<0.5?-1:1)*(r+r2+30+Math.random()*30);
    ring.partner = {
      x: bx2, y: -r2-20, baseX: bx2,
      r:r2, perfectR:pf2, sway:0, swayAmp, swayFreq, swayOff: ring.swayOff+Math.PI*0.5,
      type:'normal', hue:(hue+60)%360, inflate:0, squashY:1, hit:false, miss:false, fadeOut:0,
      isWind:false, windTriggered:false, split:false, partner:null,
      isSlave:true,
    };
  }

  rings.push(ring);
}

function initGame(){
  score=0; combo=0; consecutivePerfects=0;
  speed=2.5; totalDist=0; ringSpawnDist=0;
  rings=[]; speedLines=[];
  shakeAmt=0; windActive=false; windTimer=0;
  bgHue=120; frameHue=120;
  runner.x=W*0.5; runner.y=H*0.65;
  runner.vy=0; runner.trail=[];
  runner.linked=false; runner.linkFlash=0; runner.perfectFlash=0;
  runner.squash=1; runner.stretch=1;
  for(let i=0;i<POOL_SIZE;i++) pool[i].active=false;
  // Spawn a few rings ahead
  for(let i=0;i<3;i++){
    spawnRing();
    rings[rings.length-1].y = H*0.15 + i*(H*0.22);
  }
  state='playing';
}

// ── Tap/Input ─────────────────────────────────────────────────────────────────
function onTap(){
  if(state==='start'){initGame();return;}
  if(state==='gameover'){state='start';return;}
  if(state!=='playing') return;
  handleLink();
}

function handleLink(){
  // Find nearest ring (lowest y that is on screen)
  let best = null, bestDist = Infinity;
  for(const ring of rings){
    if(ring.hit||ring.miss||ring.fadeOut>0) continue;
    const candidates = [ring];
    if(ring.partner && !ring.partner.hit && !ring.partner.miss) candidates.push(ring.partner);
    for(const r of candidates){
      const dx = runner.x - r.x;
      const dy = runner.y - r.y;
      const dist = Math.sqrt(dx*dx+dy*dy);
      if(dist < bestDist){ bestDist=dist; best=r; }
    }
  }

  if(!best){ failLink(); return; }

  const dx = runner.x - best.x;
  const dy = runner.y - best.y;
  const dist = Math.sqrt(dx*dx+dy*dy);

  if(dist <= best.r){
    const isPerfect = dist <= best.perfectR;
    successLink(best, isPerfect);
  } else {
    failLink();
  }
}

function successLink(ring, isPerfect){
  ring.hit=true; ring.squashY=0.6;
  runner.linkFlash=1;
  if(isPerfect){
    consecutivePerfects++;
    const multi = Math.min(6, 1 + Math.floor(consecutivePerfects/3));
    const pts = (3)*multi;
    score += pts; combo++;
    runner.perfectFlash=1;
    shakeAmt=4; shakeDecay=0.85;
    spawnBurst(ring.x, ring.y, 22, ring.hue, 'spark');
    spawnBurst(ring.x, ring.y, 10, 60, 'leaf');
  } else {
    consecutivePerfects=0;
    score+=1; combo=0;
    shakeAmt=2; shakeDecay=0.82;
    spawnBurst(ring.x, ring.y, 12, ring.hue, 'leaf');
  }
  saveScores(score);
  speed = Math.min(12, speed + 0.3);
  runner.squash=0.7; runner.stretch=1.4;
  runner.vy = -3;
  bgHue = (bgHue+8)%360;
}

function failLink(){
  state='gameover';
  shakeAmt=14; shakeDecay=0.78;
  spawnBurst(runner.x, runner.y, 30, 0, 'splinter');
  runner.squash=1.5; runner.stretch=0.5;
  saveScores(score);
}

// ── Speed lines ───────────────────────────────────────────────────────────────
function updateSpeedLines(dt){
  if(combo>=3){
    if(Math.random()<0.3*dt*60){
      speedLines.push({x:Math.random()*W, y:0, len:30+Math.random()*60, speed:8+Math.random()*6, alpha:0.6+Math.random()*0.4});
    }
  }
  for(let i=speedLines.length-1;i>=0;i--){
    const sl=speedLines[i];
    sl.y+=sl.speed*dt*60;
    sl.alpha-=0.02*dt*60;
    if(sl.alpha<=0||sl.y>H) speedLines.splice(i,1);
  }
}

// ── Main loop ─────────────────────────────────────────────────────────────────
let last = 0;
function loop(ts){
  requestAnimationFrame(loop);
  const raw = (ts - last)/1000;
  last = ts;
  const dt = Math.max(0.001, Math.min(0.05, raw));

  ctx.save();
  // Screen shake
  if(shakeAmt>0.2){
    const sx=(Math.random()-0.5)*shakeAmt*2;
    const sy=(Math.random()-0.5)*shakeAmt*2;
    ctx.translate(sx,sy);
    shakeAmt*=shakeDecay;
  } else shakeAmt=0;

  drawBackground(dt);

  if(state==='playing') updateGame(dt);

  drawGame(dt);
  drawUI();
  ctx.restore();
}

function drawBackground(dt){
  frameHue += dt*4;
  const hue = state==='playing' ? (bgHue+frameHue*0.1)%360 : 120;
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,`hsl(${hue},55%,8%)`);
  g.addColorStop(1,`hsl(${(hue+40)%360},45%,4%)`);
  ctx.fillStyle=g;
  ctx.fillRect(0,0,W,H);

  // Subtle grid lines (jungle canopy look)
  ctx.strokeStyle=`hsla(${hue},40%,40%,0.04)`;
  ctx.lineWidth=1;
  for(let x=0;x<W;x+=40){
    ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,H);ctx.stroke();
  }
}

function updateGame(dt){
  totalDist += speed*dt*60;
  speed = Math.min(14, 2.5 + totalDist*0.0008 + (score*0.04));

  // Wind
  if(windActive){
    windTimer-=dt;
    runner.x += windDir*2.5*dt*60;
    runner.x = Math.max(20, Math.min(W-20, runner.x));
    if(windTimer<=0) windActive=false;
  }
  if(windWarning){
    windWarnTimer-=dt;
    if(windWarnTimer<=0){ windWarning=false; windActive=true; windTimer=2; }
  }

  // Runner gravity & drift back to center
  runner.vy += 0.18*dt*60;
  runner.y += runner.vy*dt*60;
  runner.y = Math.max(H*0.1, Math.min(H*0.85, runner.y));
  if(runner.y >= H*0.85) runner.vy=0;

  // Trail
  runner.trail.unshift({x:runner.x, y:runner.y, alpha:1});
  if(runner.trail.length>12) runner.trail.pop();
  for(const t of runner.trail) t.alpha*=0.85;

  // Squash recover
  runner.squash += (1-runner.squash)*0.15*dt*60;
  runner.stretch += (1-runner.stretch)*0.15*dt*60;
  runner.linkFlash *= 0.88;
  runner.perfectFlash *= 0.88;

  // Rings
  ringSpawnDist += speed*dt*60;
  ringSpawnInterval = Math.max(150, 260 - score*1.2);
  if(ringSpawnDist >= ringSpawnInterval){
    ringSpawnDist=0; spawnRing();
  }

  for(let i=rings.length-1;i>=0;i--){
    const ring=rings[i];
    ring.y += speed*dt*60*0.55;
    ring.sway = ring.swayAmp * Math.sin(totalDist*0.015*ring.swayFreq+ring.swayOff);
    ring.x = ring.baseX + ring.sway;

    if(ring.partner){
      ring.partner.y = ring.y;
      ring.partner.sway = ring.swayAmp * Math.sin(totalDist*0.015*ring.partner.swayFreq+ring.partner.swayOff);
      ring.partner.x = ring.partner.baseX + ring.partner.sway;
    }

    // Inflate when near runner
    const dx=runner.x-ring.x, dy=runner.y-ring.y;
    const dist=Math.sqrt(dx*dx+dy*dy);
    ring.inflate = Math.max(0, 1-(dist/(ring.r*3)));
    ring.squashY += (1-ring.squashY)*0.2*dt*60;

    // Wind trigger
    if(ring.isWind && !ring.windTriggered && ring.y > H*0.2){
      ring.windTriggered=true;
      if(!windActive && !windWarning){
        windWarning=true; windWarnTimer=1.2;
        windDir=(Math.random()<0.5?-1:1);
      }
    }

    // Fade out hit rings
    if(ring.hit||ring.miss){ ring.fadeOut+=dt*3; }
    if(ring.y>H+80 || ring.fadeOut>=1) rings.splice(i,1);

    // Miss detection: passed runner y
    if(!ring.hit && !ring.miss && ring.y > runner.y+ring.r+10){
      // If runner never tapped this ring, just let it scroll off (no auto-fail)
    }
  }

  updateSpeedLines(dt);

  // Particles
  for(const p of pool){
    if(!p.active) continue;
    p.x+=p.vx*dt*60; p.y+=p.vy*dt*60;
    p.vy+=0.12*dt*60;
    p.life-=dt;
    p.alpha=Math.max(0,p.life/p.maxLife);
    if(p.life<=0) p.active=false;
  }
}

function drawGame(dt){
  // Speed lines
  if(combo>=3){
    ctx.save();
    for(const sl of speedLines){
      ctx.strokeStyle=`hsla(${bgHue},80%,70%,${sl.alpha*0.3})`;
      ctx.lineWidth=1.5;
      ctx.beginPath();ctx.moveTo(sl.x,sl.y);ctx.lineTo(sl.x,sl.y+sl.len);ctx.stroke();
    }
    ctx.restore();
  }

  // Rings
  for(const ring of rings){
    drawRing(ring);
    if(ring.partner) drawRing(ring.partner);
  }

  // Wind warning
  if(windWarning){
    ctx.save();
    const wAlpha=0.4+0.4*Math.sin(Date.now()*0.01);
    ctx.fillStyle=`hsla(40,100%,60%,${wAlpha})`;
    ctx.font=`bold ${Math.round(W*0.045)}px sans-serif`;
    ctx.textAlign='center';
    ctx.fillText('⚠ WIND GUST!', W*0.5, H*0.12);
    ctx.restore();
  }

  // Runner trail
  ctx.save();
  for(let i=runner.trail.length-1;i>=0;i--){
    const t=runner.trail[i];
    const sz=8*(1-i/runner.trail.length);
    ctx.globalAlpha=t.alpha*0.4;
    ctx.fillStyle=`hsl(${bgHue},80%,65%)`;
    ctx.beginPath();ctx.arc(t.x,t.y,sz,0,Math.PI*2);ctx.fill();
  }
  ctx.globalAlpha=1;
  ctx.restore();

  // Runner
  drawRunner();

  // Particles
  ctx.save();
  for(const p of pool){
    if(!p.active) continue;
    ctx.globalAlpha=p.alpha;
    if(p.type==='spark'){
      ctx.fillStyle=`hsl(${p.hue},100%,70%)`;
      ctx.shadowColor=`hsl(${p.hue},100%,80%)`;
      ctx.shadowBlur=6;
    } else if(p.type==='leaf'){
      ctx.fillStyle=`hsl(${p.hue},70%,55%)`;
      ctx.shadowBlur=0;
    } else {
      ctx.fillStyle=`hsl(${p.hue},80%,60%)`;
      ctx.shadowBlur=0;
    }
    ctx.beginPath();ctx.arc(p.x,p.y,p.r,0,Math.PI*2);ctx.fill();
  }
  ctx.globalAlpha=1;ctx.shadowBlur=0;
  ctx.restore();
}

function drawRing(ring){
  if(ring.fadeOut>=1) return;
  const fo=ring.fadeOut;
  const alpha=fo>0?(1-fo):1;
  const inflate=ring.inflate*0.12;
  const rr=ring.r*(1+inflate);
  const pr=ring.perfectR*(1+inflate*0.5);
  const sy=ring.squashY;

  ctx.save();
  ctx.globalAlpha=alpha;
  ctx.translate(ring.x, ring.y);
  ctx.scale(1, sy);

  // Outer glow
  const glow=ctx.createRadialGradient(0,0,rr*0.7,0,0,rr+18);
  glow.addColorStop(0,`hsla(${ring.hue},80%,60%,0.0)`);
  glow.addColorStop(0.6,`hsla(${ring.hue},80%,60%,0.18)`);
  glow.addColorStop(1,`hsla(${ring.hue},80%,60%,0.0)`);
  ctx.fillStyle=glow;
  ctx.beginPath();ctx.arc(0,0,rr+18,0,Math.PI*2);ctx.fill();

  // Ring body
  ctx.strokeStyle=`hsl(${ring.hue},85%,${ring.type==='thorn'?45:62}%)`;
  ctx.lineWidth=ring.type==='thorn'?4:3.5;
  ctx.shadowColor=`hsl(${ring.hue},90%,70%)`;
  ctx.shadowBlur=12+inflate*20;
  ctx.beginPath();ctx.arc(0,0,rr,0,Math.PI*2);ctx.stroke();
  ctx.shadowBlur=0;

  // Thorn spikes
  if(ring.type==='thorn'){
    const n=8;
    ctx.strokeStyle=`hsl(${ring.hue},70%,40%)`;
    ctx.lineWidth=2;
    for(let i=0;i<n;i++){
      const a=i/n*Math.PI*2;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a)*(rr-4),Math.sin(a)*(rr-4));
      ctx.lineTo(Math.cos(a)*(rr+10),Math.sin(a)*(rr+10));
      ctx.stroke();
    }
  }

  // Perfect core
  const pg=ctx.createRadialGradient(0,0,0,0,0,pr);
  pg.addColorStop(0,`hsla(60,100%,80%,0.55)`);
  pg.addColorStop(0.6,`hsla(50,100%,65%,0.3)`);
  pg.addColorStop(1,`hsla(40,100%,60%,0.0)`);
  ctx.fillStyle=pg;
  ctx.beginPath();ctx.arc(0,0,pr,0,Math.PI*2);ctx.fill();
  ctx.strokeStyle=`hsla(55,100%,75%,0.7)`;
  ctx.lineWidth=1.5;
  ctx.beginPath();ctx.arc(0,0,pr,0,Math.PI*2);ctx.stroke();

  // Wind ring indicator
  if(ring.isWind && !ring.windTriggered){
    ctx.strokeStyle=`hsla(40,100%,70%,0.8)`;
    ctx.lineWidth=2;
    ctx.setLineDash([5,5]);
    ctx.beginPath();ctx.arc(0,0,rr+8,0,Math.PI*2);ctx.stroke();
    ctx.setLineDash([]);
  }

  ctx.restore();
}

function drawRunner(){
  const rx=runner.x, ry=runner.y;
  const sx=runner.squash, sy=runner.stretch;
  const baseR=12;

  ctx.save();
  ctx.translate(rx,ry);
  ctx.scale(sx,sy);

  // Glow
  if(runner.perfectFlash>0.1){
    ctx.shadowColor=`hsl(55,100%,75%)`;
    ctx.shadowBlur=24*runner.perfectFlash;
  } else if(runner.linkFlash>0.1){
    ctx.shadowColor=`hsl(${bgHue},90%,70%)`;
    ctx.shadowBlur=16*runner.linkFlash;
  }

  // Body
  const rg=ctx.createRadialGradient(0,-2,1,0,0,baseR);
  rg.addColorStop(0,`hsl(${bgHue},85%,80%)`);
  rg.addColorStop(0.6,`hsl(${bgHue},75%,55%)`);
  rg.addColorStop(1,`hsl(${bgHue},70%,35%)`);
  ctx.fillStyle=rg;
  ctx.beginPath();ctx.arc(0,0,baseR,0,Math.PI*2);ctx.fill();

  // Eye
  ctx.fillStyle='#fff';
  ctx.beginPath();ctx.arc(4,-3,3.5,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#1a1a1a';
  ctx.beginPath();ctx.arc(5,-3,2,0,Math.PI*2);ctx.fill();

  ctx.shadowBlur=0;
  ctx.restore();
}

function drawUI(){
  const fs = Math.round(W*0.05);
  ctx.save();

  if(state==='start'){
    // Title
    ctx.fillStyle=`hsl(${bgHue+40},85%,70%)`;
    ctx.font=`bold ${Math.round(W*0.12)}px sans-serif`;
    ctx.textAlign='center';
    ctx.shadowColor=`hsl(${bgHue},80%,50%)`;
    ctx.shadowBlur=20;
    ctx.fillText('JUNGLE', W*0.5, H*0.3);
    ctx.fillStyle=`hsl(${bgHue},90%,65%)`;
    ctx.fillText('LINK', W*0.5, H*0.3+Math.round(W*0.13));
    ctx.shadowBlur=0;

    ctx.fillStyle='rgba(255,255,255,0.8)';
    ctx.font=`${Math.round(W*0.045)}px sans-serif`;
    ctx.fillText('Tap to zip through vine rings!', W*0.5, H*0.52);

    ctx.fillStyle='rgba(255,255,255,0.55)';
    ctx.font=`${Math.round(W*0.036)}px sans-serif`;
    ctx.fillText('Tap / Space / Enter to start', W*0.5, H*0.6);

    if(hiScore>0){
      ctx.fillStyle=`hsl(55,100%,70%)`;
      ctx.font=`${Math.round(W*0.038)}px sans-serif`;
      ctx.fillText(`Best: ${hiScore}`, W*0.5, H*0.68);
    }
    if(challengeScore>0){
      ctx.fillStyle=`hsl(30,100%,65%)`;
      ctx.font=`${Math.round(W*0.038)}px sans-serif`;
      ctx.fillText(`Challenge: Beat ${challengeScore}!`, W*0.5, H*0.74);
    }
    if(todayBest>0){
      ctx.fillStyle='rgba(255,255,255,0.45)';
      ctx.font=`${Math.round(W*0.032)}px sans-serif`;
      ctx.fillText(`Today: ${todayBest}`, W*0.5, H*0.80);
    }
  }

  if(state==='playing'){
    // Score
    ctx.fillStyle='rgba(255,255,255,0.92)';
    ctx.font=`bold ${Math.round(W*0.072)}px sans-serif`;
    ctx.textAlign='center';
    ctx.fillText(score, W*0.5, Math.round(H*0.08));

    // Combo
    if(consecutivePerfects>=3){
      const multi=Math.min(6,1+Math.floor(consecutivePerfects/3));
      ctx.fillStyle=`hsl(55,100%,65%)`;
      ctx.font=`bold ${Math.round(W*0.048)}px sans-serif`;
      ctx.fillText(`x${multi} COMBO!`, W*0.5, Math.round(H*0.14));
    }

    // Hi score marker
    if(hiScore>0&&score<=hiScore){
      ctx.fillStyle='rgba(255,255,255,0.3)';
      ctx.font=`${Math.round(W*0.03)}px sans-serif`;
      ctx.fillText(`HI ${hiScore}`, W*0.5, Math.round(H*0.04));
    }
  }

  if(state==='gameover'){
    ctx.fillStyle='rgba(0,0,0,0.55)';
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle='hsl(0,85%,65%)';
    ctx.font=`bold ${Math.round(W*0.1)}px sans-serif`;
    ctx.textAlign='center';
    ctx.shadowColor='hsl(0,80%,40%)';
    ctx.shadowBlur=16;
    ctx.fillText('GAME OVER', W*0.5, H*0.28);
    ctx.shadowBlur=0;

    ctx.fillStyle='rgba(255,255,255,0.95)';
    ctx.font=`bold ${Math.round(W*0.13)}px sans-serif`;
    ctx.fillText(score, W*0.5, H*0.42);

    ctx.fillStyle='rgba(255,255,255,0.6)';
    ctx.font=`${Math.round(W*0.038)}px sans-serif`;
    ctx.fillText('Score', W*0.5, H*0.48);

    if(score>=hiScore&&score>0){
      ctx.fillStyle=`hsl(55,100%,70%)`;
      ctx.font=`bold ${Math.round(W*0.042)}px sans-serif`;
      ctx.fillText('NEW BEST!', W*0.5, H*0.55);
    } else if(hiScore>0){
      ctx.fillStyle='rgba(255,255,255,0.45)';
      ctx.font=`${Math.round(W*0.036)}px sans-serif`;
      ctx.fillText(`Best: ${hiScore}`, W*0.5, H*0.55);
    }

    // Share button
    const bw=Math.round(W*0.58), bh=Math.round(H*0.065);
    const bx=W*0.5-bw*0.5, by=H*0.63;
    ctx.fillStyle=`hsl(${bgHue},65%,40%)`;
    roundRect(ctx,bx,by,bw,bh,bh*0.4);
    ctx.fill();
    ctx.strokeStyle=`hsl(${bgHue},80%,65%)`;
    ctx.lineWidth=1.5;
    roundRect(ctx,bx,by,bw,bh,bh*0.4);
    ctx.stroke();
    ctx.fillStyle='rgba(255,255,255,0.95)';
    ctx.font=`${Math.round(W*0.04)}px sans-serif`;
    ctx.fillText('Share Score', W*0.5, by+bh*0.65);

    // Tap again
    const pulse=0.7+0.3*Math.sin(Date.now()*0.004);
    ctx.fillStyle=`rgba(255,255,255,${pulse*0.6})`;
    ctx.font=`${Math.round(W*0.036)}px sans-serif`;
    ctx.fillText('Tap to play again', W*0.5, H*0.82);
  }

  ctx.restore();
}

function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y);
  ctx.arcTo(x+w,y,x+w,y+r,r);
  ctx.lineTo(x+w,y+h-r);
  ctx.arcTo(x+w,y+h,x+w-r,y+h,r);
  ctx.lineTo(x+r,y+h);
  ctx.arcTo(x,y+h,x,y+h-r,r);
  ctx.lineTo(x,y+r);
  ctx.arcTo(x,y,x+r,y,r);
  ctx.closePath();
}

// ── Share ─────────────────────────────────────────────────────────────────────
function shareScore(){
  const url=`https://balinti.github.io/jungle-link/?challenge=${score}`;
  const text=`I scored ${score} in Jungle Link! Can you beat me? ${url}`;
  if(navigator.share){
    navigator.share({title:'Jungle Link',text,url}).catch(()=>{});
  } else {
    try{navigator.clipboard.writeText(text);}catch(e){}
    alert('Challenge link copied!\n'+url);
  }
}

// ── Input handling ─────────────────────────────────────────────────────────────
canvas.addEventListener('pointerdown', e=>{
  e.preventDefault();
  if(state==='gameover'){
    // Check share button
    const bw=Math.round(W*0.58), bh=Math.round(H*0.065);
    const bx=W*0.5-bw*0.5, by=H*0.63;
    const rect=canvas.getBoundingClientRect();
    const cx=(e.clientX-rect.left)*(W/rect.width);
    const cy=(e.clientY-rect.top)*(H/rect.height);
    if(cx>=bx&&cx<=bx+bw&&cy>=by&&cy<=by+bh){ shareScore(); return; }
  }
  onTap();
},{passive:false});

document.addEventListener('keydown', e=>{
  if(e.code==='Space'||e.code==='Enter'){
    e.preventDefault();
    onTap();
  }
});

// ── Boot ──────────────────────────────────────────────────────────────────────
requestAnimationFrame(ts=>{ last=ts; requestAnimationFrame(loop); });

})();
</script>
</body>
</html>
